<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>手撕 - hao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="hao"><meta name="msapplication-TileImage" content="/img/2751710164138_.pic.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="hao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="hao"><meta property="og:url" content="https://jerryzhu1229.github.io/2024/01/26/%E7%AE%97%E6%B3%95/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%92%95/"><meta property="og:site_name" content="hao"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png"><meta property="article:published_time" content="2024-01-25T16:33:05.000Z"><meta property="article:author" content="Jerry Z"><meta property="article:tag" content="算法"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jerryzhu1229.github.io/pic/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerryzhu1229.github.io/2024/01/26/%E7%AE%97%E6%B3%95/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%92%95/"},"headline":"手撕","image":["https://jerryzhu1229.github.io/pic/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png"],"datePublished":"2024-01-25T16:33:05.000Z","author":{"@type":"Person","name":"Jerry Z"},"publisher":{"@type":"Organization","name":"hao","logo":{"@type":"ImageObject","url":"https://jerryzhu1229.github.io/img/2751710164138_.pic.jpg"}},"description":""}</script><link rel="canonical" href="https://jerryzhu1229.github.io/2024/01/26/%E7%AE%97%E6%B3%95/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%92%95/"><link rel="icon" href="/img/2751710164138_.pic.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/cs">计算机基础</a><a class="navbar-item" href="/categories/java">后端开发</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jerryzhu1229"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-01-25T16:33:05.000Z" title="2024/1/26 00:33:05">2024-01-26</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><span class="level-item">1 小时读完 (大约9924个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">手撕</h1><div class="content"><html><head></head><body><h1 id="题库目录"><a href="#题库目录" class="headerlink" title="题库目录"></a>题库目录</h1><table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
<th>类型</th>
<th>掌握程度</th>
</tr>
</thead>
<tbody><tr>
<td>438. 找到字符串中所有字母异位词</td>
<td>中等</td>
<td>滑动窗口+哈希表</td>
<td>⭐</td>
</tr>
<tr>
<td>189. 轮转数组</td>
<td>中等</td>
<td>翻转前要mod</td>
<td>⭐三种方法</td>
</tr>
<tr>
<td>238. 除自身以外数组的乘积</td>
<td>中等</td>
<td>前缀和</td>
<td>⭐</td>
</tr>
<tr>
<td>41. 缺失的第一个正数</td>
<td>困难</td>
<td>原地哈希</td>
<td>⭐</td>
</tr>
<tr>
<td>73. 矩阵置零</td>
<td>中等</td>
<td></td>
<td>⭐空间复杂度O(mn)<del>O(m+n)</del>O(1)</td>
</tr>
<tr>
<td>54. 螺旋矩阵</td>
<td>中等</td>
<td></td>
<td>⭐上下左右四个分界线</td>
</tr>
<tr>
<td>206. 反转链表</td>
<td>简单</td>
<td>迭代、递归</td>
<td></td>
</tr>
<tr>
<td>234. 回文链表</td>
<td>简单</td>
<td>双指针找中间节点，翻转链表</td>
<td></td>
</tr>
<tr>
<td>142. 环形链表 II</td>
<td>中等</td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td>2. 两数相加</td>
<td>中等</td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td>19. 删除链表的倒数第 N 个结点</td>
<td>中等</td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td>24. 两两交换链表中的节点</td>
<td>中等</td>
<td>递归⭐、迭代</td>
<td></td>
</tr>
<tr>
<td>25. K 个一组翻转链表</td>
<td>困难</td>
<td>递归</td>
<td></td>
</tr>
<tr>
<td>138. 随机链表的复制</td>
<td>中等</td>
<td>哈希表</td>
<td></td>
</tr>
<tr>
<td>148. 排序链表</td>
<td>中等</td>
<td>归并（找中点直到一个元素，然后合并）</td>
<td>⭐注意当只剩下一个元素就要跳出循环</td>
</tr>
<tr>
<td>23. 合并 K 个升序链表</td>
<td>困难</td>
<td>归并、优先队列</td>
<td>⭐</td>
</tr>
<tr>
<td>146. LRU 缓存</td>
<td>中等</td>
<td>哈希+双向链表</td>
<td>⭐⭐</td>
</tr>
<tr>
<td>94. 二叉树的中序遍历</td>
<td>简单</td>
<td>递归、栈迭代（颜色法）⭐</td>
<td>⭐⭐前中后的迭代法</td>
</tr>
<tr>
<td>101. 对称二叉树</td>
<td>简单</td>
<td>dfs-递归、bfs-迭代⭐</td>
<td></td>
</tr>
<tr>
<td>543. 二叉树的直径</td>
<td>简单</td>
<td>dfs</td>
<td>⭐</td>
</tr>
<tr>
<td>108. 将有序数组转换为二叉搜索树</td>
<td>简单</td>
<td>分治</td>
<td></td>
</tr>
<tr>
<td>98. 验证二叉搜索树</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>114. 二叉树展开为链表</td>
<td>中等</td>
<td>后续遍历</td>
<td>⭐</td>
</tr>
<tr>
<td>45. 跳跃游戏 II</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1190. 反转每对括号间的子串</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>781. 森林中的兔子</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>739. 每日温度</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3. 无重复字符的最长子串</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>46. 全排列</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>475. 供暖器</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>20. 有效的括号</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>394. 字符串解码</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>179. 最大数</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LCP 09. 最小跳跃次数</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>135. 分发糖果</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>面试题 17.24. 最大子矩阵</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1. 两数之和</td>
<td>简单</td>
<td>哈希</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>49. 字母异位词分组</td>
<td>中等</td>
<td>哈希</td>
<td>⭐注意char[]如何转换String</td>
</tr>
<tr>
<td>128.最长连续序列</td>
<td>中等</td>
<td>哈希</td>
<td>⭐</td>
</tr>
<tr>
<td>42. 接雨水</td>
<td>困难</td>
<td>单调栈</td>
<td></td>
</tr>
<tr>
<td>22. 括号生成</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>554. 砖墙</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>547. 省份数量</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>55. 跳跃游戏</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>621. 任务调度器</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1047. 删除字符串中的所有相邻重复项</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>514. 自由之路</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5. 最长回文子串</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14. 最长公共前缀</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>300. 最长递增子序列</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>56. 合并区间</td>
<td>中等</td>
<td>排序+双指针</td>
<td>⭐⭐</td>
</tr>
<tr>
<td>200. 岛屿数量</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11. 盛最多水的容器</td>
<td>中等</td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td>799. 香槟塔</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>316. 去除重复字母</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>392. 判断子序列</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>85. 最大矩形</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>221. 最大正方形</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>32. 最长有效括号</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>62. 不同路径</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>130. 被围绕的区域</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>679. 24 点游戏</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>70. 爬楼梯</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17. 电话号码的字母组合</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15. 三数之和</td>
<td>中等</td>
<td>双指针</td>
<td>⭐</td>
</tr>
<tr>
<td>151. 翻转字符串里的单词</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>957. N 天后的牢房</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>518. 零钱兑换 II</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>139. 单词拆分</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>179. 最大数</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>410. 分割数组的最大值</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>47. 全排列 II</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>860. 柠檬水找零</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>90. 子集 II</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>980. 不同路径 III</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>471. 编码最短长度的字符串</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>93. 复原 IP 地址</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>224. 基本计算器</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4. 寻找两个正序数组的中位数</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>88. 合并两个有序数组</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>692. 前K个高频单词</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>38. 外观数列</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>64. 最小路径和</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30. 串联所有单词的子串</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>735. 行星碰撞</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>165. 比较版本号</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>354. 俄罗斯套娃信封问题</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1160. 拼写单词</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>678. 有效的括号字符串</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>102. 二叉树的层序遍历</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>287. 寻找重复数</td>
<td>中等</td>
<td>二分法、快慢指针</td>
<td>⭐⭐</td>
</tr>
<tr>
<td>16. 最接近的三数之和</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>264. 丑数 II</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>1293. 网格中的最短路径</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>剑指 Offer 38. 字符串的排列</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40. 组合总和 II</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>746. 使用最小花费爬楼梯</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>974. 和可被 K 整除的子数组</td>
<td>中等</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>685. 冗余连接 II</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>260. 只出现一次的数字 III</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>37. 解数独</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>72. 编辑距离</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>695. 岛屿的最大面积</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>36. 有效的数独</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>84. 柱状图中最大的矩形</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>148. 排序链表</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>199. 二叉树的右视图</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>121. 买卖股票的最佳时机</td>
<td>简单</td>
<td>dp</td>
<td></td>
</tr>
<tr>
<td>322. 零钱兑换</td>
<td>中等</td>
<td>dp</td>
<td></td>
</tr>
<tr>
<td>741. 摘樱桃</td>
<td>困难</td>
<td>[记忆化搜索](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup/solutions/2766975/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-ruue/">741. 摘樱桃 - 力扣（LeetCode）</a>)</td>
<td>⭐</td>
</tr>
<tr>
<td>214. 最短回文串</td>
<td>困难</td>
<td>kmp</td>
<td>⭐</td>
</tr>
<tr>
<td>406. 根据身高重建队列</td>
<td>中等</td>
<td>贪心</td>
<td>⭐</td>
</tr>
<tr>
<td>1162. 地图分析</td>
<td>中等</td>
<td>bfs</td>
<td>⭐</td>
</tr>
<tr>
<td>402. 移掉 K 位数字</td>
<td>中等</td>
<td>单调栈</td>
<td></td>
</tr>
<tr>
<td>343. 整数拆分</td>
<td>中等</td>
<td>dp</td>
<td>⭐</td>
</tr>
<tr>
<td>617. 合并二叉树</td>
<td>简单</td>
<td>dfs</td>
<td></td>
</tr>
<tr>
<td>387. 字符串中的第一个唯一字符</td>
<td>简单</td>
<td>哈希表、数组</td>
<td></td>
</tr>
<tr>
<td>76. 最小覆盖子串</td>
<td>困难</td>
<td>滑动窗口</td>
<td>⭐</td>
</tr>
<tr>
<td>34. 在排序数组中查找元素的第一个和最后一个位置</td>
<td>中等</td>
<td>二分</td>
<td></td>
</tr>
<tr>
<td>29. 两数相除</td>
<td>中等</td>
<td>位运算</td>
<td>⭐</td>
</tr>
<tr>
<td>105. 从前序与中序遍历序列构造二叉树</td>
<td>中等</td>
<td>分治</td>
<td></td>
</tr>
<tr>
<td>451. 根据字符出现频率排序</td>
<td>中等</td>
<td>哈希表+优先队列</td>
<td></td>
</tr>
<tr>
<td>1109. 航班预订统计</td>
<td>中等</td>
<td>差分</td>
<td>⭐</td>
</tr>
<tr>
<td>166. 分数到小数</td>
<td>中等</td>
<td>模拟</td>
<td>⭐</td>
</tr>
<tr>
<td>278. 第一个错误的版本</td>
<td>简单</td>
<td>二分</td>
<td></td>
</tr>
<tr>
<td>207. 课程表</td>
<td>中等</td>
<td>bfs</td>
<td>⭐</td>
</tr>
<tr>
<td>875. 爱吃香蕉的珂珂</td>
<td>中等</td>
<td>二分</td>
<td></td>
</tr>
<tr>
<td>134. 加油站</td>
<td>中等</td>
<td>后缀和</td>
<td></td>
</tr>
<tr>
<td>剑指 Offer 22. 链表中倒数第k个节点</td>
<td>简单</td>
<td>双指针</td>
<td></td>
</tr>
<tr>
<td>611. 有效三角形的个数</td>
<td>中等</td>
<td>双指针</td>
<td>⭐</td>
</tr>
<tr>
<td>LCR 182. 动态口令</td>
<td>简单</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>面试题 02.05. 链表求和</td>
<td>中等</td>
<td>正向——栈</td>
<td></td>
</tr>
<tr>
<td>面试题 01.06. 字符串压缩</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>239. 滑动窗口的最大值</td>
<td>困难</td>
<td>优先队列</td>
<td>⭐⭐</td>
</tr>
<tr>
<td>155. 最小栈</td>
<td>中等</td>
<td>栈</td>
<td>⭐</td>
</tr>
<tr>
<td>LCR 120. 寻找文件副本</td>
<td>简单</td>
<td>初级：哈希表 进阶：原地交换</td>
<td>⭐</td>
</tr>
<tr>
<td>面试题 08.11. 硬币</td>
<td>中等</td>
<td>完全0-1背包问题</td>
<td>⭐</td>
</tr>
<tr>
<td>剑指 Offer 50. 第一个只出现一次的字符</td>
<td>简单</td>
<td>哈希</td>
<td></td>
</tr>
<tr>
<td>994. 腐烂的橘子</td>
<td>中等</td>
<td>bfs</td>
<td></td>
</tr>
<tr>
<td>70. 爬楼梯</td>
<td>简单</td>
<td>dp</td>
<td></td>
</tr>
<tr>
<td>剑指 Offer 13. 机器人的运动范围</td>
<td>中等</td>
<td>dfs、bfs</td>
<td></td>
</tr>
<tr>
<td>1004. 最大连续1的个数 III</td>
<td>中等</td>
<td>滑动窗口</td>
<td>⭐</td>
</tr>
<tr>
<td>\1494. 并行课程 II</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1386. 安排电影院座位</td>
<td>中等</td>
<td>状态压缩</td>
<td>⭐</td>
</tr>
<tr>
<td>349. 两个数组的交集</td>
<td>简单</td>
<td>哈希表</td>
<td></td>
</tr>
<tr>
<td>397. 整数替换</td>
<td>中等</td>
<td>记忆化搜索</td>
<td>⭐</td>
</tr>
<tr>
<td>63. 不同路径 II</td>
<td>中等</td>
<td>dp</td>
<td></td>
</tr>
<tr>
<td>371. 两整数之和</td>
<td>中等</td>
<td>位运算</td>
<td></td>
</tr>
<tr>
<td>373. 查找和最小的K对数字</td>
<td>中等</td>
<td>优先队列</td>
<td>⭐</td>
</tr>
<tr>
<td>面试题 17.21. 直方图的水量（接雨水）</td>
<td>困难</td>
<td>单调栈、双指针</td>
<td>⭐⭐</td>
</tr>
<tr>
<td>847. 访问所有节点的最短路径</td>
<td>困难</td>
<td>状态压缩、bfs</td>
<td>⭐</td>
</tr>
<tr>
<td>面试题 04.01. 节点间通路</td>
<td>中等</td>
<td>bfs、dfs</td>
<td></td>
</tr>
<tr>
<td>剑指 Offer 05. 替换空格</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>面试题 16.19. 水域大小</td>
<td>中等</td>
<td>bfs、dfs</td>
<td></td>
</tr>
<tr>
<td>\1723. 完成所有工作的最短时间</td>
<td>困难</td>
<td></td>
<td></td>
</tr>
<tr>
<td>874. 模拟行走机器人</td>
<td>中等</td>
<td>模拟</td>
<td></td>
</tr>
<tr>
<td>263. 丑数</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>934. 最短的桥</td>
<td>中等</td>
<td>dfs+bfs</td>
<td></td>
</tr>
<tr>
<td>1497. 检查数组对是否可以被 k 整除</td>
<td>中等</td>
<td>哈希表</td>
<td>⭐</td>
</tr>
<tr>
<td>\1755. 最接近目标值的子序列和</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7. 整数反转</td>
<td>中等</td>
<td>位运算</td>
<td>⭐</td>
</tr>
<tr>
<td>43. 字符串相乘</td>
<td>中等</td>
<td>模拟</td>
<td></td>
</tr>
<tr>
<td>203. 移除链表元素</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>242. 有效的字母异位词</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>13. 罗马数字转整数</td>
<td>简单</td>
<td>哈希</td>
<td></td>
</tr>
<tr>
<td>58. 最后一个单词的长度</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>198. 打家劫舍</td>
<td>中等</td>
<td>dp</td>
<td></td>
</tr>
<tr>
<td>235. 二叉搜索树的最近公共祖先</td>
<td>简单</td>
<td>二叉搜索树</td>
<td>⭐</td>
</tr>
<tr>
<td>279. 完全平方数</td>
<td>中等</td>
<td>dp、完全背包问题</td>
<td>⭐</td>
</tr>
<tr>
<td>403. 青蛙过河</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>415. 字符串相加</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>442. 数组中重复的数据</td>
<td>中等</td>
<td>原地哈希</td>
<td>同41. 缺失的第一个正数</td>
</tr>
<tr>
<td>593. 有效的正方形</td>
<td>中等</td>
<td>数学</td>
<td>⭐</td>
</tr>
<tr>
<td>227. 基本计算器 II</td>
<td>中等</td>
<td>栈</td>
<td>⭐</td>
</tr>
<tr>
<td>647. 回文子串</td>
<td>中等</td>
<td>中心 扩展</td>
<td></td>
</tr>
<tr>
<td>204. 计数质数</td>
<td>中等</td>
<td>埃氏筛</td>
<td>⭐</td>
</tr>
<tr>
<td>48. 旋转图像</td>
<td>中等</td>
<td>模拟原地，水平翻转+对角线翻转</td>
<td></td>
</tr>
<tr>
<td>171. Excel 表列序号</td>
<td>简单</td>
<td>进制</td>
<td></td>
</tr>
<tr>
<td>301. 删除无效的括号</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>208. 实现 Trie (前缀树)</td>
<td>中等</td>
<td>字典树</td>
<td>⭐</td>
</tr>
<tr>
<td>1013. 将数组分成和相等的三个部分</td>
<td>简单</td>
<td>前缀和</td>
<td></td>
</tr>
<tr>
<td>445. 两数相加 II</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>350. 两个数组的交集 II</td>
<td>简单</td>
<td>哈希表</td>
<td></td>
</tr>
<tr>
<td>870. 优势洗牌</td>
<td>中等</td>
<td>贪心+双指针</td>
<td></td>
</tr>
<tr>
<td>77. 组合</td>
<td>中等</td>
<td>dfs+回溯剪枝</td>
<td></td>
</tr>
<tr>
<td>539. 最小时间差</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>881. 救生艇</td>
<td>中等</td>
<td>双指针</td>
<td>⭐</td>
</tr>
<tr>
<td>98. 验证二叉搜索树</td>
<td>中等</td>
<td>中序遍历</td>
<td></td>
</tr>
<tr>
<td>75. 颜色分类</td>
<td>中等</td>
<td>双指针</td>
<td>⭐</td>
</tr>
<tr>
<td>210. 课程表 II</td>
<td>中等</td>
<td>拓扑排序（bfs+queue+map）</td>
<td></td>
</tr>
<tr>
<td>976. 三角形的最大周长</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>850. 矩形面积 II</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>605. 种花问题</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>152. 乘积最大子数组</td>
<td>中等</td>
<td>dp</td>
<td>⭐ 面经</td>
</tr>
<tr>
<td>78. 子集</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>560. 和为 K 的子数组</td>
<td>中等</td>
<td>前缀和+哈希</td>
<td>⭐</td>
</tr>
<tr>
<td>234. 回文链表</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6. Z 字形变换</td>
<td>中等</td>
<td>模拟</td>
<td></td>
</tr>
<tr>
<td>44. 通配符匹配</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>233. 数字 1 的个数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1044. 最长重复子串</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>820. 单词的压缩编码</td>
<td>中等</td>
<td>字典树</td>
<td>⭐</td>
</tr>
<tr>
<td>315. 计算右侧小于当前元素的个数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>172. 阶乘后的零</td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>39. 组合总和</td>
<td>中等</td>
<td>dfs、dp</td>
<td></td>
</tr>
<tr>
<td>79. 单词搜索</td>
<td>中等</td>
<td>dfs</td>
<td></td>
</tr>
<tr>
<td>160. 相交链表</td>
<td>简单</td>
<td>哈希、双指针</td>
<td></td>
</tr>
<tr>
<td>223. 矩形面积</td>
<td>中等</td>
<td>数学</td>
<td>⭐</td>
</tr>
<tr>
<td>338. 比特位计数</td>
<td>简单</td>
<td>dp</td>
<td>⭐</td>
</tr>
<tr>
<td>468. 验证IP地址</td>
<td>中等</td>
<td>模拟</td>
<td>⭐ split toLowerCase</td>
</tr>
<tr>
<td>136. 只出现一次的数字</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>中等</td>
<td></td>
<td></td>
</tr>
<tr>
<td>169. 多数元素</td>
<td>简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>188. 买卖股票的最佳时机 IV</td>
<td>困难</td>
<td></td>
<td>⭐</td>
</tr>
<tr>
<td>231. 2 的幂</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="笔试复盘"><a href="#笔试复盘" class="headerlink" title="笔试复盘"></a>笔试复盘</h1><h2 id="题目：老鼠串门"><a href="#题目：老鼠串门" class="headerlink" title="题目：老鼠串门"></a>题目：老鼠串门</h2><p>现有一个狭小的老鼠洞，每次仅能一只老鼠进或者出（类似于栈的特性），如果通道里有多只老鼠，那么先进洞的老鼠会比晚进洞的老鼠出来更晚，假如有一窝老鼠来串门，我们给每只老鼠单独编个数字号码，1、2、3…允许老鼠进洞后，又出洞，再次进洞，且若众多老鼠都挤满到洞口了，则不再会有老鼠进洞，最后出洞的顺序就按洞口到洞底的老鼠编号输出。假如老鼠进洞的顺序是1、2、3，那么可能的出洞顺序是3、2、1， 考虑到洞未满的情况下，老鼠进洞后又出洞了，也可能是1、2、3等，但不可能是3、1、2。现给定一个进洞序列，序列里数字可能重复，重复表示出洞后再次进洞，假定序列最后洞是满的，序列长度小于10000。</p>
<p>即老鼠编号范围是[1,10000]请给出老鼠出洞的顺序？</p>
<blockquote>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入一行数字数列，每个数字之间用英文空格分隔。如 1 2 3</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>3 2 1</p>
<h3 id="样例输入一"><a href="#样例输入一" class="headerlink" title="样例输入一"></a>样例输入一</h3><blockquote>
<p>1 2 3 2 3 4 5</p>
</blockquote>
<h3 id="样例输出一"><a href="#样例输出一" class="headerlink" title="样例输出一"></a>样例输出一</h3><blockquote>
<p>3 2 5 4 3 2 1</p>
</blockquote>
<p><strong>说明</strong></p>
<p>123后又出现2，说明2号老鼠是之前已经出洞了，再重新进洞，2号老鼠要出洞，需要3号老鼠先出洞，因而最先出洞的是3号老鼠，接着是2号老鼠。2号重新进洞后，接着3号又进洞，再是4号和5号，5号后面没其它的说明洞口满了。那么出洞顺序 就是 3 2 5 4 3 2 1。</p>
</blockquote>
<p>解决思路：</p>
<p>问题可以使用栈+哈希表来解决。老鼠进洞可以抽象成入栈，老鼠出洞可以抽象成出栈。那么题目就能转换成根据入栈的序列求出出栈的序列。</p>
<p>根据栈的先入后出的特性，假如一个元素出现在入栈序列，那么就需要确保该元素及其后入栈的元素都先出栈。</p>
<p>实现方式可以采用一个栈以及一个set，set用来标识编号为i的老鼠是否入栈，假如入栈了就需要将其加入到set中。</p>
<p>整体的流程就可以简单如下描述：首先遍历入洞序列，判断该序列是否在set中，假如不在，那么就直接将编号push到栈中并add到set中；假如在，那么就需要用一个while循环出栈直到该编号也出栈为止，在出栈的过程中用一个list记录出栈的顺序。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        String[] input = scanner.nextLine().split(" ");</span><br><span class="line">        List&lt;Integer&gt; seq = new ArrayList&lt;&gt;();</span><br><span class="line">        for (String s : input) {</span><br><span class="line">            seq.add(Integer.parseInt(s));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; sk = new Stack&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; occ = new HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int num : seq) {</span><br><span class="line">            if (occ.contains(num)) {</span><br><span class="line">                while (!sk.isEmpty() &amp;&amp; sk.peek() != num) {</span><br><span class="line">                    int tp = sk.pop();</span><br><span class="line">                    res.add(tp);</span><br><span class="line">                    occ.remove(tp);</span><br><span class="line">                }</span><br><span class="line">                if (!sk.isEmpty() &amp;&amp; sk.peek() == num) {</span><br><span class="line">                    res.add(num);</span><br><span class="line">                }</span><br><span class="line">            } else {</span><br><span class="line">                occ.add(num);</span><br><span class="line">                sk.push(num);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        while (!sk.isEmpty()) {</span><br><span class="line">            res.add(sk.pop());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(res.stream().map(String::valueOf).reduce((a, b) -&gt; a + " " + b).orElse(""));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="题目：元素消除"><a href="#题目：元素消除" class="headerlink" title="题目：元素消除"></a>题目：元素消除</h2><p>给定一个整数数组nums，同时给定一个整数interval。指定数组nums中的某个元素作为起点，然后以interval为间隔递增，如果递增的数（包含起点）等于nums中的元素，则将数组nums中对应的元素消除，返回消除元素最多的起点元素。如果消除的元素同样多，则返回最小的起点元素。</p>
<blockquote>
<h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行输入整数数组的长度n</p>
<p>第二行输入长度为n的整数数组nums</p>
<p>第三行输入整数interval1 &lt;= n &lt;= 10^5</p>
<p>0 &lt;= nums[i] &lt;= 10^8</p>
<p>0 &lt;= interval &lt;= 10^5</p>
</blockquote>
<p>解题思路：</p>
<p>由于给地你个间隔是固定的，就想到间隔相同的数之间是同余关系。</p>
<p>处理输入，对序列中的每个数同interval取模得到t，然后使用hashMap记录t的数值（即余数同为t的数的个数），并在遍历的过程中，不断更新最大的余数个数max。</p>
<p>然后再用一次遍历，如果某个数的余数的哈希值为max且数值比ans小，那么就更新ans</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Main {</span><br><span class="line">    public static int work(int n, int[] nums, int k) {</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashmap = new HashMap&lt;&gt;();</span><br><span class="line">        int anscnt = 0;</span><br><span class="line">        int ans = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        // Count the occurrences of each modulo value</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) {</span><br><span class="line">            int t = nums[i] % k;</span><br><span class="line">            hashmap.put(t, hashmap.getOrDefault(t, 0) + 1);</span><br><span class="line">            anscnt = Math.max(anscnt, hashmap.get(t));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // Find the minimum number with the maximum occurrence</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) {</span><br><span class="line">            if (hashmap.get(nums[i] % k) == anscnt) {</span><br><span class="line">                ans = Math.min(ans, nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="题目：参加博览会"><a href="#题目：参加博览会" class="headerlink" title="题目：参加博览会"></a>题目：参加博览会</h2><p>有n场编号从0到n−1的博览会将要举办，编号为i的的博览会举办时间为[starti,endi]，即从第starti天到第endi天，包含第starti天和第endi天。</p>
<p>小明计划参加这些博览会，每天最多可以参加k场博览会。请问小明最多可以参加多少场博览会。需注意，小明不需要全程参加一场博览会，只需要在某一天参加即可。</p>
<blockquote>
<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h3><p>第一行输入包含两个整数n和k，n表示博览会的数量，k表示每天最多可以参加的博览会的数量，1≤n≤10^4，1≤k≤10。</p>
<p>以下n行每行包含两个整数start和end，表示第i场博览会的举办时间，1≤starti≤endi≤10^9。</p>
</blockquote>
<p>解题思路：</p>
<p>首先可以用一个int[]数组来存每一场的开始时间和结束时间，然后用一个List来存所有的博览会，再对开始时间进行一个升序排序。</p>
<p>然后定义一个time表示当前时间，一个idx表示当前处理的博览会的索引，一个ans来统计参加的博览会的个数，还有一个小顶堆，即优先队列来对博览会的结束时间进行升序排序。小顶堆方便获取最早结束的博览会，即策略是优先参加早结束的博览会。</p>
<p>进入一个循环，条件是有未处理的博览会或者小顶堆不为空，</p>
<p>然后首先判断当前时间点，小顶堆中已经结束的博览会，将这些已过期的出堆，</p>
<p>接着检查当前时间点与下一个博览会的开始时间，若大于则将该博览会加入到堆中</p>
<p>然后尝试参加博览会，进行k次循环去小顶堆中取数，并对ans进行累加，这里需要判断小顶堆中是否为空，若空则直接退出循环。</p>
<p>最后更新当前时间，如果堆为空，直接设置为下一场博览会的开始时间，否则，将时间加1</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Main {</span><br><span class="line">    static int n, k;</span><br><span class="line"></span><br><span class="line">    // Comparator for sorting pairs based on the first element</span><br><span class="line">    public static class Pair {</span><br><span class="line">        int start, end;</span><br><span class="line"></span><br><span class="line">        Pair(int start, int end) {</span><br><span class="line">            this.start = start;</span><br><span class="line">            this.end = end;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void work(List&lt;Pair&gt; a) {</span><br><span class="line">        int time = 0;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pri = new PriorityQueue&lt;&gt;();</span><br><span class="line">        int idx = 0; // Start from 0 for 0-based index</span><br><span class="line">        int ans = 0;</span><br><span class="line"></span><br><span class="line">        while (idx &lt; n || !pri.isEmpty()) {</span><br><span class="line">            // Remove elements from the priority queue that have ended before the current time</span><br><span class="line">            while (!pri.isEmpty() &amp;&amp; pri.peek() &lt; time) {</span><br><span class="line">                pri.poll();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // Add new intervals that start at or before the current time</span><br><span class="line">            while (idx &lt; n &amp;&amp; a.get(idx).start &lt;= time) {</span><br><span class="line">                pri.add(a.get(idx).end);</span><br><span class="line">                idx++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // Process up to k intervals</span><br><span class="line">            for (int i = 0; i &lt; k; i++) {</span><br><span class="line">                if (!pri.isEmpty()) {</span><br><span class="line">                    ans++;</span><br><span class="line">                    pri.poll();</span><br><span class="line">                } else {</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // If the priority queue is empty, move to the start of the next interval</span><br><span class="line">            if (pri.isEmpty()) {</span><br><span class="line">                if (idx &lt; n) {</span><br><span class="line">                    time = a.get(idx).start;</span><br><span class="line">                }</span><br><span class="line">            } else {</span><br><span class="line">                time++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        n = scanner.nextInt();</span><br><span class="line">        k = scanner.nextInt();</span><br><span class="line">        List&lt;Pair&gt; a = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // Read the intervals</span><br><span class="line">        for (int i = 0; i &lt; n; i++) {</span><br><span class="line">            int s = scanner.nextInt();</span><br><span class="line">            int e = scanner.nextInt();</span><br><span class="line">            a.add(new Pair(s, e));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // Sort intervals based on start time</span><br><span class="line">        Collections.sort(a, Comparator.comparingInt(pair -&gt; pair.start));</span><br><span class="line"></span><br><span class="line">        // Call the work method to process the intervals</span><br><span class="line">        work(a);</span><br><span class="line">        scanner.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h1 id="数学题"><a href="#数学题" class="headerlink" title="数学题"></a>数学题</h1><h2 id="1-多个数求最小公倍数"><a href="#1-多个数求最小公倍数" class="headerlink" title="1. 多个数求最小公倍数"></a>1. 多个数求最小公倍数</h2><h3 id="求两个数的最小公倍数"><a href="#求两个数的最小公倍数" class="headerlink" title="求两个数的最小公倍数"></a>求两个数的最小公倍数</h3><blockquote>
<p>既然想算最小公倍数，首先要清楚最小公倍数的求法，还有<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0&amp;spm=1001.2101.3001.7020">最大公约数</a>的求法:</p>
<p>​									<strong>最小公倍数*最大公约数=两数乘积</strong></p>
<p> 只要有最大公约数就可以求出最小公倍数,方法:</p>
<p> ​													<strong>辗转相除法</strong></p>
<p>用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大公因数 greatest common divisor </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 最小公倍数 least common multiple</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcm</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">  <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="求多个数的最小公倍数"><a href="#求多个数的最小公倍数" class="headerlink" title="求多个数的最小公倍数"></a>求多个数的最小公倍数</h3><p>先求前两个数的最小公倍，再用这个最小公倍数与下一个数求最小公倍数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">lc1979</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            nums[i] = scanner.nextInt();</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            ans = ans * nums[i] / gcd(ans, nums[i]);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">        <span class="keyword">while</span>(b&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a % b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = t;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="模拟题"><a href="#模拟题" class="headerlink" title="模拟题"></a>模拟题</h1><h2 id="1-验证IP地址"><a href="#1-验证IP地址" class="headerlink" title="1. 验证IP地址"></a>1. <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-ip-address/">验证IP地址</a></h2><p><strong>s.split(regex s, int limit)</strong></p>
<ul>
<li>分割”.”需要用”\\.“</li>
<li>limit有三种情况<ul>
<li>limit&gt;0,分割limit-1次</li>
<li>limit=0,不限分割次数,但会把末尾的空结果删去</li>
<li>limit&lt;0,不限分割次数,不会把末尾的空结果删去</li>
</ul>
</li>
<li>假如没有设置limit,默认是0</li>
</ul>
<p><strong>s.isEmpty的实现为s.length()==0</strong></p>
<p><strong>Character.isDigit(char c)</strong></p>
<p><strong>Character.toLowerCase(char c)</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">validIPAddress</span><span class="params">(String queryIP)</span> {</span><br><span class="line">        <span class="keyword">if</span>(queryIP.indexOf(<span class="string">'.'</span>) &gt; <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.validIPv4(queryIP) ? <span class="string">"IPv4"</span> : <span class="string">"Neither"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(queryIP.indexOf(<span class="string">':'</span>) &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.validIPv6(queryIP) ? <span class="string">"IPv6"</span> : <span class="string">"Neither"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Neither"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validIPv6</span><span class="params">(String queryIP)</span> {</span><br><span class="line">        <span class="comment">//  分割查询IP，根据冒号分隔，不限制分隔的数量。</span></span><br><span class="line">        String[] split = queryIP.split(<span class="string">":"</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(split.length != <span class="number">8</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(String s:split) {</span><br><span class="line">            <span class="keyword">if</span> (s.isEmpty() || s.length() &gt; <span class="number">4</span>) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">                <span class="keyword">if</span>(!Character.isDigit(s.charAt(i)) &amp;&amp; !(Character.toLowerCase(s.charAt(i)) &gt;= <span class="string">'a'</span> &amp;&amp; Character.toLowerCase(s.charAt(i)) &lt;= <span class="string">'f'</span>)){</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">validIPv4</span><span class="params">(String queryIP)</span> {</span><br><span class="line">        String[] split = queryIP.split(<span class="string">"\\."</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(split.length != <span class="number">4</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(String s:split){</span><br><span class="line">            <span class="keyword">if</span>(s.isEmpty() || s.length() &gt; <span class="number">3</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(s.length() &gt; <span class="number">1</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">                <span class="keyword">if</span>(!Character.isDigit(s.charAt(i))){</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(s);</span><br><span class="line">            <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt; <span class="number">255</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="592-分数加减运算"><a href="#592-分数加减运算" class="headerlink" title="592. 分数加减运算"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fraction-addition-and-subtraction/">592. 分数加减运算</a></h2><blockquote>
<p>给定一个表示分数加减运算的字符串 <code>expression</code> ，你需要返回一个字符串形式的计算结果。 </p>
<p>这个结果应该是不可约分的分数，即<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0">最简分数</a>。 如果最终结果是一个整数，例如 <code>2</code>，你需要将它转换成分数形式，其分母为 <code>1</code>。所以在上述例子中, <code>2</code> 应该被转换为 <code>2/1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: expression = "-1/2+1/2"</span><br><span class="line">输出: "0/1"</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: expression = "-1/2+1/2+1/3"</span><br><span class="line">输出: "1/3"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: expression = "1/3-1/2"</span><br><span class="line">输出: "-1/6"</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 1.计算 分母最小公倍数</span></span><br><span class="line">    <span class="comment">// 2.逐个变换分子分母</span></span><br><span class="line">    <span class="comment">// 3.将 2 中计算的分子相加</span></span><br><span class="line">    <span class="comment">// 4.计算相加的分子分母的最大公约数</span></span><br><span class="line">    <span class="comment">// 5.用 4 计算的最大公约数 处理分子分母  </span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fractionAddition</span><span class="params">(String expression)</span> {</span><br><span class="line">        <span class="keyword">if</span> (expression == <span class="literal">null</span> || expression.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0/1"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">char</span>[] cs = expression.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; nums1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; nums2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur&lt;cs.length) {</span><br><span class="line">            <span class="comment">// 判断正负</span></span><br><span class="line">            <span class="keyword">if</span> (cs[cur] == <span class="string">'-'</span>) {</span><br><span class="line">                pre = -<span class="number">1</span>;</span><br><span class="line">                cur++;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (cs[cur] == <span class="string">'+'</span>) {</span><br><span class="line">                pre = <span class="number">1</span>;</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 取数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; cs.length &amp;&amp; cs[cur] != <span class="string">'/'</span> ) {</span><br><span class="line">                n1 = n1 * <span class="number">10</span> + (cs[cur] - <span class="string">'0'</span>);</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; cs.length &amp;&amp; cs[cur] != <span class="string">'+'</span> &amp;&amp; cs[cur] != <span class="string">'-'</span>) {</span><br><span class="line">                n2 = n2 * <span class="number">10</span> + (cs[cur] - <span class="string">'0'</span>);</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存数</span></span><br><span class="line">            nums1.add(pre * n1);</span><br><span class="line">            nums2.add(n2);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 分母 最小公倍数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2LCM</span> <span class="operator">=</span> nums1.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n2 : nums2) {</span><br><span class="line">            nums2LCM = lcm(nums2LCM, n2);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 逐个变换分子并相加</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1Sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums1.size(); ++i) {</span><br><span class="line">            nums1Sum += (nums2LCM / nums2.get(i)) * nums1.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 计算相加的分子分母的最大公约数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tGcd</span> <span class="operator">=</span> gcd(Math.abs(nums1Sum), nums2LCM);</span><br><span class="line">        <span class="comment">// 用 4 计算的最大公约数 处理分子分母</span></span><br><span class="line">        <span class="keyword">return</span> nums1Sum/tGcd + <span class="string">"/"</span> + nums2LCM/tGcd;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">        <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>详细个人题解：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fraction-addition-and-subtraction/solutions/2870964/mo-ni-by-nanase-6-e9it">https://leetcode.cn/problems/fraction-addition-and-subtraction/solutions/2870964/mo-ni-by-nanase-6-e9it</a></p>
<h1 id="数组题"><a href="#数组题" class="headerlink" title="数组题"></a>数组题</h1><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><p>顺时针旋转90度——主对称轴交换,左右对称轴交换</p>
<p>逆时针旋转90度——主对称轴交换,上下对称轴交换</p>
<p>顺时针旋转180度——顺时针90度x2</p>
<p>……</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> {</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 主对角线交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; ++i){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt; col; ++j){</span><br><span class="line">                swap(matrix, i, j, j, i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; ++i){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; col/<span class="number">2</span>; ++j){</span><br><span class="line">                swap(matrix, i, j, i, col-j-<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> i1, <span class="type">int</span> j1, <span class="type">int</span> i2, <span class="type">int</span> j2)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> matrix[i1][j1];</span><br><span class="line">        matrix[i1][j1] = matrix[i2][j2];</span><br><span class="line">        matrix[i2][j2] = t;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><blockquote>
<p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">        <span class="comment">// 3 4 5 1 2</span></span><br><span class="line">        <span class="comment">// x        -2 -2 -2 3 3</span></span><br><span class="line">        <span class="comment">// totalSum -2 -4 -6 -3 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>, totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;gas.length; ++i) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> gas[i] - cost[i];</span><br><span class="line">            curSum += x;</span><br><span class="line">            totalSum += x;</span><br><span class="line">            <span class="comment">// 总结：如果x到不了y+1（但能到y），那么从x到y的任一点出发都不可能到达y+1。因为从其中任一点出发的话，相当于从0开始加油，而如果从x出发到该点则不一定是从0开始加油，可能还有剩余的油。既然不从0开始都到不了y+1，那么从0开始就更不可能到达y+1了...</span></span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) {</span><br><span class="line">                ans = i+<span class="number">1</span>;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> totalSum &gt;= <span class="number">0</span> ? ans : -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a>135.分发糖果</h2><blockquote>
<p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,0,2]</span><br><span class="line">输出：5</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：ratings = [1,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span><br><span class="line">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>思路:</p>
<p>假设A、B相邻, A在B左侧</p>
<p>定义规则:</p>
<ul>
<li>左规则: 当RB&gt;RA时, B的糖果要比A多 [定A, 变B]</li>
<li>右规则: 当RA&gt;RB时, A的糖果要比B多 [定B, 变A]</li>
</ul>
<p>流程: 从左到右遍历,满足左规则; 从右到左遍历,满足右规则; 最后取max</p>
<blockquote>
<p>left和right的项只能增大或不变。然后取最大值合并后是可以同时满足left和right，这个要分类讨论，不过这里不难。关键在于合并后是否就是最优，这里合并后相对left来说是某些项增大某些不变，要优化肯定涉及到某些项的减小，那只能减小相对left来说增大的项，而这些项相对right来说又是原来的项，不能动，否则破坏right的条件，因此合并后的项不能再优化了，它就是最优解。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> {</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(left, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(right, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> left[ratings.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>]) right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            count += Math.max(left[i], right[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="1-字符串的排列"><a href="#1-字符串的排列" class="headerlink" title="1.字符串的排列"></a>1.字符串的排列</h2><p>排列组合问题,且不能重复</p>
<p>总结:</p>
<ul>
<li>set-&gt;array        <code>x.toArray(new T[0])</code></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Set&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">public</span> String[] goodsOrder(String goods) {</span><br><span class="line">        <span class="type">char</span>[] cList = goods.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[] isVisit = <span class="keyword">new</span> <span class="title class_">boolean</span>[goods.length()];</span><br><span class="line"></span><br><span class="line">        dfs(cList, isVisit, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] cList, <span class="type">boolean</span>[] isVisit, StringBuffer sb)</span>{</span><br><span class="line">        <span class="keyword">if</span>(sb.length() == cList.length){</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cList.length; ++i){</span><br><span class="line">            <span class="keyword">if</span>(isVisit[i]){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            isVisit[i] = <span class="literal">true</span>;</span><br><span class="line">            sb.append(cList[i]);</span><br><span class="line">            dfs(cList, isVisit, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">            isVisit[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><blockquote>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="type">boolean</span>[] visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums, visit);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] visit)</span> {</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) {</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (visit[i]) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            visit[i]= <span class="literal">true</span>;</span><br><span class="line">            dfs(nums, visit);</span><br><span class="line">            visit[i]= <span class="literal">false</span>;</span><br><span class="line">            list.remove(Integer.valueOf(nums[i]));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../pic/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" alt="image.png"></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<p>思路: 滑动窗口——有左右指针控制窗口 [left, right]</p>
<p>实际解决: 在右指针自增时候,  移动左指针保持窗口内不含有重复字符</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] cList = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); ++i){</span><br><span class="line">          	<span class="comment">// 滑动窗口，存在重复字母的区间需要移动左边界，不存在时不用</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cList[i])){</span><br><span class="line">                left = Math.max(left, map.get(cList[i])+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            map.put(cList[i], i);</span><br><span class="line">            ans = Math.max(ans, i-left+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/string-compression/">443. 压缩字符串</a></h2><p>aabbbccc -&gt; a2b2c3</p>
<p>a -&gt; a</p>
<p>abbbbbbbbbbbbbb -&gt; ab14</p>
<p>思路: </p>
<ul>
<li>最简单的是开辟一个StringBuffer去存, 采用双指针去控制窗口边界,一个存右边界,一个存左边界</li>
<li>要求原地修改, 则需要多一个write指针,控制修改的位置</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> {</span><br><span class="line">        <span class="keyword">if</span>(chars == <span class="literal">null</span> || chars.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> write=<span class="number">0</span>, read=<span class="number">0</span>, left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (read &lt; chars.length) {</span><br><span class="line">            <span class="keyword">if</span>(read == chars.length-<span class="number">1</span> || chars[read] != chars[read+<span class="number">1</span>]){</span><br><span class="line">                chars[write++] = chars[read];</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> read - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(num &gt; <span class="number">1</span>){</span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> write;</span><br><span class="line">                    <span class="keyword">while</span>(num &gt; <span class="number">0</span>){</span><br><span class="line">                        chars[write++] = (<span class="type">char</span>)(num % <span class="number">10</span> +<span class="string">'0'</span>);</span><br><span class="line">                        num /= <span class="number">10</span>;</span><br><span class="line">                    } </span><br><span class="line">                    reverse(chars, t, write-<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">                left = read + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            read++;</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> write;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">int</span> left, <span class="type">int</span> right)</span>{</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right){</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> chars[left];</span><br><span class="line">            chars[left] = chars[right];</span><br><span class="line">            chars[right] = t;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="1190-反转每对括号间的子串"><a href="#1190-反转每对括号间的子串" class="headerlink" title="1190. 反转每对括号间的子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/">1190. 反转每对括号间的子串</a></h2><p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p>
<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<p>思路: 栈+StringBuffer</p>
<p>遇到右括号时才进行字符串处理，这样可以保证我们是按照从括号内到外的顺序处理字符串。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="comment">// 0. 定义一个 StringBuilder</span></span><br><span class="line">        <span class="comment">// 1. 遇到'('将当前 String 加到 stack, 重置 sb</span></span><br><span class="line">        <span class="comment">// 2. 遇到')'将当前 String1 翻转，取出栈内 String2 加在当前 String1 前</span></span><br><span class="line">        <span class="comment">// 3. 假如为 char 直接 sb.append()</span></span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : cs) {</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) {</span><br><span class="line">                stack.offerLast(sb.toString());</span><br><span class="line">                sb.setLength(<span class="number">0</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) {</span><br><span class="line">                sb.reverse();</span><br><span class="line">                sb.insert(<span class="number">0</span>, stack.pollLast());</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sb.append(c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>递归: 需要一个全局idx</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseParentheses</span><span class="params">(String s)</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> traversal(s).toString();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuffer <span class="title function_">traversal</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; s.length()) {</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(idx) == <span class="string">'('</span>) {</span><br><span class="line">                idx++;</span><br><span class="line">                sb.append(traversal(s).reverse());</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(idx) == <span class="string">')'</span>) {</span><br><span class="line">                idx++;</span><br><span class="line">                <span class="keyword">return</span> sb;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sb.append(s.charAt(idx));</span><br><span class="line">                idx++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="2243-计算字符串的数字和"><a href="#2243-计算字符串的数字和" class="headerlink" title="2243. 计算字符串的数字和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/calculate-digit-sum-of-a-string/">2243. 计算字符串的数字和</a></h2><p>思路: 递归</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">digitSum</span><span class="params">(String s, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= k) {</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] list = s.toCharArray();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.length; ++i) {</span><br><span class="line">            curNum += list[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == s.length()-<span class="number">1</span> || (i+<span class="number">1</span>) % k == <span class="number">0</span>) {</span><br><span class="line">                sb.append(Integer.toString(curNum));</span><br><span class="line">                curNum = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> digitSum(sb.toString(), k);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "3[a]2[bc]"</span><br><span class="line">输出："aaabcbc"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "3[a2[c]]"</span><br><span class="line">输出："accaccacc"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "2[abc]3[cd]ef"</span><br><span class="line">输出："abcabccdcdcdef"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "abc3[cd]xyz"</span><br><span class="line">输出："abccdcdcdxyz"</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        Deque&lt;String&gt; sstack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; nstack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;cs.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(cs[i])) {</span><br><span class="line">                num = num * <span class="number">10</span> + (cs[i] - <span class="string">'0'</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(cs[i] == <span class="string">'['</span>) {</span><br><span class="line">                <span class="comment">// 开启新的[]拼接 需要将同层的已经确定的字符串 存起来</span></span><br><span class="line">                nstack.offerLast(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                sstack.offerLast(cur.toString());</span><br><span class="line">                cur.setLength(<span class="number">0</span>);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span>(cs[i] == <span class="string">']'</span>) {</span><br><span class="line">                <span class="comment">// 结束当前[]拼接 计算重复次数,然后连接同一层的已经确定的字符串</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">dn</span> <span class="operator">=</span> nstack.pollLast();</span><br><span class="line">                <span class="type">String</span> <span class="variable">oldCur</span> <span class="operator">=</span> cur.toString();</span><br><span class="line">                <span class="keyword">while</span> (dn &gt; <span class="number">1</span>) {</span><br><span class="line">                    cur.append(oldCur);</span><br><span class="line">                    dn--;</span><br><span class="line">                }</span><br><span class="line">                cur.insert(<span class="number">0</span>, sstack.pollLast());</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur.append(cs[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>算法流程：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd">https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd</a></p>
<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> {</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> dfs(cs, <span class="number">0</span>, cs.length-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    String <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[] cs, <span class="type">int</span> l, <span class="type">int</span> r)</span> {</span><br><span class="line">        <span class="comment">// 确定[]内的 string</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=l; i&lt;=r; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(cs[i])) {</span><br><span class="line">                ans.append(cs[i]);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (Character.isDigit(cs[i])) {</span><br><span class="line">                    num = num * <span class="number">10</span> + (cs[i++] - <span class="string">'0'</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="type">int</span> <span class="variable">old</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">fnum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (fnum &gt; <span class="number">0</span>) {</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span> (cs[i] == <span class="string">'['</span>) fnum++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cs[i] == <span class="string">']'</span>) fnum--;</span><br><span class="line">                }</span><br><span class="line">                <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> dfs(cs, old, i-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (num-- &gt; <span class="number">0</span>) {</span><br><span class="line">                    ans.append(sub);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h2><blockquote>
<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,2]</span><br><span class="line">输出："210"</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出："9534330"</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// s1.compareTo(s2) 理解为 s1-s2  负数则 s1 小  前提是长度一样</span></span><br><span class="line">        <span class="comment">// pq 里面的比较关系 s1,s2 后面的值为 - 则 s1 在前</span></span><br><span class="line">        <span class="comment">// 要让 s1 在前 需要 s1+s2&gt;s2+s1 记 (s2+s1).compareTo(s1+s2) 为 -</span></span><br><span class="line">        PriorityQueue&lt;String&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;String&gt;((s1,s2)-&gt;(s2+s1).compareTo(s1+s2));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) {</span><br><span class="line">            pq.offer(Integer.toString(n));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 特殊情况处理</span></span><br><span class="line">        <span class="keyword">if</span> (pq.peek().equals(<span class="string">"0"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            sb.append(t);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>知识点:</p>
<p>在 <code>PriorityQueue</code> 中使用自定义的 <code>Comparator</code> 来排序元素时，<code>Comparator</code> 的 <code>compare</code> 方法返回的值决定了两个元素的顺序。</p>
<ul>
<li><strong>返回负数</strong> (<code>&lt; 0</code>)：表示第一个参数（<code>s1</code>）应该排在第二个参数（<code>s2</code>）之前。</li>
<li><strong>返回正数</strong> (<code>&gt; 0</code>)：表示第一个参数（<code>s1</code>）应该排在第二个参数（<code>s2</code>）之后。</li>
<li><strong>返回零</strong> (<code>0</code>)：表示两个参数顺序相同（即不交换位置）。</li>
</ul>
<p>如果 <code>s1.compareTo(s2)</code> 返回负数（意味着 <code>s1</code> 在字典顺序上小于 <code>s2</code>），则 <code>s1</code> 应该排在 <code>s2</code> 前面。</p>
<p>如果 <code>s1.compareTo(s2)</code> 返回正数（意味着 <code>s1</code> 在字典顺序上大于 <code>s2</code>），则 <code>s1</code> 应该排在 <code>s2</code> 后面。</p>
<p>如果 <code>s1.compareTo(s2)</code> 返回 0，表示 <code>s1</code> 和 <code>s2</code> 相等，保持当前顺序。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><p>完全背包问题</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">      	<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=amount; ++i){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c:coins){</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= c){</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-c]+<span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><blockquote>
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "leetcode", wordDict = ["leet", "code"]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "applepenapple", wordDict = ["apple", "pen"]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]</span><br><span class="line">输出: false</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>思路：</p>
<p>dp[i] 前 i 个字母能否由字典拼出</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> {</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=s.length(); ++i) {</span><br><span class="line">            <span class="keyword">for</span> (String word : wordDict) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i-word.length();</span><br><span class="line">                <span class="keyword">if</span> (start &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(start,i);</span><br><span class="line">                <span class="keyword">if</span> (sub.equals(word) &amp;&amp; dp[start]) {</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                } </span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-lcci/">面试题 08.11. 硬币</a></h2><blockquote>
<p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n = 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 输入: n = 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10=10</span><br><span class="line">10=5+5</span><br><span class="line">10=5+1+1+1+1+1</span><br><span class="line">10=1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>不同于爬楼梯 取硬币 1 5 和 5 1是一样的</p>
<p>为了保证使用第二个硬币尝试的时候，dp中 只有 第一个硬币 尝试的结果，需要将coin循环放在外层</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">waysToChange</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="comment">// dp[i] n分有几种表示法</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] coins = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>};</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) {</span><br><span class="line">                <span class="comment">//于是我们先遍历硬币，保证在考虑一枚硬币的情况时，没有较大的硬币影响，这样，我们最终每种组合情况，都是以硬币的面额大小非递减组合。保证了同样的情况，调换顺序后重复计算的情况。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (coin &lt;=i) {</span><br><span class="line">                    dp[i] = (dp[i] + dp[i-coin]) % <span class="number">1000000007</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="1004-最大连续1的个数"><a href="#1004-最大连续1的个数" class="headerlink" title="1004.最大连续1的个数"></a>1004.最大连续1的个数</h2><p>给定一个二进制数组 <code>nums</code> 和一个整数 <code>k</code>，如果可以翻转最多 <code>k</code> 个 <code>0</code> ，则返回 <em>数组中连续 <code>1</code> 的最大个数</em> 。</p>
<blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">输出：10</span><br><span class="line">解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 10。</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>代码思路：</p>
<p>使用 left和 right两个指针，分别指向滑动窗口的左右边界。<br>right主动右移：right 指针每次移动一步。当 A[right]为 0，说明滑动窗口内增加了一个 0；<br>left 被动右移：判断此时窗口内 0 的个数，如果超过了 K，则 left 指针被迫右移，直至窗口内的 0 的个数小于等于 K 为止。<br>滑动窗口长度的最大值就是所求。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestOnes</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, ans = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) {</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == <span class="number">0</span>) {</span><br><span class="line">                cur++;</span><br><span class="line">            } </span><br><span class="line">            <span class="keyword">while</span> (cur &gt; k) {</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == <span class="number">0</span>) {</span><br><span class="line">                    cur--;</span><br><span class="line">                }</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="滑动窗口模板"><a href="#滑动窗口模板" class="headerlink" title="滑动窗口模板"></a>滑动窗口模板</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findSubArray</span>(<span class="params">nums</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(nums) <span class="comment"># 数组/字符串长度</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 双指针，表示当前遍历的区间[left, right]，闭区间</span></span><br><span class="line">    sums = <span class="number">0</span> <span class="comment"># 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数</span></span><br><span class="line">    res = <span class="number">0</span> <span class="comment"># 保存最大的满足题目要求的 子数组/子串 长度</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; N: <span class="comment"># 当右边的指针没有搜索到 数组/字符串 的结尾</span></span><br><span class="line">        sums += nums[right] <span class="comment"># 增加当前右边指针的数字/字符的求和/计数</span></span><br><span class="line">        <span class="keyword">while</span> 区间[left, right]不符合题意: <span class="comment"># 此时需要一直移动左指针，直至找到一个符合题意的区间</span></span><br><span class="line">            sums -= nums[left] <span class="comment"># 移动左指针前需要从counter中减少left位置字符的求和/计数</span></span><br><span class="line">            left += <span class="number">1</span> <span class="comment"># 真正的移动左指针，注意不能跟上面一行代码写反</span></span><br><span class="line">        <span class="comment"># 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>) <span class="comment"># 需要更新结果</span></span><br><span class="line">        right += <span class="number">1</span> <span class="comment"># 移动右指针，去探索新的区间</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>



<p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p>
<p>模板的整体思想是：</p>
<ul>
<li>定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；</li>
<li>第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和/计数；</li>
<li>第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和/计数；</li>
<li>在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。</li>
<li>right 指针每次向右移动一步，开始探索新的区间。</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h2><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给定一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong>，即所有路径上节点值之和的最大值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfs</span> <span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.max(dfs(root.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Math.max(dfs(root.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以当前节点为纽带</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> root.val + l + r;</span><br><span class="line"></span><br><span class="line">        ans = Math.max(ans, sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不以当前节点为纽带</span></span><br><span class="line">        <span class="keyword">return</span>  Math.max(l, r) + root.val;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
</blockquote>
<h2 id="475-供暖器"><a href="#475-供暖器" class="headerlink" title="475. 供暖器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/heaters/">475. 供暖器</a></h2><blockquote>
<p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p>
<p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p>
<p>现在，给出位于一条水平线上的房屋 <code>houses</code> 和供暖器 <code>heaters</code> 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p>
<p><strong>注意</strong>：所有供暖器 <code>heaters</code> 都遵循你的半径标准，加热的半径也一样。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: houses = [1,2,3], heaters = [2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 仅在位置 2 上有一个供暖器。如果我们将加热半径设为 1，那么所有房屋就都能得到供暖。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: houses = [1,2,3,4], heaters = [1,4]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 在位置 1, 4 上有两个供暖器。我们需要将加热半径设为 1，这样所有房屋就都能得到供暖。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [1,5], heaters = [2]</span><br><span class="line">输出：3</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> {</span><br><span class="line">        <span class="comment">// 对于一个房子, 要么用前面的暖气, 要么用后面的, 二者取近的</span></span><br><span class="line">        <span class="comment">// 可以使用双指针</span></span><br><span class="line">        <span class="comment">// 先对两个数组做 sort </span></span><br><span class="line">        <span class="comment">// 对于每一个房子house, 从 heaters 中找第一个位置大于 house 的, -1 就是第一个位置小于 house</span></span><br><span class="line">        <span class="comment">// 然后有三种情况, 第一个heater 就满足; 最后一个 heater 也不满足; 中间的 heater 满足,那么就需要比较前后的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;houses.length; ++i) {</span><br><span class="line">            <span class="keyword">while</span> (j &lt; heaters.length &amp;&amp; houses[i] &gt; heaters[j]) j++;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) {</span><br><span class="line">                ans = Math.max(ans, heaters[j] - houses[i]);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (j == heaters.length) {</span><br><span class="line">                ans = Math.max(ans, houses[i] - heaters[j-<span class="number">1</span>]);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ans = Math.max(ans, Math.min(houses[i]-heaters[j-<span class="number">1</span>], heaters[j]-houses[i]));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</body></html></div><div class="article-licensing box"><div class="licensing-title"><p>手撕</p><p><a href="https://jerryzhu1229.github.io/2024/01/26/算法/华为手撕/">https://jerryzhu1229.github.io/2024/01/26/算法/华为手撕/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jerry Z</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-01-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/02/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Redis</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/01/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AE%9E%E8%B7%B5/"><span class="level-item">MySQL实践</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#题库目录"><span class="level-left"><span class="level-item">1</span><span class="level-item">题库目录</span></span></a></li><li><a class="level is-mobile" href="#笔试复盘"><span class="level-left"><span class="level-item">2</span><span class="level-item">笔试复盘</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题目：老鼠串门"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">题目：老鼠串门</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#输入描述"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">输入描述</span></span></a></li><li><a class="level is-mobile" href="#输出描述"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">输出描述</span></span></a></li><li><a class="level is-mobile" href="#样例输入一"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">样例输入一</span></span></a></li><li><a class="level is-mobile" href="#样例输出一"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">样例输出一</span></span></a></li></ul></li><li><a class="level is-mobile" href="#题目：元素消除"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">题目：元素消除</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#输入描述-1"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">输入描述</span></span></a></li></ul></li><li><a class="level is-mobile" href="#题目：参加博览会"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">题目：参加博览会</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#输入描述-2"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">输入描述</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#哈希"><span class="level-left"><span class="level-item">3</span><span class="level-item">哈希</span></span></a></li><li><a class="level is-mobile" href="#数学题"><span class="level-left"><span class="level-item">4</span><span class="level-item">数学题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-多个数求最小公倍数"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">1. 多个数求最小公倍数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#求两个数的最小公倍数"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">求两个数的最小公倍数</span></span></a></li><li><a class="level is-mobile" href="#求多个数的最小公倍数"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">求多个数的最小公倍数</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#模拟题"><span class="level-left"><span class="level-item">5</span><span class="level-item">模拟题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-验证IP地址"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">1. 验证IP地址</span></span></a></li><li><a class="level is-mobile" href="#592-分数加减运算"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">592. 分数加减运算</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数组题"><span class="level-left"><span class="level-item">6</span><span class="level-item">数组题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#48-旋转图像"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">48. 旋转图像</span></span></a></li><li><a class="level is-mobile" href="#134-加油站"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">134. 加油站</span></span></a></li><li><a class="level is-mobile" href="#135-分发糖果"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">135.分发糖果</span></span></a></li></ul></li><li><a class="level is-mobile" href="#回溯"><span class="level-left"><span class="level-item">7</span><span class="level-item">回溯</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-字符串的排列"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">1.字符串的排列</span></span></a></li><li><a class="level is-mobile" href="#46-全排列"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">46. 全排列</span></span></a></li></ul></li><li><a class="level is-mobile" href="#字符串"><span class="level-left"><span class="level-item">8</span><span class="level-item">字符串</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-无重复字符的最长子串"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">3. 无重复字符的最长子串</span></span></a></li><li><a class="level is-mobile" href="#443-压缩字符串"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">443. 压缩字符串</span></span></a></li><li><a class="level is-mobile" href="#1190-反转每对括号间的子串"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">1190. 反转每对括号间的子串</span></span></a></li><li><a class="level is-mobile" href="#2243-计算字符串的数字和"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">2243. 计算字符串的数字和</span></span></a></li><li><a class="level is-mobile" href="#394-字符串解码"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">394. 字符串解码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#栈"><span class="level-left"><span class="level-item">8.5.1</span><span class="level-item">栈</span></span></a></li><li><a class="level is-mobile" href="#dfs"><span class="level-left"><span class="level-item">8.5.2</span><span class="level-item">dfs</span></span></a></li></ul></li><li><a class="level is-mobile" href="#179-最大数"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">179. 最大数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#动态规划"><span class="level-left"><span class="level-item">9</span><span class="level-item">动态规划</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#322-零钱兑换"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">322. 零钱兑换</span></span></a></li><li><a class="level is-mobile" href="#139-单词拆分"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">139. 单词拆分</span></span></a></li><li><a class="level is-mobile" href="#面试题-08-11-硬币"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">面试题 08.11. 硬币</span></span></a></li></ul></li><li><a class="level is-mobile" href="#滑动窗口"><span class="level-left"><span class="level-item">10</span><span class="level-item">滑动窗口</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1004-最大连续1的个数"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">1004.最大连续1的个数</span></span></a></li><li><a class="level is-mobile" href="#滑动窗口模板"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">滑动窗口模板</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉树"><span class="level-left"><span class="level-item">11</span><span class="level-item">二叉树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#124-二叉树中的最大路径和"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">124. 二叉树中的最大路径和</span></span></a></li></ul></li><li><a class="level is-mobile" href="#双指针"><span class="level-left"><span class="level-item">12</span><span class="level-item">双指针</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#283-移动零"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">283. 移动零</span></span></a></li><li><a class="level is-mobile" href="#475-供暖器"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">475. 供暖器</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/cs/"><span class="level-start"><span class="level-item">cs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/python/"><span class="level-start"><span class="level-item">python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">前端技术</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BF%90%E7%BB%B4/"><span class="level-start"><span class="level-item">运维</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a><p class="is-size-7"><span>&copy; 2025 Jerry Z</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>