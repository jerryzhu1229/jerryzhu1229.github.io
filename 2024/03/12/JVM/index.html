<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JVM - hao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="hao"><meta name="msapplication-TileImage" content="/img/2751710164138_.pic.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="hao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="hao"><meta property="og:url" content="https://jerryzhu1229.github.io/2024/03/12/JVM/"><meta property="og:site_name" content="hao"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/java-runtime-data-areas-jdk1.8.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/hotspot-heap-structure.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/method-area-implementation.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/method-area-jdk1.7.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/a7598135c2039f254af77fa895bce1ef.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/java-jmm-x03.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/serial-garbage-collector.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/parnew-garbage-collector.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/parallel-scavenge-garbage-collector.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/cms-garbage-collector-20240320092604199.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/656"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/928"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/g1-garbage-collector.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/656"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/v2-adecb8b867ce06a962df2a3668563101_1440w.jpg"><meta property="article:published_time" content="2024-03-12T01:57:04.000Z"><meta property="article:modified_time" content="2024-03-23T12:54:50.572Z"><meta property="article:author" content="Jerry Z"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jerryzhu1229.github.io/pic/java-runtime-data-areas-jdk1.8.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerryzhu1229.github.io/2024/03/12/JVM/"},"headline":"JVM","image":["https://jerryzhu1229.github.io/pic/java-runtime-data-areas-jdk1.8.png","https://jerryzhu1229.github.io/pic/hotspot-heap-structure.png","https://jerryzhu1229.github.io/pic/method-area-implementation.png","https://jerryzhu1229.github.io/pic/method-area-jdk1.7.png","https://jerryzhu1229.github.io/pic/a7598135c2039f254af77fa895bce1ef.png","https://jerryzhu1229.github.io/pic/java-jmm-x03.png","https://jerryzhu1229.github.io/pic/serial-garbage-collector.png","https://jerryzhu1229.github.io/pic/parnew-garbage-collector.png","https://jerryzhu1229.github.io/pic/parallel-scavenge-garbage-collector.png","https://jerryzhu1229.github.io/pic/cms-garbage-collector-20240320092604199.png","https://jerryzhu1229.github.io/pic/g1-garbage-collector.png","https://jerryzhu1229.github.io/pic/v2-adecb8b867ce06a962df2a3668563101_1440w.jpg"],"datePublished":"2024-03-12T01:57:04.000Z","dateModified":"2024-03-23T12:54:50.572Z","author":{"@type":"Person","name":"Jerry Z"},"publisher":{"@type":"Organization","name":"hao","logo":{"@type":"ImageObject","url":"https://jerryzhu1229.github.io/img/2751710164138_.pic.jpg"}},"description":""}</script><link rel="canonical" href="https://jerryzhu1229.github.io/2024/03/12/JVM/"><link rel="icon" href="/img/2751710164138_.pic.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/cs">计算机基础</a><a class="navbar-item" href="/categories/java">后端开发</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jerryzhu1229"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-12T01:57:04.000Z" title="2024/3/12 09:57:04">2024-03-12</time>发表</span><span class="level-item"><time dateTime="2024-03-23T12:54:50.572Z" title="2024/3/23 20:54:50">2024-03-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">1 小时读完 (大约8112个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JVM</h1><div class="content"><html><head></head><body><h2 id="JVM-内存区域"><a href="#JVM-内存区域" class="headerlink" title="**JVM 内存区域"></a>**JVM 内存区域</h2><p><strong>JDK 1.8</strong>：</p>
<p><img src="/../pic/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）"></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器：记录程序执行到的位置	</li>
<li>虚拟机栈<ul>
<li><strong>局部变量表</strong>：存放了编译期可知的各种数据类型</li>
<li><strong>操作数栈</strong>：存放方法执行过程中产生的中间计算结果</li>
<li><strong>动态链接</strong>：将符号引用转换为调用方法的直接引用。多态</li>
<li><strong>方法返回地址</strong></li>
</ul>
</li>
<li>本地方法栈：执行本地方法</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li><p>堆：存放类实例和数组</p>
<p><img src="/../pic/hotspot-heap-structure.png" alt="堆内存结构"></p>
<p>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存</p>
</li>
<li><p>方法区：（方法区逻辑上在堆中）存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、JIT 代码缓存等数据</strong></p>
<p><img src="/../pic/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p>
</li>
<li><p>运行时常量池：字面量（Literal 源代码中的固定值的表示法，字面量包括整数、浮点数和字符串字面量）和符号引用（Symbolic Reference，包括类符号引用、字段符号引用、方法符号引用、接口方法符号）</p>
</li>
<li><p>字符串常量池。主要目的是为了避免字符串的重复创建。</p>
</li>
</ul>
<p><img src="/../pic/method-area-jdk1.7.png" alt="method-area-jdk1.7"></p>
<h2 id="java-内存模型-happen-before-原则"><a href="#java-内存模型-happen-before-原则" class="headerlink" title="java 内存模型\happen-before 原则"></a>java 内存模型\happen-before 原则</h2><blockquote>
<p>有什么存在作用？</p>
</blockquote>
<p>java 内存模型跟 cpu 缓存模型类型，是基于 cpu 缓存模型来建立的，Java内存模型定义了共享内存系统中多线程程序读写操作行为的规范，是为了解决并发编程问题而存在的。</p>
<blockquote>
<p>JMM对内存的划分？</p>
</blockquote>
<p>划分为主内存和工作内存两种</p>
<p>规定所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</p>
<blockquote>
<p>主内存和工作内存的交互操作</p>
</blockquote>
<p>首先是从lock加锁开始，把主内存中的变量标志为一条线程独占的状态；read读取，将一个变量的值从主内存传输到工作内存中；load加载，把read得到的值加载到工作内存的变量副本中；use使用，把工作内存中变量的值传递给执行引擎；assign赋值，把从执行引擎接收到的值赋值给工作内存的变量；store存储，把工作内存中变量的值传送回主内存中；write写入，把store得到的值放入主内存的变量中；最后是unlock解锁，把主内存中处于锁定状态的变量释放出来，<br><img src="/../pic/a7598135c2039f254af77fa895bce1ef.png" alt="image-20210116112358455"></p>
<blockquote>
<p>内存交互基本操作的三个特性的理解？</p>
</blockquote>
<p>原子性（synchroinzed）、可见性（volatile）、以及有序性（happen-before）。</p>
<blockquote>
<p>happen-before</p>
</blockquote>
<p>happen-before原则是Java内存模型中定义的两项操作之间的偏序关系。</p>
<p><strong>Happens-Before关系只是描述结果的可见性，并不表示指令执行的先后顺序，也就是说只要不对结果产生影响，仍然允许指令重排序。</strong></p>
<p>为了具体说明，请看前面提到过的计算圆面积的示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span>  <span class="operator">=</span> <span class="number">3.14</span>;    <span class="comment">//A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span>   <span class="operator">=</span> <span class="number">1.0</span>;     <span class="comment">//B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r; <span class="comment">//C</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面计算圆的面积的示例代码存在三个 happens- before 关系：</p>
<ul>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ul>
<p>由于 A happens- before B，happens- before 的定义会要求：A 操作执行的结果要对 B 可见，且 A 操作的执行顺序排在 B 操作之前。 但是从程序语义的角度来说，对 A 和 B 做重排序即不会改变程序的执行结果，也还能提高程序的执行性能（允许这种重排序减少了对编译器和处理器优化的束缚）。也就是说，上面这 3 个 happens- before 关系中，虽然 2 和 3 是必需要的，但 1 是不必要的。因此，JMM 把 happens- before 要求禁止的重排序分为了下面两类：</p>
<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
<p>JMM 对这两种不同性质的重排序，采取了不同的策略：</p>
<ul>
<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li>
</ul>
<p>下面是 JMM 的设计示意图：</p>
<p><img src="/../pic/java-jmm-x03.png" alt="img"></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p>大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p>
<h4 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h4><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p>
<h3 id="JVM是如何判断一个对象是可回收的？"><a href="#JVM是如何判断一个对象是可回收的？" class="headerlink" title="JVM是如何判断一个对象是可回收的？"></a>JVM是如何判断一个对象是可回收的？</h3><ol>
<li>引用计数法</li>
</ol>
<p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的。</li>
</ul>
<p>**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</p>
<ol start="2">
<li>可达性分析算法</li>
</ol>
<p>基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<h3 id="哪些对象可以作为-GC-Roots-呢？"><a href="#哪些对象可以作为-GC-Roots-呢？" class="headerlink" title="哪些对象可以作为 GC Roots 呢？"></a><strong>哪些对象可以作为 GC Roots 呢？</strong></h3><ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p>
<ul>
<li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li>
<li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li>
</ul>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="**垃圾收集器"></a>**垃圾收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="/../pic/serial-garbage-collector.png" alt="Serial 收集器"></p>
<p> <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p>不良用户体验但<strong>简单而高效（与其他收集器的单线程相比）</strong></p>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p>
<p><img src="/../pic/parnew-garbage-collector.png" alt="ParNew 收集器 "></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p>parnew+cms</p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="/../pic/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="**CMS 收集器"></a>**CMS 收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收<strong>停顿时间</strong>为目标的收集器。它非常符合在注重用户体验的应用上使用。<strong>并发收集器</strong>。</p>
<p><strong>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。</strong></p>
<p><img src="/../pic/cms-garbage-collector-20240320092604199.png" alt="CMS 收集器"></p>
<p>CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：1）初始标记（CMS initial mark） 2）并发标记（CMS concurrent mark） 3）重新标记（CMS remark） 4）并发清除（CMS concurrent sweep）</p>
<ul>
<li><p><strong>初始标记</strong>：标记直接与GCRoots 相连的对象，速度很快 </p>
</li>
<li><p><strong>并发标记</strong>： 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。这里使用三色标记法。每个对象分为三种类型，黑色代表自身和成员都检查，灰色代表自身检查完成员没有检查，白色代表自身跟成员都还未检查。GC 开始前所有对象都是白色，GC 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后待其子对象都进栈变灰色后，该对象变成黑色。当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。但是由于是并发标记，会存在错标问题，标记线程已经确定 b、d 是黑色，然后用户线程将 b、d 断开同时 d 没有其他对象被引用了，但是他已经是黑色不会在去检查，所以就不会被 gc 回收，也就是浮动垃圾。</p>
</li>
</ul>
<p><img src="/../pic/656" alt="错表"></p>
<ul>
<li><strong>重新标记</strong>：修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</li>
</ul>
<p><img src="/../pic/928" alt="img"></p>
<ul>
<li><strong>并发清除</strong>：开启用户线程，同时 GC 线程开始对未标记的区域做清扫，这个阶段也是可以与用户线程同时并发的。由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</li>
</ul>
<p>主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li>吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="**G1 收集器"></a>**G1 收集器</h4><p>它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</p>
<p><strong>其中初始标记、最终标记、筛选回收这三个步骤仍然需要“Stop The World”。</strong></p>
<p>特点：</p>
<ul>
<li><p><strong>分代收集</strong>：G1(Garbage First)物理内存不再分代，而是由一块一块的<code>Region</code>组成,但是逻辑分代仍然存在。G1 把堆划分成多个大小相等的独立区域(Region)，每个 region 根据需要扮演新生代或老年代，新生代和老年代不再物理隔离， G1 可以直接对新生代和老年代一起回收。</p>
</li>
<li><p><strong>可预测的停顿</strong>： 每个Region 可以单独进行垃圾回收，通过对每个 Region 维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region，控制停顿时间。</p>
</li>
<li><p><strong>避免全堆扫描：</strong>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
</li>
<li><p><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上（两个 region 来看）来看是基于“标记-复制”算法实现的。</p>
<blockquote>
<p>G1GC 的主要功能是<strong>并发标记和转移</strong>。其中并发标记由并发标记线程来执行。</p>
<ul>
<li>并发标记的作用是在尽量不暂停用户线程的情况下标记出存活对象。而且，还需要在并发标记结束之后记录下每个区域内存活对象的数量。这个信息在转移时会用到。</li>
<li>转移的作用是将待回收区域内的存活对象复制到其他的空闲区域，然后将待回收区域重置为空闲状态。这很像复制 GC 算法，只不过是以区域为单位进行的。</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="/../pic/g1-garbage-collector.png" alt="G1 收集器"></p>
<p><strong>几个步骤：</strong></p>
<ul>
<li><strong>初始标记</strong>：暂停所有用户线程，标记 gc roots 直接相连的对象，速度很快。</li>
<li><strong>并发标记</strong>：采用三色标记法，以 gc roots直接相连的对象为起点，进行广度优先遍历，配合<code>原始快照</code>记录用户线程更改引用的关系的原始引用到Remembered Set Logs。</li>
<li><strong>最终标记</strong>：最终标记阶段需要把 并发标记生成的Remembered Set Logs 的数据合并到 Remembered Set 中，然后扫描 gc 堆栈，配合 Rset 执行标记。</li>
<li><strong>筛选回收</strong>：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<h4 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h4><ul>
<li>白色：没有检查（或者检查过了，确实没有引用指向它了）</li>
<li>灰色：自身被检查了，成员没被检查完（可以认为访问到了，但是正在被检查，就是图的遍历里那些在队列中的节点）</li>
<li>黑色：自身和成员都被检查完了</li>
</ul>
<p><strong>具体流程:</strong></p>
<ol>
<li>首先创建三个集合：白、灰、黑。</li>
<li>将所有对象放入白色集合中。</li>
<li>然后从根节点开始遍历所有对象（注意这里并不<strong>「递归遍历」</strong>），把遍历到的对象从白色集合放入灰色集合。</li>
<li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li>
<li>重复 上一步骤 直到灰色中无任何对象</li>
<li>通过write-barrier检测对象有变化，CMS 采用增量更新，在黑色连接白色后，将黑色变为灰色；G1 采用初始快照，将删除灰色到白色的连接记录到 remembered set log 中，这样在后续的重新标记/最终标记的时候进行处理。</li>
<li>收集所有白色对象（垃圾）</li>
</ol>
<h3 id="第一种问题：-错标"><a href="#第一种问题：-错标" class="headerlink" title="第一种问题： 错标"></a>第一种问题： 错标</h3><p>标记过不是垃圾的，变成了垃圾（也叫浮动垃圾）</p>
<p><img src="/../pic/656" alt="img"></p>
<p>会在 CMS 出现，因为 cms 采用的是增量更新，不会对引用的删除进行处理。</p>
<h3 id="第二种问题：漏标，或者叫错杀"><a href="#第二种问题：漏标，或者叫错杀" class="headerlink" title="第二种问题：漏标，或者叫错杀"></a>第二种问题：漏标，或者叫错杀</h3><p>产生漏标问题的条件有两个：</p>
<ul>
<li>黑色对象指向了白色对象</li>
<li>灰色对象指向白色对象的引用消失</li>
</ul>
<p>G1：<strong>写屏障</strong>+ <strong>SATB</strong> <strong>（Snapshot At The Beginning）</strong></p>
<p>在开始标记的时候生成一个快照图标记存活对象</p>
<p>在一个引用断开后，要将此引用推到 GC 的堆栈里，保证白色对象(垃圾)还能被 GC 线程扫描到(在**write barrier(写屏障)**里把所有旧的引用所指向的对象都变成非白的)</p>
<p>配合 Rset，去扫描哪些 Region 引用到当前的白色对象，若没有引用到当前对象，则回收</p>
<p><strong>cms：写屏障+ 增量更新</strong></p>
<ul>
<li>新增<br>如果新增黑色到白色的引用，那么jvm会通过写屏障，来把黑色置为灰色</li>
<li>删除<br>如果删除引用，jvm什么都不会做，这个导致了浮动垃圾</li>
</ul>
<p><strong>当有新引用插入进来时，记录下新的引用对象</strong></p>
<h3 id="为什么-ThreadLocalMap-的-key-是弱引用，而-value-是强引用？"><a href="#为什么-ThreadLocalMap-的-key-是弱引用，而-value-是强引用？" class="headerlink" title="为什么 ThreadLocalMap 的 key 是弱引用，而 value 是强引用？"></a>为什么 ThreadLocalMap 的 key 是弱引用，而 value 是强引用？</h3><p><img src="/../pic/v2-adecb8b867ce06a962df2a3668563101_1440w.jpg" alt="img"></p>
<h4 id="问题一：为什么-ThreadLocalMap-的-key-是弱引用？"><a href="#问题一：为什么-ThreadLocalMap-的-key-是弱引用？" class="headerlink" title="问题一：为什么 ThreadLocalMap 的 key 是弱引用？"></a>问题一：为什么 ThreadLocalMap 的 key 是弱引用？</h4><p><strong>【假设 Entry 的 key 是对 ThreadLocal 对象的强引用】</strong>。如果在其他地方都没有对这个 ThreadLocla 对象的引用了，然后在使用 ThreadLocalMap 的过程中又没有正确地在用完后就调用 remove 方法，<strong>所以这个 ThreadLocal 对象和所关联的 value 对象就会跟随着线程一直存在，这样就会可能会造成内存泄漏问题。</strong></p>
<p>特别是在使用线程池的时候，核心线程是会一直存在直到程序结束，如果这些线程中的 ThreadLocalMap 中的数据没有被及时清理，就会一直占用内存，而且在线程复用时可能会导致数据错乱的危险。</p>
<p><strong>【Entry 的 key 是对 ThreadLocal 对象的弱引用】</strong>：弱引用就意味着，如果没有其他引用对象的强引用关系，那么这个仅被弱引用引用着的对象在下次 GC 时就会被回收掉，<strong>这样在一定程度上降低内存泄漏的风险</strong>。但同时也引入了新的问题，key 虽然被回收了，但是 value 对象还在，我们无法获取，也无法删除，这样也会存在内存泄漏的风险。虽然 ThreadLocalMap 中在进行 set 和 get 操作时会进行<strong>启发式清理</strong>和<strong>探测式清理</strong>，清理一部分 key 为 null 的 Entry 对象，但是这也只是一种后备选择方案，最重要的还是开发人员在编写代码时记得在使用完数据后及时调用 remove() 方法手动清理。</p>
<p><strong>【内存泄漏就是，有些对象已经不再使用了，但是由于没有正确处理对象的引用关系，使得这个无用的对象还一直被 GC Root 直接或间接引用着，垃圾回收时就无法清理掉这些对象，如果这类对象存在很多，就会导致内存泄漏。简单地说就是有些无用对象占用着宝贵的内存空间，但又没办法清理掉它们】</strong></p>
<h4 id="问题二：为什么-ThreadLocalMap-的-value-是强引用？"><a href="#问题二：为什么-ThreadLocalMap-的-value-是强引用？" class="headerlink" title="问题二：为什么 ThreadLocalMap 的 value 是强引用？"></a>问题二：为什么 ThreadLocalMap 的 value 是强引用？</h4><p><strong>【假设Entry 的 value 是弱引用】</strong>：假设 key 所引用的 ThreadLocal 对象还被其他的引用对象强引用着，那么这个 ThreadLocal 对象就不会被 GC 回收，但如果 value 是弱引用且不被其他引用对象引用着，那 GC 的时候就被回收掉了，那线程通过 ThreadLocal 来获取 value 的时候就会获得 null，显然这不是我们希望的结果。因为对我们来说，value 才是我们想要保存的数据，ThreadLcoal 只是用来关联 value 的，如果 value 都没了，还要 ThreadLocal 干嘛呢？<strong>所以 value 不能是弱引用</strong>。</p>
<blockquote>
<p>请问会不会出现：将登录用户信息放入ThreadLocal中，业务代码中还未使用，此时GC把弱引用的key删除了，导致后续业务中获取用户信息失败？？？</p>
</blockquote>
<p>每个线程都会有一个ThreadLocal的强引用在指向着堆中的ThreadLocal对象，知道线程终止key才会失效，一般来说是不会被清理掉的，弱引用是框架层面的思考，加了一层保险</p>
<h2 id="调试排错-Java-问题排查之Linux命令"><a href="#调试排错-Java-问题排查之Linux命令" class="headerlink" title="调试排错 - Java 问题排查之Linux命令"></a>调试排错 - Java 问题排查之Linux命令</h2><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><h4 id="文本查询-grep"><a href="#文本查询-grep" class="headerlink" title="文本查询-grep"></a>文本查询-grep</h4><p>grep常用命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line">grep yoursearchkeyword f.txt     <span class="comment">#文件查找</span></span><br><span class="line">grep <span class="string">'KeyWord otherKeyWord'</span> f.txt cpf.txt <span class="comment">#多文件查找, 含空格加引号</span></span><br><span class="line">grep <span class="string">'KeyWord'</span> /home/admin -r -n <span class="comment">#目录下查找所有符合关键字的文件</span></span><br><span class="line">grep <span class="string">'keyword'</span> /home/admin -r -n -i <span class="comment"># -i 忽略大小写</span></span><br><span class="line">grep <span class="string">'KeyWord'</span> /home/admin -r -n --include *.{vm,java} <span class="comment">#指定文件后缀</span></span><br><span class="line">grep <span class="string">'KeyWord'</span> /home/admin -r -n --exclude *.{vm,java} <span class="comment">#反匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cat + grep</span></span><br><span class="line"><span class="built_in">cat</span> f.txt | grep -i keyword <span class="comment"># 查找所有keyword且不分大小写  </span></span><br><span class="line"><span class="built_in">cat</span> f.txt | grep -c <span class="string">'KeyWord'</span> <span class="comment"># 统计Keyword次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># seq + grep</span></span><br><span class="line"><span class="built_in">seq</span> 10 | grep 5 -A 3    <span class="comment">#上匹配</span></span><br><span class="line"><span class="built_in">seq</span> 10 | grep 5 -B 3    <span class="comment">#下匹配</span></span><br><span class="line"><span class="built_in">seq</span> 10 | grep 5 -C 3    <span class="comment">#上下匹配，平时用这个就妥了</span></span><br></pre></td></tr></tbody></table></figure>

<p>Grep的参数：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-i, --ignore-case：忽略字符大小写;</span><br><span class="line">-n, --line-number：显示行号;</span><br><span class="line">-c, --count：统计匹配到的行数; <span class="built_in">print</span> a count of matching lines;</span><br><span class="line"></span><br><span class="line">-B, --before-context=NUM：<span class="built_in">print</span> NUM lines of leading context   后<span class="comment">#行 </span></span><br><span class="line">-A, --after-context=NUM：<span class="built_in">print</span> NUM lines of trailing context   前<span class="comment">#行 </span></span><br><span class="line">-C, --context=NUM：<span class="built_in">print</span> NUM lines of output context           前后各<span class="comment">#行 </span></span><br></pre></td></tr></tbody></table></figure>



<h4 id="文本分析-awk"><a href="#文本分析-awk" class="headerlink" title="文本分析 - awk"></a>文本分析 - awk</h4><p>awk基本命令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line">awk <span class="string">'{print $4,$6}'</span> f.txt</span><br><span class="line">awk <span class="string">'{print NR,$0}'</span> f.txt cpf.txt    </span><br><span class="line">awk <span class="string">'{print FNR,$0}'</span> f.txt cpf.txt</span><br><span class="line">awk <span class="string">'{print FNR,FILENAME,$0}'</span> f.txt cpf.txt</span><br><span class="line">awk <span class="string">'{print FILENAME,"NR="NR,"FNR="FNR,"$"NF"="$NF}'</span> f.txt cpf.txt</span><br><span class="line"><span class="built_in">echo</span> 1:2:3:4 | awk -F: <span class="string">'{print $1,$2,$3,$4}'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配</span></span><br><span class="line">awk <span class="string">'/ldb/ {print}'</span> f.txt   <span class="comment">#匹配ldb</span></span><br><span class="line">awk <span class="string">'!/ldb/ {print}'</span> f.txt  <span class="comment">#不匹配ldb</span></span><br><span class="line">awk <span class="string">'/ldb/ &amp;&amp; /LISTEN/ {print}'</span> f.txt   <span class="comment">#匹配ldb和LISTEN</span></span><br><span class="line">awk <span class="string">'$5 ~ /ldb/ {print}'</span> f.txt <span class="comment">#第五列匹配ldb</span></span><br></pre></td></tr></tbody></table></figure>

<p>内建变量</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`NR`: 已经读出的记录数，就是行号，从1开始，NR可以理解为Number of Record的缩写。</span><br><span class="line"></span><br><span class="line">`FNR`: 各文件分别计数的行号，FNR可以理解为File Number of Record。</span><br><span class="line"></span><br><span class="line">`NF`: 一条记录的字段的数目，NF可以理解为Number of Field。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="文本处理-sed"><a href="#文本处理-sed" class="headerlink" title="文本处理 - sed"></a>文本处理 - sed</h4><p>sed常用：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本打印</span></span><br><span class="line">sed -n <span class="string">'3p'</span> xxx.log <span class="comment">#只打印第三行</span></span><br><span class="line">sed -n <span class="string">'$p'</span> xxx.log <span class="comment">#只打印最后一行</span></span><br><span class="line">sed -n <span class="string">'3,9p'</span> xxx.log <span class="comment">#只查看文件的第3行到第9行</span></span><br><span class="line">sed -n -e <span class="string">'3,9p'</span> -e <span class="string">'='</span> xxx.log <span class="comment">#打印3-9行，并显示行号</span></span><br><span class="line">sed -n <span class="string">'/root/p'</span> xxx.log <span class="comment">#显示包含root的行</span></span><br><span class="line">sed -n <span class="string">'/hhh/,/omc/p'</span> xxx.log <span class="comment"># 显示包含"hhh"的行到包含"omc"的行之间的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本替换</span></span><br><span class="line">sed -i <span class="string">'s/root/world/g'</span> xxx.log <span class="comment"># 用world 替换xxx.log文件中的root; s==search  查找并替换, g==global  全部替换, -i: implace</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本插入</span></span><br><span class="line">sed <span class="string">'1,4i hahaha'</span> xxx.log <span class="comment"># 在文件第一行和第四行的每行下面添加hahaha</span></span><br><span class="line">sed -e <span class="string">'1i happy'</span> -e <span class="string">'$a new year'</span> xxx.log  <span class="comment">#【界面显示】在文件第一行添加happy,文件结尾添加new year</span></span><br><span class="line">sed -i -e <span class="string">'1i happy'</span> -e <span class="string">'$a new year'</span> xxx.log <span class="comment">#【真实写入文件】在文件第一行添加happy,文件结尾添加new year</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本删除</span></span><br><span class="line">sed  <span class="string">'3,9d'</span> xxx.log <span class="comment"># 删除第3到第9行,只是不显示而已</span></span><br><span class="line">sed <span class="string">'/hhh/,/omc/d'</span> xxx.log <span class="comment"># 删除包含"hhh"的行到包含"omc"的行之间的行</span></span><br><span class="line">sed <span class="string">'/omc/,10d'</span> xxx.log <span class="comment"># 删除包含"omc"的行到第十行的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与find结合</span></span><br><span class="line">find . -name  <span class="string">"*.txt"</span> |xargs   sed -i <span class="string">'s/hhhh/\hHHh/g'</span></span><br><span class="line">find . -name  <span class="string">"*.txt"</span> |xargs   sed -i <span class="string">'s#hhhh#hHHh#g'</span></span><br><span class="line">find . -name  <span class="string">"*.txt"</span> -<span class="built_in">exec</span> sed -i <span class="string">'s/hhhh/\hHHh/g'</span> {} \;</span><br><span class="line">find . -name  <span class="string">"*.txt"</span> |xargs <span class="built_in">cat</span></span><br></pre></td></tr></tbody></table></figure>



<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="文件监听-tail"><a href="#文件监听-tail" class="headerlink" title="文件监听 - tail"></a>文件监听 - tail</h4><p>最常用的<code>tail -f filename</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本使用</span></span><br><span class="line"><span class="built_in">tail</span> -f xxx.log <span class="comment"># 循环监听文件</span></span><br><span class="line"><span class="built_in">tail</span> -300f xxx.log <span class="comment">#倒数300行并追踪文件</span></span><br><span class="line"><span class="built_in">tail</span> +20 xxx.log <span class="comment">#从第 20 行至文件末尾显示文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tailf使用</span></span><br><span class="line">tailf xxx.log <span class="comment">#等同于tail -f -n 10 打印最后10行，然后追踪文件</span></span><br></pre></td></tr></tbody></table></figure>



<p>tail的参数</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-f 循环读取</span><br><span class="line">-c&lt;数目&gt; 显示的字节数</span><br><span class="line">-n&lt;行数&gt; 显示文件的尾部 n 行内容</span><br><span class="line">-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</span><br></pre></td></tr></tbody></table></figure>



<h4 id="文件查找-find"><a href="#文件查找-find" class="headerlink" title="文件查找 - find"></a>文件查找 - find</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo -u admin find /home/admin /tmp /usr -name \*.<span class="built_in">log</span>(多个目录去找)</span><br><span class="line">find . -iname \*.txt(大小写都匹配)</span><br><span class="line">find . -<span class="built_in">type</span> d(当前目录下的所有子目录)</span><br><span class="line">find /usr -<span class="built_in">type</span> l(当前目录下所有的符号链接)</span><br><span class="line">find /usr -<span class="built_in">type</span> l -name <span class="string">"z*"</span> -<span class="built_in">ls</span>(符号链接的详细信息 eg:inode,目录)</span><br><span class="line">find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)</span><br><span class="line">find /home/admin f -perm 777 -<span class="built_in">exec</span> <span class="built_in">ls</span> -l {} \; (按照权限查询文件)</span><br><span class="line">find /home/admin -atime -1  1天内访问过的文件</span><br><span class="line">find /home/admin -ctime -1  1天内状态改变过的文件    </span><br><span class="line">find /home/admin -mtime -1  1天内修改过的文件</span><br><span class="line">find /home/admin -amin -1  1分钟内访问过的文件</span><br><span class="line">find /home/admin -cmin -1  1分钟内状态改变过的文件    </span><br><span class="line">find /home/admin -mmin -1  1分钟内修改过的文件</span><br></pre></td></tr></tbody></table></figure>



<h3 id="查看网络和进程"><a href="#查看网络和进程" class="headerlink" title="查看网络和进程"></a>查看网络和进程</h3><h4 id="查看所有网络接口的属性"><a href="#查看所有网络接口的属性" class="headerlink" title="查看所有网络接口的属性"></a>查看所有网络接口的属性</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查看防火墙设置"><a href="#查看防火墙设置" class="headerlink" title="查看防火墙设置"></a>查看防火墙设置</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></tbody></table></figure>

<h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>查看所有监听端口</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -lntp</span><br><span class="line">-l, --listening      display listening server sockets</span><br></pre></td></tr></tbody></table></figure>

<p>查看所有已经建立的连接</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -antp</span><br><span class="line"> -a, --all, --listening     display all sockets (default: connected)</span><br></pre></td></tr></tbody></table></figure>

<p>查看网络统计信息进程</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -s</span><br><span class="line"> -s, --statistics           display networking statistics (like SNMP)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="查看所有进程"><a href="#查看所有进程" class="headerlink" title="查看所有进程"></a>查看所有进程</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef  | grep java</span><br><span class="line">-e：显示所有进程。</span><br><span class="line">-f：全格式显示。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>top除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H -p pid</span><br></pre></td></tr></tbody></table></figure>

<h3 id="查看磁盘和内存相关"><a href="#查看磁盘和内存相关" class="headerlink" title="查看磁盘和内存相关"></a>查看磁盘和内存相关</h3><h4 id="查看内存使用"><a href="#查看内存使用" class="headerlink" title="查看内存使用"></a>查看内存使用</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br><span class="line">-h或--human-readable 以K，M，G为单位，提高信息的可读性。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查看各分区使用情况"><a href="#查看各分区使用情况" class="headerlink" title="查看各分区使用情况"></a>查看各分区使用情况</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line">-h或--human-readable 以K，M，G为单位，提高信息的可读性。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查看指定目录的大小"><a href="#查看指定目录的大小" class="headerlink" title="查看指定目录的大小"></a>查看指定目录的大小</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh</span><br><span class="line">-s或--summarize 仅显示指定目录或文件的总大小，而不显示其子目录的大小。</span><br><span class="line">-h或--human-readable 以K，M，G为单位，提高信息的可读性。</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查看内存总量"><a href="#查看内存总量" class="headerlink" title="查看内存总量"></a>查看内存总量</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep MemTotal /proc/meminfo</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查看空闲内存量"><a href="#查看空闲内存量" class="headerlink" title="查看空闲内存量"></a>查看空闲内存量</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep MemFree /proc/meminfo</span><br></pre></td></tr></tbody></table></figure>

<h4 id="查看所有分区"><a href="#查看所有分区" class="headerlink" title="查看所有分区"></a>查看所有分区</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></tbody></table></figure>



<h2 id="讲一下JVM调优过程？"><a href="#讲一下JVM调优过程？" class="headerlink" title="讲一下JVM调优过程？"></a>讲一下JVM调优过程？</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/488615913">https://zhuanlan.zhihu.com/p/488615913</a></p>
<p><strong>分析和定位当前系统的瓶颈</strong></p>
<p><strong>1）CPU指标</strong></p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 显示系统各个进程的资源使用情况</span><br><span class="line">top</span><br><span class="line">// 查看某个进程中的线程占用情况</span><br><span class="line">top -Hp pid</span><br><span class="line">// 查看当前 Java 进程的线程堆栈信息</span><br><span class="line">jstack pid</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2）JVM 内存指标</strong></p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看 Java 进程的配置信息，包括系统属性和JVM命令行标志</span><br><span class="line">jinfo pid</span><br><span class="line">// 输出 Java 进程当前的 gc 情况</span><br><span class="line">jstat -gc pid</span><br><span class="line">// 输出 Java 堆详细信息</span><br><span class="line">jmap -heap pid</span><br></pre></td></tr></tbody></table></figure>



<p><strong>制订优化方案</strong></p>
<ul>
<li>代码bug：升级修复bug。典型的有：死循环、使用无界队列。</li>
<li>不合理的JVM参数配置：优化 JVM 参数配置。典型的有：年轻代内存配置过小、堆内存配置过小、元空间配置过小。</li>
</ul>
<p><strong>对比优化前后的指标，统计优化效果</strong></p>
<h2 id="GC日志查看"><a href="#GC日志查看" class="headerlink" title="GC日志查看"></a>GC日志查看</h2><p>可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 日志文件的输出路径</span><br></pre></td></tr></tbody></table></figure>

</body></html></div><div class="article-licensing box"><div class="licensing-title"><p>JVM</p><p><a href="https://jerryzhu1229.github.io/2024/03/12/JVM/">https://jerryzhu1229.github.io/2024/03/12/JVM/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jerry Z</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-03-23</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/03/12/MySQL/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/12/%E5%B9%B6%E5%8F%91/"><span class="level-item">并发</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#JVM-内存区域"><span class="level-left"><span class="level-item">1</span><span class="level-item">**JVM 内存区域</span></span></a></li><li><a class="level is-mobile" href="#java-内存模型-happen-before-原则"><span class="level-left"><span class="level-item">2</span><span class="level-item">java 内存模型\happen-before 原则</span></span></a></li><li><a class="level is-mobile" href="#垃圾回收"><span class="level-left"><span class="level-item">3</span><span class="level-item">垃圾回收</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存分配和回收原则"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">内存分配和回收原则</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#大对象直接进入老年代"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">大对象直接进入老年代</span></span></a></li><li><a class="level is-mobile" href="#主要进行-gc-的区域"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">主要进行 gc 的区域</span></span></a></li><li><a class="level is-mobile" href="#空间分配担保"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">空间分配担保</span></span></a></li></ul></li><li><a class="level is-mobile" href="#JVM是如何判断一个对象是可回收的？"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">JVM是如何判断一个对象是可回收的？</span></span></a></li><li><a class="level is-mobile" href="#哪些对象可以作为-GC-Roots-呢？"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">哪些对象可以作为 GC Roots 呢？</span></span></a></li><li><a class="level is-mobile" href="#垃圾收集算法"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">垃圾收集算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#标记-清除算法"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">标记-清除算法</span></span></a></li><li><a class="level is-mobile" href="#复制算法"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">复制算法</span></span></a></li><li><a class="level is-mobile" href="#标记-整理算法"><span class="level-left"><span class="level-item">3.4.3</span><span class="level-item">标记-整理算法</span></span></a></li><li><a class="level is-mobile" href="#分代收集算法"><span class="level-left"><span class="level-item">3.4.4</span><span class="level-item">分代收集算法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#垃圾收集器"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">**垃圾收集器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Serial-收集器"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">Serial 收集器</span></span></a></li><li><a class="level is-mobile" href="#ParNew-收集器"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">ParNew 收集器</span></span></a></li><li><a class="level is-mobile" href="#Parallel-Scavenge-收集器"><span class="level-left"><span class="level-item">3.5.3</span><span class="level-item">Parallel Scavenge 收集器</span></span></a></li><li><a class="level is-mobile" href="#CMS-收集器"><span class="level-left"><span class="level-item">3.5.4</span><span class="level-item">**CMS 收集器</span></span></a></li><li><a class="level is-mobile" href="#G1-收集器"><span class="level-left"><span class="level-item">3.5.5</span><span class="level-item">**G1 收集器</span></span></a></li><li><a class="level is-mobile" href="#三色标记算法"><span class="level-left"><span class="level-item">3.5.6</span><span class="level-item">三色标记算法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第一种问题：-错标"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">第一种问题： 错标</span></span></a></li><li><a class="level is-mobile" href="#第二种问题：漏标，或者叫错杀"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">第二种问题：漏标，或者叫错杀</span></span></a></li><li><a class="level is-mobile" href="#为什么-ThreadLocalMap-的-key-是弱引用，而-value-是强引用？"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">为什么 ThreadLocalMap 的 key 是弱引用，而 value 是强引用？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#问题一：为什么-ThreadLocalMap-的-key-是弱引用？"><span class="level-left"><span class="level-item">3.8.1</span><span class="level-item">问题一：为什么 ThreadLocalMap 的 key 是弱引用？</span></span></a></li><li><a class="level is-mobile" href="#问题二：为什么-ThreadLocalMap-的-value-是强引用？"><span class="level-left"><span class="level-item">3.8.2</span><span class="level-item">问题二：为什么 ThreadLocalMap 的 value 是强引用？</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#调试排错-Java-问题排查之Linux命令"><span class="level-left"><span class="level-item">4</span><span class="level-item">调试排错 - Java 问题排查之Linux命令</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#文本操作"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">文本操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#文本查询-grep"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">文本查询-grep</span></span></a></li><li><a class="level is-mobile" href="#文本分析-awk"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">文本分析 - awk</span></span></a></li><li><a class="level is-mobile" href="#文本处理-sed"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">文本处理 - sed</span></span></a></li></ul></li><li><a class="level is-mobile" href="#文件操作"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">文件操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#文件监听-tail"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">文件监听 - tail</span></span></a></li><li><a class="level is-mobile" href="#文件查找-find"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">文件查找 - find</span></span></a></li></ul></li><li><a class="level is-mobile" href="#查看网络和进程"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">查看网络和进程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#查看所有网络接口的属性"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">查看所有网络接口的属性</span></span></a></li><li><a class="level is-mobile" href="#查看防火墙设置"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">查看防火墙设置</span></span></a></li><li><a class="level is-mobile" href="#查看路由表"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">查看路由表</span></span></a></li><li><a class="level is-mobile" href="#netstat"><span class="level-left"><span class="level-item">4.3.4</span><span class="level-item">netstat</span></span></a></li><li><a class="level is-mobile" href="#查看所有进程"><span class="level-left"><span class="level-item">4.3.5</span><span class="level-item">查看所有进程</span></span></a></li><li><a class="level is-mobile" href="#top"><span class="level-left"><span class="level-item">4.3.6</span><span class="level-item">top</span></span></a></li></ul></li><li><a class="level is-mobile" href="#查看磁盘和内存相关"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">查看磁盘和内存相关</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#查看内存使用"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">查看内存使用</span></span></a></li><li><a class="level is-mobile" href="#查看各分区使用情况"><span class="level-left"><span class="level-item">4.4.2</span><span class="level-item">查看各分区使用情况</span></span></a></li><li><a class="level is-mobile" href="#查看指定目录的大小"><span class="level-left"><span class="level-item">4.4.3</span><span class="level-item">查看指定目录的大小</span></span></a></li><li><a class="level is-mobile" href="#查看内存总量"><span class="level-left"><span class="level-item">4.4.4</span><span class="level-item">查看内存总量</span></span></a></li><li><a class="level is-mobile" href="#查看空闲内存量"><span class="level-left"><span class="level-item">4.4.5</span><span class="level-item">查看空闲内存量</span></span></a></li><li><a class="level is-mobile" href="#查看所有分区"><span class="level-left"><span class="level-item">4.4.6</span><span class="level-item">查看所有分区</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#讲一下JVM调优过程？"><span class="level-left"><span class="level-item">5</span><span class="level-item">讲一下JVM调优过程？</span></span></a></li><li><a class="level is-mobile" href="#GC日志查看"><span class="level-left"><span class="level-item">6</span><span class="level-item">GC日志查看</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/cs/"><span class="level-start"><span class="level-item">cs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a><p class="is-size-7"><span>&copy; 2024 Jerry Z</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>