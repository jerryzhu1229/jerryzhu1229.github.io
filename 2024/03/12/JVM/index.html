<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>JVM - hao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="hao"><meta name="msapplication-TileImage" content="/img/2751710164138_.pic.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="hao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="hao"><meta property="og:url" content="https://jerryzhu1229.github.io/2024/03/12/JVM/"><meta property="og:site_name" content="hao"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/java-runtime-data-areas-jdk1.8.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/hotspot-heap-structure.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/method-area-implementation.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/method-area-jdk1.7.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/a7598135c2039f254af77fa895bce1ef.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/serial-garbage-collector.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/parnew-garbage-collector.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/parallel-scavenge-garbage-collector.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/928"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/cms-garbage-collector-20240320092604199.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/g1-garbage-collector.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/656"><meta property="article:published_time" content="2024-03-12T01:57:04.000Z"><meta property="article:modified_time" content="2024-03-20T01:57:50.257Z"><meta property="article:author" content="Jerry Z"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jerryzhu1229.github.io/pic/java-runtime-data-areas-jdk1.8.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerryzhu1229.github.io/2024/03/12/JVM/"},"headline":"JVM","image":["https://jerryzhu1229.github.io/pic/java-runtime-data-areas-jdk1.8.png","https://jerryzhu1229.github.io/pic/hotspot-heap-structure.png","https://jerryzhu1229.github.io/pic/method-area-implementation.png","https://jerryzhu1229.github.io/pic/method-area-jdk1.7.png","https://jerryzhu1229.github.io/pic/a7598135c2039f254af77fa895bce1ef.png","https://jerryzhu1229.github.io/pic/serial-garbage-collector.png","https://jerryzhu1229.github.io/pic/parnew-garbage-collector.png","https://jerryzhu1229.github.io/pic/parallel-scavenge-garbage-collector.png","https://jerryzhu1229.github.io/pic/cms-garbage-collector-20240320092604199.png","https://jerryzhu1229.github.io/pic/g1-garbage-collector.png"],"datePublished":"2024-03-12T01:57:04.000Z","dateModified":"2024-03-20T01:57:50.257Z","author":{"@type":"Person","name":"Jerry Z"},"publisher":{"@type":"Organization","name":"hao","logo":{"@type":"ImageObject","url":"https://jerryzhu1229.github.io/img/2751710164138_.pic.jpg"}},"description":""}</script><link rel="canonical" href="https://jerryzhu1229.github.io/2024/03/12/JVM/"><link rel="icon" href="/img/2751710164138_.pic.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/cs">计算机基础</a><a class="navbar-item" href="/categories/java">后端开发</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jerryzhu1229"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-12T01:57:04.000Z" title="2024/3/12 09:57:04">2024-03-12</time>发表</span><span class="level-item"><time dateTime="2024-03-20T01:57:50.257Z" title="2024/3/20 09:57:50">2024-03-20</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">27 分钟读完 (大约3979个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JVM</h1><div class="content"><html><head></head><body><h2 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="**Java 内存区域"></a>**Java 内存区域</h2><p><strong>JDK 1.8</strong>：</p>
<p><img src="/../pic/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）"></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器：记录程序执行到的位置	</li>
<li>虚拟机栈<ul>
<li><strong>局部变量表</strong>：存放了编译期可知的各种数据类型</li>
<li><strong>操作数栈</strong>：存放方法执行过程中产生的中间计算结果</li>
<li><strong>动态链接</strong>：将符号引用转换为调用方法的直接引用。多态</li>
<li><strong>方法返回地址</strong></li>
</ul>
</li>
<li>本地方法栈：执行本地方法</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li><p>堆：存放类实例和数组</p>
<p><img src="/../pic/hotspot-heap-structure.png" alt="堆内存结构"></p>
<p>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存</p>
</li>
<li><p>方法区：（方法区逻辑上在堆中）存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、JIT 代码缓存等数据</strong></p>
<p><img src="/../pic/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p>
</li>
<li><p>运行时常量池：字面量（Literal 源代码中的固定值的表示法，字面量包括整数、浮点数和字符串字面量）和符号引用（Symbolic Reference，包括类符号引用、字段符号引用、方法符号引用、接口方法符号）</p>
</li>
<li><p>字符串常量池。主要目的是为了避免字符串的重复创建。</p>
</li>
</ul>
<p><img src="/../pic/method-area-jdk1.7.png" alt="method-area-jdk1.7"></p>
<h2 id="java-内存模型-happen-before-原则"><a href="#java-内存模型-happen-before-原则" class="headerlink" title="java 内存模型\happen-before 原则"></a>java 内存模型\happen-before 原则</h2><blockquote>
<p>有什么存在作用？</p>
</blockquote>
<p>java 内存模型跟 cpu 缓存模型类型，是基于 cpu 缓存模型来建立的，Java内存模型定义了共享内存系统中多线程程序读写操作行为的规范，是为了解决并发编程问题而存在的。</p>
<blockquote>
<p>JMM对内存的划分？</p>
</blockquote>
<p>划分为主内存和工作内存两种</p>
<p>规定所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</p>
<blockquote>
<p>主内存和工作内存的交互操作</p>
</blockquote>
<p>首先是从lock加锁开始，把主内存中的变量标志为一条线程独占的状态；read读取，将一个变量的值从主内存传输到工作内存中；load加载，把read得到的值加载到工作内存的变量副本中；use使用，把工作内存中变量的值传递给执行引擎；assign赋值，把从执行引擎接收到的值赋值给工作内存的变量；store存储，把工作内存中变量的值传送回主内存中；write写入，把store得到的值放入主内存的变量中；最后是unlock解锁，把主内存中处于锁定状态的变量释放出来，<br><img src="/../pic/a7598135c2039f254af77fa895bce1ef.png" alt="image-20210116112358455"></p>
<blockquote>
<p>内存交互基本操作的三个特性的理解？</p>
</blockquote>
<p>原子性（synchroinzed）、可见性（volatile）、以及有序性（happen-before）。</p>
<blockquote>
<p>happen-before</p>
</blockquote>
<p>happen-before原则是Java内存模型中定义的两项操作之间的偏序关系。</p>
<p><strong>Happens-Before关系只是描述结果的可见性，并不表示指令执行的先后顺序，也就是说只要不对结果产生影响，仍然允许指令重排序。</strong></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p>大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p>
<h4 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h4><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p>
<h3 id="JVM是如何判断一个对象是可回收的？"><a href="#JVM是如何判断一个对象是可回收的？" class="headerlink" title="JVM是如何判断一个对象是可回收的？"></a>JVM是如何判断一个对象是可回收的？</h3><ol>
<li>引用计数法</li>
</ol>
<p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的。</li>
</ul>
<p>**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</p>
<ol start="2">
<li>可达性分析算法</li>
</ol>
<p>基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>
<ul>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p>
<ul>
<li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li>
<li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li>
</ul>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="**垃圾收集器"></a>**垃圾收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="/../pic/serial-garbage-collector.png" alt="Serial 收集器"></p>
<p> <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>
<p>不良用户体验但<strong>简单而高效（与其他收集器的单线程相比）</strong></p>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p>
<p><img src="/../pic/parnew-garbage-collector.png" alt="ParNew 收集器 "></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p>parnew+cms</p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="/../pic/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="**CMS 收集器"></a>**CMS 收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收<strong>停顿时间</strong>为目标的收集器。它非常符合在注重用户体验的应用上使用。<strong>并发收集器</strong>。</p>
<p><strong>初始标记</strong>：记录下直接与 root 相连的对象，速度很快 </p>
<p><strong>并发标记</strong>： 同时开启 GC 和用户线程，去记录可达对象</p>
<p><strong>重新标记</strong>：修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</p>
<p><img src="/../pic/928" alt="img"></p>
<p><strong>并发清除</strong>：开启用户线程，同时 GC 线程开始对未标记的区域做清扫</p>
<p><img src="/../pic/cms-garbage-collector-20240320092604199.png" alt="CMS 收集器"></p>
<p>主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><p><strong>对 CPU 资源敏感；</strong></p>
</li>
<li><p><strong>无法处理浮动垃圾；</strong></p>
</li>
<li><p><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></p>
</li>
</ul>
<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="**G1 收集器"></a>**G1 收集器</h4><p>以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</p>
<p>特点：</p>
<ul>
<li><strong>并行与并发</strong>：使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li>
</ul>
<p><strong>几个步骤：</strong></p>
<ul>
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p><img src="/../pic/g1-garbage-collector.png" alt="G1 收集器"></p>
<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> </p>
<h4 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h4><ul>
<li>白色：没有检查（或者检查过了，确实没有引用指向它了）</li>
<li>灰色：自身被检查了，成员没被检查完（可以认为访问到了，但是正在被检查，就是图的遍历里那些在队列中的节点）</li>
<li>黑色：自身和成员都被检查完了</li>
</ul>
<h3 id="第一种问题：-错标"><a href="#第一种问题：-错标" class="headerlink" title="第一种问题： 错标"></a>第一种问题： 错标</h3><p>标记过不是垃圾的，变成了垃圾（也叫浮动垃圾）</p>
<h3 id="第二种问题：漏标，或者叫错杀"><a href="#第二种问题：漏标，或者叫错杀" class="headerlink" title="第二种问题：漏标，或者叫错杀"></a>第二种问题：漏标，或者叫错杀</h3><p>G1：<strong>写屏障</strong>+ <strong>SATB</strong> <strong>（Snapshot At The Beginning）</strong></p>
<p>尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB），当某个时刻 的GC Roots确定后，当时的对象图就已经确定了。<br>如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。</p>
<p><strong>cms：写屏障+ 增量更新</strong></p>
<ul>
<li>新增<br>如果新增黑色到白色的引用，那么jvm会通过写屏障，来把黑色置为灰色</li>
<li>删除<br>如果删除引用，jvm什么都不会做，这个导致了浮动垃圾</li>
</ul>
<p><img src="/../pic/656" alt="img"></p>
<p><strong>当有新引用插入进来时，记录下新的引用对象</strong></p>
<h3 id="讲一下JVM调优过程？"><a href="#讲一下JVM调优过程？" class="headerlink" title="讲一下JVM调优过程？"></a>讲一下JVM调优过程？</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/488615913">https://zhuanlan.zhihu.com/p/488615913</a></p>
<p><strong>分析和定位当前系统的瓶颈</strong></p>
<p><strong>1）CPU指标</strong></p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 显示系统各个进程的资源使用情况</span><br><span class="line">top</span><br><span class="line">// 查看某个进程中的线程占用情况</span><br><span class="line">top -Hp pid</span><br><span class="line">// 查看当前 Java 进程的线程堆栈信息</span><br><span class="line">jstack pid</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2）JVM 内存指标</strong></p>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看 Java 进程的配置信息，包括系统属性和JVM命令行标志</span><br><span class="line">jinfo pid</span><br><span class="line">// 输出 Java 进程当前的 gc 情况</span><br><span class="line">jstat -gc pid</span><br><span class="line">// 输出 Java 堆详细信息</span><br><span class="line">jmap -heap pid</span><br></pre></td></tr></tbody></table></figure>



<p><strong>制订优化方案</strong></p>
<ul>
<li>代码bug：升级修复bug。典型的有：死循环、使用无界队列。</li>
<li>不合理的JVM参数配置：优化 JVM 参数配置。典型的有：年轻代内存配置过小、堆内存配置过小、元空间配置过小。</li>
</ul>
<p><strong>对比优化前后的指标，统计优化效果</strong></p>
<h2 id="GC日志查看"><a href="#GC日志查看" class="headerlink" title="GC日志查看"></a>GC日志查看</h2><p>可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 日志文件的输出路径</span><br></pre></td></tr></tbody></table></figure>

</body></html></div><div class="article-licensing box"><div class="licensing-title"><p>JVM</p><p><a href="https://jerryzhu1229.github.io/2024/03/12/JVM/">https://jerryzhu1229.github.io/2024/03/12/JVM/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jerry Z</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-03-20</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/03/12/MySQL/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/12/%E5%B9%B6%E5%8F%91/"><span class="level-item">并发</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Java-内存区域"><span class="level-left"><span class="level-item">1</span><span class="level-item">**Java 内存区域</span></span></a></li><li><a class="level is-mobile" href="#java-内存模型-happen-before-原则"><span class="level-left"><span class="level-item">2</span><span class="level-item">java 内存模型\happen-before 原则</span></span></a></li><li><a class="level is-mobile" href="#垃圾回收"><span class="level-left"><span class="level-item">3</span><span class="level-item">垃圾回收</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存分配和回收原则"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">内存分配和回收原则</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#大对象直接进入老年代"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">大对象直接进入老年代</span></span></a></li><li><a class="level is-mobile" href="#主要进行-gc-的区域"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">主要进行 gc 的区域</span></span></a></li><li><a class="level is-mobile" href="#空间分配担保"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">空间分配担保</span></span></a></li></ul></li><li><a class="level is-mobile" href="#JVM是如何判断一个对象是可回收的？"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">JVM是如何判断一个对象是可回收的？</span></span></a></li><li><a class="level is-mobile" href="#垃圾收集算法"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">垃圾收集算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#标记-清除算法"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">标记-清除算法</span></span></a></li><li><a class="level is-mobile" href="#复制算法"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">复制算法</span></span></a></li><li><a class="level is-mobile" href="#标记-整理算法"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">标记-整理算法</span></span></a></li><li><a class="level is-mobile" href="#分代收集算法"><span class="level-left"><span class="level-item">3.3.4</span><span class="level-item">分代收集算法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#垃圾收集器"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">**垃圾收集器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Serial-收集器"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">Serial 收集器</span></span></a></li><li><a class="level is-mobile" href="#ParNew-收集器"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">ParNew 收集器</span></span></a></li><li><a class="level is-mobile" href="#Parallel-Scavenge-收集器"><span class="level-left"><span class="level-item">3.4.3</span><span class="level-item">Parallel Scavenge 收集器</span></span></a></li><li><a class="level is-mobile" href="#CMS-收集器"><span class="level-left"><span class="level-item">3.4.4</span><span class="level-item">**CMS 收集器</span></span></a></li><li><a class="level is-mobile" href="#G1-收集器"><span class="level-left"><span class="level-item">3.4.5</span><span class="level-item">**G1 收集器</span></span></a></li><li><a class="level is-mobile" href="#三色标记算法"><span class="level-left"><span class="level-item">3.4.6</span><span class="level-item">三色标记算法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#第一种问题：-错标"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">第一种问题： 错标</span></span></a></li><li><a class="level is-mobile" href="#第二种问题：漏标，或者叫错杀"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">第二种问题：漏标，或者叫错杀</span></span></a></li><li><a class="level is-mobile" href="#讲一下JVM调优过程？"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">讲一下JVM调优过程？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#GC日志查看"><span class="level-left"><span class="level-item">4</span><span class="level-item">GC日志查看</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/cs/"><span class="level-start"><span class="level-item">cs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a><p class="is-size-7"><span>&copy; 2024 Jerry Z</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>