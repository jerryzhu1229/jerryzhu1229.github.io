<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java基础 - hao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="hao"><meta name="msapplication-TileImage" content="/img/2751710164138_.pic.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="hao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="hao"><meta property="og:url" content="https://jerryzhu1229.github.io/2024/03/12/Java%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="hao"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/jdk-include-jre.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/java-code-to-machine-code-with-jit.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/primitive-type-vs-packaging-type.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/v2-32e425cdb908c47586267e59228fcd22_720w.webp"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/member-var-vs-local-var.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/shallow&amp;amp;deep-copy.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/image-20240215205634342.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/image-20240216130700188.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/image-20240216001213876.png"><meta property="og:image" content="https://jerryzhu1229.github.io/..../pic/e5cb4bdae7764001aa4b980d8d7c9299.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/ec9022edf4b64adca63c15a72bd0c738.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/image-20240216111701776.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/image-20220413175809959.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/image-20220413180021072.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjAzMzMx,size_16,color_FFFFFF,t_70.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjAzMzMx,size_16,color_FFFFFF,t_70-20240219220012195.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark-20240214172511586.png"><meta property="article:published_time" content="2024-03-11T17:19:59.000Z"><meta property="article:modified_time" content="2024-03-11T17:33:36.144Z"><meta property="article:author" content="Jerry Z"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jerryzhu1229.github.io/pic/jdk-include-jre.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerryzhu1229.github.io/2024/03/12/Java%E5%9F%BA%E7%A1%80/"},"headline":"Java基础","image":["https://jerryzhu1229.github.io/pic/jdk-include-jre.png","https://jerryzhu1229.github.io/pic/java-code-to-machine-code-with-jit.png","https://jerryzhu1229.github.io/pic/primitive-type-vs-packaging-type.png","https://jerryzhu1229.github.io/pic/v2-32e425cdb908c47586267e59228fcd22_720w.webp","https://jerryzhu1229.github.io/pic/member-var-vs-local-var.png","https://jerryzhu1229.github.io/pic/shallow&amp;deep-copy.png","https://jerryzhu1229.github.io/pic/image-20240215205634342.png","https://jerryzhu1229.github.io/pic/image-20240216130700188.png","https://jerryzhu1229.github.io/pic/image-20240216001213876.png","https://jerryzhu1229.github.io/..../pic/e5cb4bdae7764001aa4b980d8d7c9299.png","https://jerryzhu1229.github.io/pic/ec9022edf4b64adca63c15a72bd0c738.png","https://jerryzhu1229.github.io/pic/image-20240216111701776.png","https://jerryzhu1229.github.io/pic/image-20220413175809959.png","https://jerryzhu1229.github.io/pic/image-20220413180021072.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjAzMzMx,size_16,color_FFFFFF,t_70.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjAzMzMx,size_16,color_FFFFFF,t_70-20240219220012195.png","https://jerryzhu1229.github.io/pic/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark-20240214172511586.png"],"datePublished":"2024-03-11T17:19:59.000Z","dateModified":"2024-03-11T17:33:36.144Z","author":{"@type":"Person","name":"Jerry Z"},"publisher":{"@type":"Organization","name":"hao","logo":{"@type":"ImageObject","url":"https://jerryzhu1229.github.io/img/2751710164138_.pic.jpg"}},"description":""}</script><link rel="canonical" href="https://jerryzhu1229.github.io/2024/03/12/Java%E5%9F%BA%E7%A1%80/"><link rel="icon" href="/img/2751710164138_.pic.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/cs">计算机基础</a><a class="navbar-item" href="/categories/java">后端开发</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jerryzhu1229"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-11T17:19:59.000Z" title="2024/3/12 01:19:59">2024-03-12</time>发表</span><span class="level-item"><time dateTime="2024-03-11T17:33:36.144Z" title="2024/3/12 01:33:36">2024-03-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">2 小时读完 (大约18894个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java基础</h1><div class="content"><html><head></head><body><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。</p>
<p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。</p>
<p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p>
<p><img src="/../pic/jdk-include-jre.png" alt="JDK 包含 JRE"></p>
<h3 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h3><p>在 Java 中，<strong>JVM 可以理解的代码就叫做字节码</strong>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>Java 语言通过字节码的方式，在一定程度上<strong>解决了传统解释型语言执行效率低</strong>的问题，同时又保留了解释型语言<strong>可移植</strong>的特点。</p>
<h3 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h3><p>编译型语言：执行效率高、开发效率低</p>
<p>解释型语言：开发效率高、执行效率低</p>
<p>Java语言需要经过编译(源码经过 <u>javac 编译</u>变成字节码)、解释（字节码经过 <u>解释器和 JIT(即时编译器)</u>变成机器码）</p>
<p><img src="/../pic/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程"></p>
<h3 id="AOT-有什么优点？为什么不全部使用-AOT-呢？"><a href="#AOT-有什么优点？为什么不全部使用-AOT-呢？" class="headerlink" title="AOT 有什么优点？为什么不全部使用 AOT 呢？"></a>AOT 有什么优点？为什么不全部使用 AOT 呢？</h3><p>AOT(ahead of time Compilation)。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）</p>
<p>优点：启动速度、内存占用、打包体积。</p>
<p>缺点：极限处理能力不如 JIT</p>
<p>AOT 不能使用反射、动态代理、动态加载，常用框架和库（spring，CGLIB）都需要这些特性质。</p>
<hr>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><p><img src="/../pic/primitive-type-vs-packaging-type.png" alt="基本类型 vs 包装类型"></p>
<p>基本类型 vs 包装类型</p>
<ul>
<li><p><strong>用途</strong>：</p>
<ul>
<li>基本类型：定义常量和局部变量</li>
<li>包装类型：方法参数、对象属性</li>
<li>包装类型可用于泛型，而基本类型不可以。</li>
</ul>
</li>
<li><p><strong>存储方式</strong>：</p>
<ul>
<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的<code>局部变量表</code>中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中（类的实例），被<code>static </code>修饰的存放在 Java 虚拟机的堆中（Class对象）。</li>
<li>包装类型属于对象类型，几乎所有对象实例都存在于堆中。</li>
</ul>
</li>
<li><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p>
</li>
<li><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p>
</li>
<li><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p>
</li>
</ul>
<h3 id="为什么说是几乎所有对象实例都存在于堆中呢？"><a href="#为什么说是几乎所有对象实例都存在于堆中呢？" class="headerlink" title="为什么说是几乎所有对象实例都存在于堆中呢？"></a><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong></h3><p>这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存<a href="###%E5%AF%B9%E8%B1%A1%E6%80%8E%E4%B9%88%E5%88%86%E9%85%8D">不充部分</a></p>
<h3 id="基本数据类型是否都存放在栈中？"><a href="#基本数据类型是否都存放在栈中？" class="headerlink" title="基本数据类型是否都存放在栈中？"></a><strong>基本数据类型是否都存放在栈中？</strong></h3><p>基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中(是否被 static 修饰都是在堆中)</p>
<h3 id="包装类型的缓存机制了解么？"><a href="#包装类型的缓存机制了解么？" class="headerlink" title="包装类型的缓存机制了解么？"></a>包装类型的缓存机制了解么？</h3><p>作用：提升性能</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><strong><code>Character</code> 缓存源码:</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> {</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) { <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>{}</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<h3 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h3><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong>（常量、局部变量用基本数据类型）</p>
<h3 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h3><p>与计算机保存浮点数机制有关。表示一个数字时，宽度有限，无线循环的小数存储在计算机时只能被截断，所以导致精度丢失。</p>
<h3 id="浮点型从二进制的视角是怎么存储的？"><a href="#浮点型从二进制的视角是怎么存储的？" class="headerlink" title="浮点型从二进制的视角是怎么存储的？"></a>浮点型从二进制的视角是怎么存储的？</h3><p>符号位+指数位+尾号位</p>
<p><img src="/../pic/v2-32e425cdb908c47586267e59228fcd22_720w.webp" alt="img"></p>
<p>这32个二进制位的内存编号从高到低 (从31到0), 共包含如下几个部分:</p>
<p><strong>sign: 符号位, 即图中蓝色的方块</strong></p>
<p><strong>biased exponent: 偏移后的指数位（偏移量 127 保证指数非负数）, 即图中绿色的方块</strong></p>
<p><strong>fraction: 尾数位, 即图中红色的方块</strong></p>
<h3 id="（IEEE-754）小数位如何计算出来的？"><a href="#（IEEE-754）小数位如何计算出来的？" class="headerlink" title="（IEEE 754）小数位如何计算出来的？"></a>（IEEE 754）小数位如何计算出来的？</h3><p>如果我们现在想用浮点数表示 0.2，它的结果会是多少呢？</p>
<p>0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">0.8 * 2 = 1.6 -&gt; 1</span><br><span class="line">0.6 * 2 = 1.2 -&gt; 1</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0（发生循环）</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>所以 0.2(D) = 0.00110…(B)。</p>
<h3 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h3><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<h3 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>
<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>
<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="成员变量与局部变量的区别？"><a href="#成员变量与局部变量的区别？" class="headerlink" title="成员变量与局部变量的区别？"></a>成员变量与局部变量的区别？</h3><p><img src="/../pic/member-var-vs-local-var.png" alt="成员变量 vs 局部变量"></p>
<p><strong>语法形式</strong>：成员变量属于类，局部变量属于代码块、方法定义变量和方法的参数；成员变量可以被访问控制修饰符以及<code>static</code> 修饰、局部变量不可以。</p>
<p><strong>存储方式</strong>：成员变量存在于堆内存，局部变量则存在于栈内存。</p>
<p><strong>生存时间</strong>：从变量在内存中的生存时间上看，成员变量——对象同步，而局部变量——方法同步。</p>
<p><strong>默认值</strong>：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（<u>一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值</u>），而局部变量则不会自动赋值。</p>
<h3 id="为什么成员变量有默认值？"><a href="#为什么成员变量有默认值？" class="headerlink" title="为什么成员变量有默认值？"></a><strong>为什么成员变量有默认值？</strong></h3><ol>
<li>不考虑变量类型。若没有默认值，变量存储的是内存地址对应的任意随机值，即遗留值，可以会出现意外或信息泄露问题</li>
<li>对于编译器 javac 来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”影响用户体验，所以采用自动赋默认值</li>
</ol>
<h3 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h3><p>所有类的实例共用一份静态变量，节省内存</p>
<p>（若被 private 修饰就不能用类名.变量名访问）</p>
<p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p>
<h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h3><p><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</p>
<p><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以<strong>参加表达式运算</strong>; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</p>
<p><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</p>
<p>⚠️ 注意 <code>char</code> 在 Java 中占<strong>两个字节</strong>。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h3><p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><ol>
<li><p>调用方式：</p>
<p>​	在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p>​	为了避免混淆建议静态方法使用前一种</p>
</li>
<li><p>访问类成员是否存在限制：</p>
<p>​	静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
</li>
</ol>
<h3 id="重载和重写有什么区别？"><a href="#重载和重写有什么区别？" class="headerlink" title="重载和重写有什么区别？"></a>重载和重写有什么区别？</h3><p><strong>重载</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>方法名、参数列表必须相同，<u>子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类</u>（更精细），访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>总结</strong></p>
<p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p>
<p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》，<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/892">issue#892open in new window</a> ）：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
<h2 id="面相对象基础"><a href="#面相对象基础" class="headerlink" title="面相对象基础"></a>面相对象基础</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="对象的相等和引用相等的区别"><a href="#对象的相等和引用相等的区别" class="headerlink" title="对象的相等和引用相等的区别"></a>对象的相等和引用相等的区别</h3><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<h3 id="如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗?"></a>如果一个类没有声明构造方法，该程序能正确执行吗?</h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。</p>
<p>我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>
<h3 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h3><p>构造方法特点如下：</p>
<ul>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><p><strong>封装</strong></p>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<p><strong>继承</strong></p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类<strong>进行扩展</strong>。</li>
<li>子类可以<strong>用自己的方式实现</strong>父类的方法。</li>
</ol>
<p><strong>多态</strong></p>
<p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="*接口和抽象类有什么共同点和区别？"></a>*接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong>：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>接口主要用于<strong>对类的行为进行约束</strong>，你实现了某个接口就具有了对应的行为。抽象类主要<strong>用于代码复用</strong>，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<p><img src="/../pic/shallow&amp;deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p>
<hr>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable { }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h3><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<p><code>Object</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> {</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>equals()</code> 方法存在两种使用情况：</p>
<ul>
<li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ul>
<h3 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a>hashCode() 有什么用？</h3><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p>
<blockquote>
<p>⚠️ 注意：该方法在 <strong>Oracle OpenJDK8</strong> 中默认是 “使用线程局部状态来实现 Marsaglia’s xor-shift 随机数生成”, 并不是 “地址” 或者 “地址转换而来”, 不同 JDK/VM 可能不同在 <strong>Oracle OpenJDK8</strong> 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。</p>
</blockquote>
<h3 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a>为什么要有 hashCode？</h3><p>在 HashMap 和 HashSet 中都需要用到 hashCode，以 HashSet 为例：</p>
<p>​	当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的<strong>效率会更高</strong></p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓<strong>哈希碰撞</strong>也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p><strong>思考</strong>：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p>
<p>两个相同的对象加到 HashMap 中，对应的 hashCode 不同，但是 HashMap 是先判断 hashCode 是否相同来判断是否有重复 key，最终会导致 HashMap 存在两个相同的对象同时作为 Key，这与 HashMap 的 key 不可以重复相悖。</p>
<p><strong>总结</strong>：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>对象 Object：表示的是某一类事物的抽象的名词和概念，是<u>对一类事物的抽象表示</u></p>
<p>类 Class：<u>对象在计算机中的表示</u>，如定义一个“人”的类</p>
<p>实例 Instance：<u>根据类创建出来的一个个具体的“对象”</u>，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<p>Oop：ordinary object point</p>
<h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h3><ol>
<li>申请空间，给成员变量赋默认值</li>
<li>调用 init 构造函数，给成员变量赋值</li>
<li>建立引用和对象的连接</li>
</ol>
<p><img src="/../pic/image-20240215205634342.png" alt="image-20240215205634342"></p>
<hr>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singletonPattern01</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">singletonPattern01</span> <span class="variable">SINGLE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">singletonPattern01</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singletonPattern01</span><span class="params">()</span>{};</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singletonPattern01 <span class="title function_">getSingle</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> SINGLE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>优点：这种写法比较简单，就是<strong>在类加载的时候就完成实例化。避免了线程同步问题。</strong></li>
<li>缺点：在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%8A%A0%E8%BD%BD&amp;spm=1001.2101.3001.7020">类加载</a>的时候就完成实例化，没有达到Lazy Loading的效果。如果从未使用过这个实例，则会<strong>造成内存的浪费</strong>。</li>
</ul>
<h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>起到了Lazy Loading的效果，但是只能在单线程下使用。</p>
<p>如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式。</p>
<p>结论：在实际开发中，不要使用这种方式.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> * 懒汉式单例模式</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singletonPattern02</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> singletonPattern02 SINGLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singletonPattern02</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singletonPattern02 <span class="title function_">getInstance</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">if</span>(SINGLE == <span class="literal">null</span>){</span><br><span class="line">							SINGLE = <span class="keyword">new</span> <span class="title class_">singletonPattern02</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> SINGLE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="双重检查锁（DCL-double-check-lock）"><a href="#双重检查锁（DCL-double-check-lock）" class="headerlink" title="双重检查锁（DCL double check lock）"></a>双重检查锁（DCL double check lock）</h4><p>双重检查概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。</p>
<p>这样，实例化代码只会执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步.</p>
<p>线程安全；延迟加载；效率较高</p>
<p>结论：在实际开发中，推荐使用这种单例设计模式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singletonPattern02</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> singletonPattern02 SINGLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singletonPattern02</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singletonPattern02 <span class="title function_">getInstance</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(SINGLE == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span> (singletonPattern02.class){</span><br><span class="line">                <span class="keyword">if</span> (SINGLE == <span class="literal">null</span>){</span><br><span class="line">                    <span class="keyword">try</span>{</span><br><span class="line">                        Thread.sleep(<span class="number">1L</span>);</span><br><span class="line">                    }<span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    SINGLE = <span class="keyword">new</span> <span class="title class_">singletonPattern02</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> SINGLE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p><strong>DCL要不要加 volatile</strong></p>
<p>要。</p>
<p>假如 new singletonPattern02()时候发生指令重排序，先建立了连接，那么 SINGLE！=null ，多线程时候另一个线程就会直接 返回半初始化的对象。</p>
<p>所以说，这段代码要不要加volatile？必须加！<strong>加了volatile的这块内存，对于它的读写访问不可以重排序！</strong></p>
<p><img src="/../pic/image-20240216130700188.png" alt="image-20240216130700188"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaoyajie1011/article/details/106812327">https://blog.csdn.net/zhaoyajie1011/article/details/106812327</a></p>
<h4 id="静态内部类形式"><a href="#静态内部类形式" class="headerlink" title="静态内部类形式"></a><strong>静态内部类形式</strong></h4><p>这种方式采用了类加载的机制来保证初始化实例时只有一个线程。</p>
<p>静态内部类方式在Singleton类被加载时并不会立即实例化，而是在需要实例化<br>时，调用getSingleTon方法，才会加载Inner类，从而完成Singleton的实例化。</p>
<p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们<br>保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p>
<p>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</p>
<p>结论：推荐使用.</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singletonPattern03</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singletonPattern03</span><span class="params">()</span>{};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">singletonHolder</span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">singletonPattern03</span> <span class="variable">SINGLE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">singletonPattern03</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singletonPattern03 <span class="title function_">getInstance</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> singletonHolder.SINGLE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<hr>
<h3 id="java中的引用类型的对象存放在哪里"><a href="#java中的引用类型的对象存放在哪里" class="headerlink" title="java中的引用类型的对象存放在哪里"></a>java中的引用类型的对象存放在哪里</h3><p>根据上下文来确定。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void func()</span><br><span class="line">{</span><br><span class="line">  Object obj = new Object();//这个obj在函数的栈里。</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">{</span><br><span class="line">  private Object obj = new Object();//这个obj随对应的Test对象分配在堆里</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于方法中的局部变量的引用时存放在java运行时数据区的栈中</p>
<p>对于实例变量则是存放在java运行时数据区的堆中。</p>
<hr>
<h3 id="Class-实例究竟在-method-area-还是在-heap"><a href="#Class-实例究竟在-method-area-还是在-heap" class="headerlink" title="Class 实例究竟在 method area 还是在 heap"></a>Class 实例究竟在 method area 还是在 heap</h3><p>hotspot使用了 OOP-KLASS 模型来表示 java 对象</p>
<p>main方法中：Object o = new Object();</p>
<p><img src="/../pic/image-20240216001213876.png" alt="image-20240216001213876"></p>
<ol>
<li>jvm在加载class时，创建instanceKlass，表示其<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%85%83%E6%95%B0%E6%8D%AE&amp;spm=1001.2101.3001.7020">元数据</a>，包括常量池、字段、方法等，存放在方法区；instanceKlass是jvm中的数据结构；（vm加载的字节码，也就是.class文件，被加载到方法区里面，叫Klass，是一个C++对象，含有类的信息、虚方法表等。）</li>
<li>在new一个对象时，jvm创建instanceOopDesc，来表示这个对象，存放在堆区，其引用，存放在栈区；它用来表示对象的实例信息，看起来像个指针实际上是藏在指针里的对象；instanceOopDesc对应java中的对象实例；</li>
<li>HotSpot并不把instanceKlass暴露给Java，而会另外创建对应的instanceOopDesc来表示java.lang.Class对象，并将后者称为前者的“Java镜像”，<strong>klass持有指向oop引用</strong>(_java_mirror便是该instanceKlass对Class对象的引用)；</li>
<li>要注意，new操作返回的instanceOopDesc类型指针指向instanceKlass，而instanceKlass指向了对应的类型的Class实例的instanceOopDesc；有点绕，简单说，就是Person实例——&gt;Person的instanceKlass——&gt;Person的Class。</li>
</ol>
<hr>
<h3 id="对象在内存中的存储布局"><a href="#对象在内存中的存储布局" class="headerlink" title="对象在内存中的存储布局"></a>对象在内存中的存储布局</h3><p>instanceOopDesc，只包含数据信息，它包含三部分：</p>
<ol>
<li>Mark Word，主要存储对象运行时记录信息，如hashcode, GC分代年龄，锁状态标志，线程ID，时间戳等; （64 位 os 就是 64 位即 8 字节）</li>
<li>元数据指针，即指向方法区的instanceKlass实例（压缩钱 8 字节，压缩后 4 字节） </li>
<li>实例数据; （成员变量）</li>
<li>另外，如果是数组对象，还多了一个数组长度</li>
</ol>
<hr>
<h3 id="对象如何定位"><a href="#对象如何定位" class="headerlink" title="对象如何定位"></a>对象如何定位</h3><h4 id="直接"><a href="#直接" class="headerlink" title="直接"></a>直接</h4><p>使用直接指针访问，Java堆中对象的内存布局就必须考虑如何防止访问类型数据的相关信息，<strong>reference中存储的直接就是对象地址</strong>，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p>
<p><img src="/..../pic/e5cb4bdae7764001aa4b980d8d7c9299.png" alt="在这里插入图片描述"></p>
<h4 id="间接（句柄访问）"><a href="#间接（句柄访问）" class="headerlink" title="间接（句柄访问）"></a>间接（句柄访问）</h4><p>使用句柄访问，Java堆中将可能会划分出一块<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>用来作为句柄池，reference中寸的就是对象的句柄地址，而<strong>句柄中包含了对象实例数据与类型数据各自具体的地址信息。</strong></p>
<p><img src="/../pic/ec9022edf4b64adca63c15a72bd0c738.png" alt="在这里插入图片描述"></p>
<h4 id="两种访问方式的优势"><a href="#两种访问方式的优势" class="headerlink" title="两种访问方式的优势"></a>两种访问方式的优势</h4><p>句柄访问： 最大的好处是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>指针访问：最大的好处时速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p>
<hr>
<h3 id="对象怎么分配"><a href="#对象怎么分配" class="headerlink" title="对象怎么分配"></a>对象怎么分配</h3><p><img src="/../pic/image-20240216111701776.png" alt="image-20240216111701776"></p>
<ol>
<li><p>判断分配到栈上。</p>
<p>逃逸分析。没有发生逃逸的对象优先尝试在栈上分配</p>
</li>
<li><p>是否大。</p>
<p>jvm 调优</p>
</li>
<li><p>TLAB。线程本地分配缓存</p>
<p>多线程时，给各线程分配特定的空间</p>
</li>
</ol>
<hr>
<h3 id="为什么-hotspot-不实用-c-对象来代表-java-对象"><a href="#为什么-hotspot-不实用-c-对象来代表-java-对象" class="headerlink" title="为什么 hotspot 不实用 c++对象来代表 java 对象"></a>为什么 hotspot 不实用 c++对象来代表 java 对象</h3><p>c++对象有虚函数表，java 对象的虚函数表在 Class 对象中</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h3><p><strong>可变性</strong></p>
<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> <u>对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</u>。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h3><p>被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code>不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<p><strong>不可变的好处</strong></p>
<p>这个最简单地原因，就是为了<strong>安全</strong>。</p>
<p>再看下面这个<strong>HashSet</strong>用StringBuilder做元素的场景，问题就更严重了，而且更隐蔽。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Test{</span><br><span class="line">    public static void main(String[] args){</span><br><span class="line">        HashSet&lt;StringBuilder&gt; hs=new HashSet&lt;StringBuilder&gt;();</span><br><span class="line">        StringBuilder sb1=new StringBuilder("aaa");</span><br><span class="line">        StringBuilder sb2=new StringBuilder("aaabbb");</span><br><span class="line">        hs.add(sb1);</span><br><span class="line">        hs.add(sb2);    //这时候HashSet里是{"aaa","aaabbb"}</span><br><span class="line"></span><br><span class="line">        StringBuilder sb3=sb1;</span><br><span class="line">        sb3.append("bbb");  //这时候HashSet里是{"aaabbb","aaabbb"}</span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//Output:</span><br><span class="line">//[aaabbb, aaabbb]</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=StringBuilder%E5%9E%8B%E5%8F%98%E9%87%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:114125846%7D">StringBuilder型变量</a>sb1和sb2分别指向了堆内的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%AD%97%E9%9D%A2%E9%87%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:114125846%7D">字面量</a>“aaa”和”aaabbb”。把他们都插入一个HashSet。到这一步没问题。但如果后面我把变量sb3也指向sb1的地址，再改变sb3的值，因为StringBuilder没有不可变性的保护，sb3直接在原先”aaa”的地址上改。导致sb1的值也变了。这时候，HashSet上就出现了两个相等的键值”aaabbb”。<strong>破坏了HashSet键值的唯一性</strong>。所以<strong>千万不要用可变类型做HashMap和HashSet键值。</strong></p>
<h3 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h3><p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>
<p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。</p>
<h3 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p>会创建 1 或 2 个字符串对象。</p>
<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，<strong>其中一个字符串对象的引用会被保存在字符串常量池中</strong>。</p>
<blockquote>
<p>示例代码（JDK 1.8）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>对应的字节码：</p>
<p><img src="/../pic/image-20220413175809959.png" alt="img"></p>
<p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p>
</blockquote>
<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<blockquote>
<p>示例代码（JDK 1.8）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串常量池中已存在字符串对象“abc”的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>对应的字节码：</p>
<p><img src="/../pic/image-20220413180021072.png" alt="img"></p>
<p>这里就不对上面的字节码进行详细注释了，7 这个位置的 <code>ldc</code> 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 <code>ldc</code> 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 <code>ldc</code> 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。</p>
</blockquote>
<h3 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="*String#intern 方法有什么作用?"></a>*String#intern 方法有什么作用?</h3><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，<u>那就在常量池</u><u>中创建一个指向该字符串对象的引用并返回</u>。</li>
</ul>
<blockquote>
<p>应用场景<br>使用方法</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Person{</span><br><span class="line">String name;</span><br><span class="line">	public void setName(String paramString)</span><br><span class="line">	{</span><br><span class="line">		String str = paramString.intern();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里是一个能展现出inern()实际作用的场景,首先假设我从数据库里读了一个人的信息出来,然后把这个人的名字赋值给这个Person对象.<br>那么,从数据库读数据,毫无疑问得创建一个字符串对象出来,假定读了10个人的数据,其中三个都叫小明,那么在不使用intern()的情况下,对字符串对象的引用情况如图所示</p>
<p><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjAzMzMx,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>在使用intern的情况下,对字符串对象的引用情况如图所示</p>
<p><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjAzMzMx,size_16,color_FFFFFF,t_70-20240219220012195.png" alt="在这里插入图片描述"></p>
<p>很显然,剩下的那两个小明字符串对象,就都可以回收了,大大节省空间.</p>
</blockquote>
<h3 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h3><ol>
<li><p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"str"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"ing"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">"str"</span> + <span class="string">"ing"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure>

<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。</p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = "str" + "ing";</code> 编译器会给你优化成 <code>String str3 = "string";</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"str"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">"ing"</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p>被 <code>final</code> 关键字修饰之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>
<p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">"str"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"ing"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code><strong>：<code>Error</code> 属于程序无法处理的错误 ，我们不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择</strong>线程终止</strong></li>
</ul>
<h3 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code>关键字处理的话，就没办法通过编译。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p>
<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
</ul>
<h3 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h3><ul>
<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>
<li><code>String toString()</code>: 返回异常发生时的详细信息</li>
<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a>try-catch-finally 如何使用？</h3><p> <code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</p>
<p><code>catch</code>块：用于处理 try 捕获到的异常。</p>
<p><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>
<p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">输出</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p>
<ol>
<li>finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<h3 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</p>
<p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p>
<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"D://read.txt"</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) {</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) {</span><br><span class="line">        scanner.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"test.txt"</span>))) {</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) {</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">catch</span> (FileNotFoundException fnfe) {</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">}a</span><br></pre></td></tr></tbody></table></figure>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"test.txt"</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"out.txt"</span>)))) {</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) {</span><br><span class="line">        bout.write(b);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h3><ul>
<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>
<li>抛出的异常信息一定要有意义。</li>
<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>
<li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li>
<li>……</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p><strong>泛型</strong>：是一种把<u>明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型</u>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，而这种参数类型可以用在<strong>类、方法和接口</strong>中，分别被称为<code>泛型类</code>、<code>泛型方法</code>、<code>泛型接口</code>。<br>注意:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
<h3 id="有什么作用？"><a href="#有什么作用？" class="headerlink" title="有什么作用？"></a>有什么作用？</h3><ul>
<li>避免了类型强转的麻烦。</li>
</ul>
<ul>
<li>它提供了编译期的<strong>类型安全</strong>，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。</li>
</ul>
<h3 id="泛型的使用方式有哪几种？"><a href="#泛型的使用方式有哪几种？" class="headerlink" title="泛型的使用方式有哪几种？"></a>泛型的使用方式有哪几种？</h3><ol>
<li><strong>泛型类</strong>：</li>
</ol>
<p>泛型类型用于类的定义中，被称为泛型类。最典型的就是各种集合框架容器类，如：List、Set、Map。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">泛型类的定义格式：</span><br><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; {  }</span><br><span class="line"></span><br><span class="line">怕你不清楚怎么使用，这里我还是做了一个简单的泛型类：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 这里解释下&lt;T&gt;中的T:</span></span><br><span class="line"><span class="comment"> *           此处的T可以随便写为任意标识，常见的有T、E等形式的参数表示泛型</span></span><br><span class="line"><span class="comment"> *           泛型在定义的时候不具体，使用的时候才变得具体。</span></span><br><span class="line"><span class="comment"> *           在使用的时候确定泛型的具体数据类型。即在创建对象的时候确定泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> {</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。即：在创建对象的时候确定泛型。</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><strong>泛型接口</strong>：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义格式</span><br><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; {  }</span><br><span class="line">public interface Generator&lt;T&gt; {</span><br><span class="line">    public T method();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><strong>泛型方法</strong>：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">定义格式：</span><br><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 传入泛型的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *   1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *   2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *   3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">genercMethod</span><span class="params">(T t)</span>{</span><br><span class="line">    System.out.println(t.getClass());</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">fanxing</span> <span class="variable">fanxing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">fanxing</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> fanxing.genercMethod(<span class="string">"string"</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> fanxing.genercMethod(<span class="number">123</span>);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><blockquote>
<p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tongpeifu</span><span class="params">(List&lt;?&gt; list)</span>{</span><br><span class="line">	<span class="comment">//只能用 Object 修饰，所以也只能用 Object 自带的方法</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">	tongpeifu(Arrays.asList(<span class="string">"1111"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>通配符基本使用</strong></p>
<p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ？代表可以接收任意类型</span></span><br><span class="line"><span class="comment">// 泛型不存在继承、多态关系,泛型左右两边要一样。jdk1.7后右边的泛型可以省略</span></span><br><span class="line"><span class="comment">//ArrayList&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型通配符?:左边写&lt;?&gt; 右边的泛型可以是任意类型</span></span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//编译错误 不可以存储数据</span></span><br><span class="line">list.add(<span class="string">"1111"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>泛型通配符?主要应用在参数传递方面</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    test(list1);</span><br><span class="line">    ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    test(list2);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ArrayList&lt;?&gt; coll)</span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>通配符高级使用</strong></p>
<p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement1(list1);</span><br><span class="line">    getElement1(list2);<span class="comment">//报错 </span></span><br><span class="line">    getElement1(list3);</span><br><span class="line">    getElement1(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>{}</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>{}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="何为反射"><a href="#何为反射" class="headerlink" title="何为反射"></a>何为反射</h3><p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，并调用这些方法和属性。</p>
<h3 id="反射的应用场景了解么？"><a href="#反射的应用场景了解么？" class="headerlink" title="反射的应用场景了解么？"></a>反射的应用场景了解么？</h3><p>Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h3 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h3><p><strong>优点</strong>：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p><strong>缺点</strong>：让我们在运行时有了分析操作类的能力，这同样也<strong>增加了安全问题</strong>。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的<strong>性能也要稍差点</strong>（编译器无法优化，无法使用 JIT），不过，对于框架来说实际是影响不大的。</p>
<h3 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h3><p>​	要想通过反射获取一个类的信息，首先要获取该类对应的Class类实例（Class 对象），Class类的实例代表了正在运行中的Java应用的类和接口。Class类没有公共的构造方法，Class类对象是在二进制字节流（一般是.class文件，也可通过网络或zip包等路径获取）被JVM加载时，通过调用类加载器的defineClass()方法来构建的。（译自Class类的JDK源码）</p>
<p>​	JVM在加载阶段要完成的3件事情中正好有Class对象的生成：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（.class字节码文件）。</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构（hotspot vm 中即InstanceKlass，即元数据）。</li>
<li>在内存（堆）中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h4 id="获取-Class-对象的四种方式"><a href="#获取-Class-对象的四种方式" class="headerlink" title="获取 Class 对象的四种方式"></a>获取 Class 对象的四种方式</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 知道具体类的情况下可以使用：</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 通过 Class.forName()传入类的全路径获取：</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 通过对象实例instance.getClass()获取：</span></span><br><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取:</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br><span class="line"><span class="comment">//通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="反射的一些基本操作"><a href="#反射的一些基本操作" class="headerlink" title="反射的一些基本操作"></a>反射的一些基本操作</h4><ol>
<li><p>创建一个我们要使用反射操作的类 <code>TargetObject</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> {</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetObject</span><span class="params">()</span> {</span><br><span class="line">        value = <span class="string">"JavaGuide"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">(String s)</span> {</span><br><span class="line">        System.out.println(<span class="string">"I love "</span> + s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"value is "</span> + value);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用反射操作这个类的方法以及参数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test_targetObject</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; targetObject = Class.forName(<span class="string">"TargetObject"</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> targetObject.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : targetObject.getDeclaredMethods()) {</span><br><span class="line">            System.out.println(declaredMethod);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">publicMethod</span> <span class="operator">=</span> targetObject.getDeclaredMethod(<span class="string">"publicMethod"</span>, String.class);</span><br><span class="line">        publicMethod.invoke(o, <span class="string">"fml"</span>);</span><br><span class="line">			</span><br><span class="line">        <span class="type">Field</span> <span class="variable">value</span> <span class="operator">=</span> targetObject.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        value.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        value.set(o, <span class="string">"fmlzuibang"</span>);</span><br><span class="line">				 <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> targetObject.getDeclaredMethod(<span class="string">"privateMethod"</span>);</span><br><span class="line">        privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        privateMethod.invoke(o);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="何谓注解"><a href="#何谓注解" class="headerlink" title="何谓注解"></a>何谓注解</h3><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override {</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
<h3 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="何谓-SPI"><a href="#何谓-SPI" class="headerlink" title="何谓 SPI?"></a>何谓 SPI?</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”。一种<code>服务发现机制</code>，允许在运行时动态地加载实现特定接口的类，而不需要在代码中显式地指定该类，从而实现<strong>解耦和灵活性</strong>。</p>
<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者<strong>解耦</strong>，能够提升程序的扩展性、可维护性。<strong>修改或者替换服务实现并不需要修改调用方。</strong></p>
<h3 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h3><p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p>
<p><img src="/../pic/1ebd1df862c34880bc26b9d494535b3dtplv-k3u1fbpfcp-watermark-20240214172511586.png" alt="img"></p>
<p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>
<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>
<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>
<h3 id="Java-SPI-的优缺点？"><a href="#Java-SPI-的优缺点？" class="headerlink" title="Java SPI 的优缺点？"></a>Java SPI 的优缺点？</h3><p>优点：</p>
<ul>
<li>松耦合度：在运行时动态加载实现类，而无需在编译时将实现类硬编码到代码中</li>
<li>扩展性：可以为同一个接口定义多个实现类。这使得应用程序更容易扩展和适应变化。</li>
</ul>
<p>缺点：</p>
<ul>
<li>安全性不足：SPI提供者必须将其实现类名称写入到配置文件中，因此如果未正确配置，则可能存在安全风险。</li>
<li>性能损失：每次查找服务提供者都需要重新读取配置文件，这可能会增加启动时间和内存开销。</li>
</ul>
<p>上面对Java SPI的缺点说了一下，我们来说一下：<br>Spring的SPI机制相对于Java原生的SPI机制进行了改造和扩展，主要体现在以下几个方面：</p>
<ul>
<li><p>支持多个实现类：Spring的SPI机制允许为同一个接口定义多个实现类，而Java原生的SPI机制只支持单个实现类。这使得在应用程序中使用Spring的SPI机制更加灵活和可扩展。</p>
</li>
<li><p>支持自动装配：Spring的SPI机制支持自动装配，可以通过将实现类标记为Spring组件（例如@Component），从而实现自动装配和依赖注入。这在一定程度上简化了应用程序中服务提供者的配置和管理。</p>
</li>
<li><p>支持动态替换：Spring的SPI机制支持动态替换服务提供者，可以通过修改配置文件或者其他方式来切换服务提供者。而Java原生的SPI机制只能在启动时加载一次服务提供者，并且无法在运行时动态替换。</p>
</li>
<li><p>提供了更多扩展点：Spring的SPI机制提供了很多扩展点，例如BeanPostProcessor、BeanFactoryPostProcessor等，可以在服务提供者初始化和创建过程中进行自定义操作。</p>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>Java SPI</code>机制是一种服务提供者发现的机制，适用于需要在多个实现中选择一个进行使用的场景。</p>
<p>常见的应用场景包括：</p>
<table>
<thead>
<tr>
<th><strong>应用名称</strong></th>
<th>具体应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>数据库驱动程序加载</td>
<td><code>JDBC</code>为了实现<code>可插拔</code>的数据库驱动，在Java.sql.Driver接口中定义了一组标准的API规范，而具体的数据库厂商则需要实现这个接口，以提供自己的数据库驱动程序。在Java中，JDBC驱动程序的加载就是通过SPI机制实现的。</td>
</tr>
<tr>
<td>日志框架的实现</td>
<td>流行的<code>开源日志框架</code>，如<code>Log4j、SLF4J和Logback</code>等，都采用了SPI机制。用户可以根据自己的需求选择合适的日志实现，而不需要修改代码。</td>
</tr>
<tr>
<td>Spring框架</td>
<td><code>Spring框架</code>中的Bean加载机制就使用了SPI思想，通过读取classpath下的META-INF/spring.factories文件来<code>加载各种自定义的Bean</code>。</td>
</tr>
<tr>
<td>Dubbo框架</td>
<td><code>Dubbo框架</code>也使用了SPI思想，通过接口<code>注解@SPI</code>声明扩展点接口，并在classpath下的META-INF/dubbo目录中提供实现类的配置文件，来实现扩展点的动态加载。</td>
</tr>
</tbody></table>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52423918/article/details/130968307">https://blog.csdn.net/qq_52423918/article/details/130968307</a></p>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><h3 id="什么是序列化-什么是反序列化"><a href="#什么是序列化-什么是反序列化" class="headerlink" title="什么是序列化?什么是反序列化?"></a>什么是序列化?什么是反序列化?</h3><ul>
<li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过</li>
</ul>
<p><strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<p><strong>序列化协议对应于 TCP/IP 4 层模型的哪一层？</strong></p>
<p>应用层（表示层）</p>
<h3 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a>如果有些字段不想进行序列化怎么办？</h3><p>使用 <code>transient</code> 关键字修饰</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h3 id="JDK-自带的序列化方式"><a href="#JDK-自带的序列化方式" class="headerlink" title="JDK 自带的序列化方式"></a>JDK 自带的序列化方式</h3><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p>
<h4 id="serialVersionUID-有什么作用？"><a href="#serialVersionUID-有什么作用？" class="headerlink" title="serialVersionUID 有什么作用？"></a><strong>serialVersionUID 有什么作用？</strong></h4><p>序列化号 <code>serialVersionUID</code> 属于版本控制的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code></p>
<h4 id="serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？"><a href="#serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？" class="headerlink" title="serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？"></a><strong>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</strong></h4><p><code>static</code> 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。但是，<code>serialVersionUID</code> 的序列化做了特殊处理，在序列化时，会将 <code>serialVersionUID</code> 序列化到二进制字节流中；在反序列化时，也会解析它并做一致性判断。</p>
<h3 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a>为什么不推荐使用 JDK 自带的序列化？</h3><ul>
<li><strong>性能差</strong></li>
<li><strong>存在安全问题</strong></li>
<li><strong>不支持跨语言调用</strong></li>
</ul>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="Java-IO-流了解吗？"><a href="#Java-IO-流了解吗？" class="headerlink" title="Java IO 流了解吗？"></a>Java IO 流了解吗？</h3><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="I-O-流为什么要分为字节流和字符流呢"><a href="#I-O-流为什么要分为字节流和字符流呢" class="headerlink" title="I/O 流为什么要分为字节流和字符流呢?"></a>I/O 流为什么要分为字节流和字符流呢?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时（字节流优势）；</li>
<li>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题（字符流优势）。</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>一种设计模式：<strong>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，扩展目标对象的功能。（</strong>比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。<strong>）</strong></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul>
<li><p>实现和应用角度：</p>
<p>​	对目标对象的每个方法的增强都是手动完成的，非常<strong>不灵活</strong>（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且<strong>麻烦</strong>(需要对每个目标类都单独写一个代理类）</p>
</li>
<li><p>JVM 层面：</p>
<p>​	 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>
</li>
</ul>
<p><strong>静态代理实现步骤</strong>:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h4><p>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li><p>定义一个接口及其实现类；</p>
</li>
<li><p>定义一个实现 <code>InvocationHandler</code> 并重写<code>invoke</code>方法的类，在 <code>invoke</code> 方法中会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**loader :类加载器，用于加载代理对象。</span></span><br><span class="line"><span class="comment">* interfaces : 被代理类实现的一些接口；</span></span><br><span class="line"><span class="comment">* h : 实现了 InvocationHandler 接口的对象；</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException{</span><br><span class="line">	......</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h4><p>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code>类是核心。</p>
<p><strong>使用步骤</strong></p>
<ol>
<li><p>定义一个类；</p>
</li>
<li><p>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code>用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"before method "</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">"after method "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> {</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h4><ol>
<li>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</li>
<li>CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀</li>
</ol>
<h3 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h3><ol>
<li><strong>灵活性</strong>：动态代理更加灵活，不需要<strong>必须实现接口</strong>（静态代理、jdk 动态代理），可以直接代理实现类(CGLIB)，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong>：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
</body></html></div><div class="article-licensing box"><div class="licensing-title"><p>Java基础</p><p><a href="https://jerryzhu1229.github.io/2024/03/12/Java基础/">https://jerryzhu1229.github.io/2024/03/12/Java基础/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jerry Z</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-03-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/03/12/%E9%9B%86%E5%90%88/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">集合</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-item">计算机网络</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础概念"><span class="level-left"><span class="level-item">1</span><span class="level-item">基础概念</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#JVM-vs-JDK-vs-JRE"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">JVM vs JDK vs JRE</span></span></a></li><li><a class="level is-mobile" href="#什么是字节码-采用字节码的好处是什么"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">什么是字节码?采用字节码的好处是什么?</span></span></a></li><li><a class="level is-mobile" href="#为什么说-Java-语言“编译与解释并存”？"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">为什么说 Java 语言“编译与解释并存”？</span></span></a></li><li><a class="level is-mobile" href="#AOT-有什么优点？为什么不全部使用-AOT-呢？"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">AOT 有什么优点？为什么不全部使用 AOT 呢？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#基本数据类型"><span class="level-left"><span class="level-item">2</span><span class="level-item">基本数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本类型和包装类型的区别？"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">基本类型和包装类型的区别？</span></span></a></li><li><a class="level is-mobile" href="#为什么说是几乎所有对象实例都存在于堆中呢？"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">为什么说是几乎所有对象实例都存在于堆中呢？</span></span></a></li><li><a class="level is-mobile" href="#基本数据类型是否都存放在栈中？"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">基本数据类型是否都存放在栈中？</span></span></a></li><li><a class="level is-mobile" href="#包装类型的缓存机制了解么？"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">包装类型的缓存机制了解么？</span></span></a></li><li><a class="level is-mobile" href="#自动装箱与拆箱了解吗？原理是什么？"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">自动装箱与拆箱了解吗？原理是什么？</span></span></a></li><li><a class="level is-mobile" href="#为什么浮点数运算的时候会有精度丢失的风险？"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">为什么浮点数运算的时候会有精度丢失的风险？</span></span></a></li><li><a class="level is-mobile" href="#浮点型从二进制的视角是怎么存储的？"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">浮点型从二进制的视角是怎么存储的？</span></span></a></li><li><a class="level is-mobile" href="#（IEEE-754）小数位如何计算出来的？"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">（IEEE 754）小数位如何计算出来的？</span></span></a></li><li><a class="level is-mobile" href="#如何解决浮点数运算的精度丢失问题？"><span class="level-left"><span class="level-item">2.9</span><span class="level-item">如何解决浮点数运算的精度丢失问题？</span></span></a></li><li><a class="level is-mobile" href="#超过-long-整型的数据应该如何表示？"><span class="level-left"><span class="level-item">2.10</span><span class="level-item">超过 long 整型的数据应该如何表示？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#变量"><span class="level-left"><span class="level-item">3</span><span class="level-item">变量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#成员变量与局部变量的区别？"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">成员变量与局部变量的区别？</span></span></a></li><li><a class="level is-mobile" href="#为什么成员变量有默认值？"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">为什么成员变量有默认值？</span></span></a></li><li><a class="level is-mobile" href="#静态变量有什么作用？"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">静态变量有什么作用？</span></span></a></li><li><a class="level is-mobile" href="#字符型常量和字符串常量的区别"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">字符型常量和字符串常量的区别?</span></span></a></li></ul></li><li><a class="level is-mobile" href="#方法"><span class="level-left"><span class="level-item">4</span><span class="level-item">方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#静态方法为什么不能调用非静态成员"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">静态方法为什么不能调用非静态成员?</span></span></a></li><li><a class="level is-mobile" href="#静态方法和实例方法有何不同？"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">静态方法和实例方法有何不同？</span></span></a></li><li><a class="level is-mobile" href="#重载和重写有什么区别？"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">重载和重写有什么区别？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#面相对象基础"><span class="level-left"><span class="level-item">5</span><span class="level-item">面相对象基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#面向对象和面向过程的区别"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">面向对象和面向过程的区别</span></span></a></li><li><a class="level is-mobile" href="#对象的相等和引用相等的区别"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">对象的相等和引用相等的区别</span></span></a></li><li><a class="level is-mobile" href="#如果一个类没有声明构造方法，该程序能正确执行吗"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">如果一个类没有声明构造方法，该程序能正确执行吗?</span></span></a></li><li><a class="level is-mobile" href="#构造方法有哪些特点？是否可被-override"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">构造方法有哪些特点？是否可被 override?</span></span></a></li><li><a class="level is-mobile" href="#面向对象三大特征"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">面向对象三大特征</span></span></a></li><li><a class="level is-mobile" href="#接口和抽象类有什么共同点和区别？"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">*接口和抽象类有什么共同点和区别？</span></span></a></li><li><a class="level is-mobile" href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Object"><span class="level-left"><span class="level-item">6</span><span class="level-item">Object</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Object-类的常见方法有哪些？"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Object 类的常见方法有哪些？</span></span></a></li><li><a class="level is-mobile" href="#和-equals-的区别"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">== 和 equals() 的区别</span></span></a></li><li><a class="level is-mobile" href="#hashCode-有什么用？"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">hashCode() 有什么用？</span></span></a></li><li><a class="level is-mobile" href="#为什么要有-hashCode？"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">为什么要有 hashCode？</span></span></a></li><li><a class="level is-mobile" href="#为什么重写-equals-时必须重写-hashCode-方法？"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">为什么重写 equals() 时必须重写 hashCode() 方法？</span></span></a></li><li><a class="level is-mobile" href="#概念"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">概念</span></span></a></li><li><a class="level is-mobile" href="#对象的创建过程"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">对象的创建过程</span></span></a></li><li><a class="level is-mobile" href="#单例模式"><span class="level-left"><span class="level-item">6.8</span><span class="level-item">单例模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#饿汉式"><span class="level-left"><span class="level-item">6.8.1</span><span class="level-item">饿汉式</span></span></a></li><li><a class="level is-mobile" href="#懒汉式"><span class="level-left"><span class="level-item">6.8.2</span><span class="level-item">懒汉式</span></span></a></li><li><a class="level is-mobile" href="#双重检查锁（DCL-double-check-lock）"><span class="level-left"><span class="level-item">6.8.3</span><span class="level-item">双重检查锁（DCL double check lock）</span></span></a></li><li><a class="level is-mobile" href="#静态内部类形式"><span class="level-left"><span class="level-item">6.8.4</span><span class="level-item">静态内部类形式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#java中的引用类型的对象存放在哪里"><span class="level-left"><span class="level-item">6.9</span><span class="level-item">java中的引用类型的对象存放在哪里</span></span></a></li><li><a class="level is-mobile" href="#Class-实例究竟在-method-area-还是在-heap"><span class="level-left"><span class="level-item">6.10</span><span class="level-item">Class 实例究竟在 method area 还是在 heap</span></span></a></li><li><a class="level is-mobile" href="#对象在内存中的存储布局"><span class="level-left"><span class="level-item">6.11</span><span class="level-item">对象在内存中的存储布局</span></span></a></li><li><a class="level is-mobile" href="#对象如何定位"><span class="level-left"><span class="level-item">6.12</span><span class="level-item">对象如何定位</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#直接"><span class="level-left"><span class="level-item">6.12.1</span><span class="level-item">直接</span></span></a></li><li><a class="level is-mobile" href="#间接（句柄访问）"><span class="level-left"><span class="level-item">6.12.2</span><span class="level-item">间接（句柄访问）</span></span></a></li><li><a class="level is-mobile" href="#两种访问方式的优势"><span class="level-left"><span class="level-item">6.12.3</span><span class="level-item">两种访问方式的优势</span></span></a></li></ul></li><li><a class="level is-mobile" href="#对象怎么分配"><span class="level-left"><span class="level-item">6.13</span><span class="level-item">对象怎么分配</span></span></a></li><li><a class="level is-mobile" href="#为什么-hotspot-不实用-c-对象来代表-java-对象"><span class="level-left"><span class="level-item">6.14</span><span class="level-item">为什么 hotspot 不实用 c++对象来代表 java 对象</span></span></a></li></ul></li><li><a class="level is-mobile" href="#String"><span class="level-left"><span class="level-item">7</span><span class="level-item">String</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#String、StringBuffer、StringBuilder-的区别？"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">String、StringBuffer、StringBuilder 的区别？</span></span></a></li><li><a class="level is-mobile" href="#String-为什么是不可变的"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">String 为什么是不可变的?</span></span></a></li><li><a class="level is-mobile" href="#字符串拼接用“-”-还是-StringBuilder"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">字符串拼接用“+” 还是 StringBuilder?</span></span></a></li><li><a class="level is-mobile" href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">String s1 = new String(“abc”);这句话创建了几个字符串对象？</span></span></a></li><li><a class="level is-mobile" href="#String-intern-方法有什么作用"><span class="level-left"><span class="level-item">7.5</span><span class="level-item">*String#intern 方法有什么作用?</span></span></a></li><li><a class="level is-mobile" href="#String-类型的变量和常量做“-”运算时发生了什么？"><span class="level-left"><span class="level-item">7.6</span><span class="level-item">String 类型的变量和常量做“+”运算时发生了什么？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#异常"><span class="level-left"><span class="level-item">8</span><span class="level-item">异常</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Exception-和-Error-有什么区别？"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">Exception 和 Error 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#Checked-Exception-和-Unchecked-Exception-有什么区别？"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">Checked Exception 和 Unchecked Exception 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#Throwable-类常用方法有哪些？"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">Throwable 类常用方法有哪些？</span></span></a></li><li><a class="level is-mobile" href="#try-catch-finally-如何使用？"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">try-catch-finally 如何使用？</span></span></a></li><li><a class="level is-mobile" href="#finally-中的代码一定会执行吗？"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">finally 中的代码一定会执行吗？</span></span></a></li><li><a class="level is-mobile" href="#如何使用-try-with-resources-代替try-catch-finally？"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">如何使用 try-with-resources 代替try-catch-finally？</span></span></a></li><li><a class="level is-mobile" href="#异常使用有哪些需要注意的地方？"><span class="level-left"><span class="level-item">8.7</span><span class="level-item">异常使用有哪些需要注意的地方？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#泛型"><span class="level-left"><span class="level-item">9</span><span class="level-item">泛型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是泛型？"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">什么是泛型？</span></span></a></li><li><a class="level is-mobile" href="#有什么作用？"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">有什么作用？</span></span></a></li><li><a class="level is-mobile" href="#泛型的使用方式有哪几种？"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">泛型的使用方式有哪几种？</span></span></a></li><li><a class="level is-mobile" href="#泛型通配符"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">泛型通配符</span></span></a></li></ul></li><li><a class="level is-mobile" href="#反射"><span class="level-left"><span class="level-item">10</span><span class="level-item">反射</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#何为反射"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">何为反射</span></span></a></li><li><a class="level is-mobile" href="#反射的应用场景了解么？"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">反射的应用场景了解么？</span></span></a></li><li><a class="level is-mobile" href="#反射机制的优缺点"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">反射机制的优缺点</span></span></a></li><li><a class="level is-mobile" href="#反射原理"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">反射原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#获取-Class-对象的四种方式"><span class="level-left"><span class="level-item">10.4.1</span><span class="level-item">获取 Class 对象的四种方式</span></span></a></li><li><a class="level is-mobile" href="#反射的一些基本操作"><span class="level-left"><span class="level-item">10.4.2</span><span class="level-item">反射的一些基本操作</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#注解"><span class="level-left"><span class="level-item">11</span><span class="level-item">注解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#何谓注解"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">何谓注解</span></span></a></li><li><a class="level is-mobile" href="#注解的解析方法有哪几种？"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">注解的解析方法有哪几种？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SPI"><span class="level-left"><span class="level-item">12</span><span class="level-item">SPI</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#何谓-SPI"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">何谓 SPI?</span></span></a></li><li><a class="level is-mobile" href="#SPI-和-API-有什么区别？"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">SPI 和 API 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#Java-SPI-的优缺点？"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">Java SPI 的优缺点？</span></span></a></li><li><a class="level is-mobile" href="#应用场景"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">应用场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#序列化和反序列化"><span class="level-left"><span class="level-item">13</span><span class="level-item">序列化和反序列化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是序列化-什么是反序列化"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">什么是序列化?什么是反序列化?</span></span></a></li><li><a class="level is-mobile" href="#如果有些字段不想进行序列化怎么办？"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">如果有些字段不想进行序列化怎么办？</span></span></a></li><li><a class="level is-mobile" href="#JDK-自带的序列化方式"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">JDK 自带的序列化方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#serialVersionUID-有什么作用？"><span class="level-left"><span class="level-item">13.3.1</span><span class="level-item">serialVersionUID 有什么作用？</span></span></a></li><li><a class="level is-mobile" href="#serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？"><span class="level-left"><span class="level-item">13.3.2</span><span class="level-item">serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#为什么不推荐使用-JDK-自带的序列化？"><span class="level-left"><span class="level-item">13.4</span><span class="level-item">为什么不推荐使用 JDK 自带的序列化？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#I-O"><span class="level-left"><span class="level-item">14</span><span class="level-item">I/O</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Java-IO-流了解吗？"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">Java IO 流了解吗？</span></span></a></li><li><a class="level is-mobile" href="#I-O-流为什么要分为字节流和字符流呢"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">I/O 流为什么要分为字节流和字符流呢?</span></span></a></li></ul></li><li><a class="level is-mobile" href="#代理模式"><span class="level-left"><span class="level-item">15</span><span class="level-item">代理模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#静态代理"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">静态代理</span></span></a></li><li><a class="level is-mobile" href="#动态代理"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">动态代理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#JDK-动态代理机制"><span class="level-left"><span class="level-item">15.2.1</span><span class="level-item">JDK 动态代理机制</span></span></a></li><li><a class="level is-mobile" href="#CGLIB-动态代理机制"><span class="level-left"><span class="level-item">15.2.2</span><span class="level-item">CGLIB 动态代理机制</span></span></a></li><li><a class="level is-mobile" href="#JDK-动态代理和-CGLIB-动态代理对比"><span class="level-left"><span class="level-item">15.2.3</span><span class="level-item">JDK 动态代理和 CGLIB 动态代理对比</span></span></a></li></ul></li><li><a class="level is-mobile" href="#静态代理和动态代理的对比"><span class="level-left"><span class="level-item">15.3</span><span class="level-item">静态代理和动态代理的对比</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/cs/"><span class="level-start"><span class="level-item">cs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a><p class="is-size-7"><span>&copy; 2024 Jerry Z</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>