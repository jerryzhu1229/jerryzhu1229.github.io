<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MySQL - hao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="hao"><meta name="msapplication-TileImage" content="/img/2751710164138_.pic.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="hao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="hao"><meta property="og:url" content="https://jerryzhu1229.github.io/2024/03/12/MySQL/"><meta property="og:site_name" content="hao"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center-20240315213232594.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center-20240315221648863.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center-20240315221737005.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center-20240315221810273.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70-20240330214648097.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/d37bfa1678eb71ae7e33dc8f211d1ec1.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/cce766a69dea725cd8f19b90db2d0430.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/4e98ea2e60923b969790898565b4d643.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/readview%E7%BB%93%E6%9E%84.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/f595d13450878acd04affa82731f76c5.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/a463e5d8f8493c4696716e44e96748af-20240324212007851.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/ReadView.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/x%E9%94%81%E5%92%8Cs%E9%94%81.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E15.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E6.drawio-20240331091327727.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/90c1e01d0345de639e3426cea0390e80.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E5%AD%97%E8%8A%82mysql%E9%9D%A2%E8%AF%95%E9%A2%98.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/wal.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/innodb_flush_log_at_trx_commit.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/innodb_flush_log_at_trx_commit2.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/checkpoint.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/binlogcache.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/mybatis-y-arch-4.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/fb8f06d7d8c544c8a9bf1885c44bf3be.png"><meta property="article:published_time" content="2024-03-12T01:59:08.000Z"><meta property="article:modified_time" content="2024-04-09T10:33:31.144Z"><meta property="article:author" content="Jerry Z"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jerryzhu1229.github.io/pic/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerryzhu1229.github.io/2024/03/12/MySQL/"},"headline":"MySQL","image":["https://jerryzhu1229.github.io/pic/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png","https://jerryzhu1229.github.io/pic/Center.png","https://jerryzhu1229.github.io/pic/Center-20240315213232594.png","https://jerryzhu1229.github.io/pic/Center-20240315221648863.png","https://jerryzhu1229.github.io/pic/Center-20240315221737005.png","https://jerryzhu1229.github.io/pic/Center-20240315221810273.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70-20240330214648097.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70.png","https://jerryzhu1229.github.io/pic/d37bfa1678eb71ae7e33dc8f211d1ec1.png","https://jerryzhu1229.github.io/pic/cce766a69dea725cd8f19b90db2d0430.png","https://jerryzhu1229.github.io/pic/4e98ea2e60923b969790898565b4d643.png","https://jerryzhu1229.github.io/pic/readview%E7%BB%93%E6%9E%84.drawio.png","https://jerryzhu1229.github.io/pic/f595d13450878acd04affa82731f76c5.png","https://jerryzhu1229.github.io/pic/a463e5d8f8493c4696716e44e96748af-20240324212007851.png","https://jerryzhu1229.github.io/pic/ReadView.drawio.png","https://jerryzhu1229.github.io/pic/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png","https://jerryzhu1229.github.io/pic/x%E9%94%81%E5%92%8Cs%E9%94%81.png","https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png","https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png","https://jerryzhu1229.github.io/pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E15.drawio.png","https://jerryzhu1229.github.io/pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E6.drawio-20240331091327727.png","https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png","https://jerryzhu1229.github.io/pic/90c1e01d0345de639e3426cea0390e80.png","https://jerryzhu1229.github.io/pic/%E5%AD%97%E8%8A%82mysql%E9%9D%A2%E8%AF%95%E9%A2%98.png","https://jerryzhu1229.github.io/pic/wal.png","https://jerryzhu1229.github.io/pic/innodb_flush_log_at_trx_commit.drawio.png","https://jerryzhu1229.github.io/pic/innodb_flush_log_at_trx_commit2.drawio.png","https://jerryzhu1229.github.io/pic/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png","https://jerryzhu1229.github.io/pic/checkpoint.png","https://jerryzhu1229.github.io/pic/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png","https://jerryzhu1229.github.io/pic/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png","https://jerryzhu1229.github.io/pic/binlogcache.drawio.png","https://jerryzhu1229.github.io/pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png","https://jerryzhu1229.github.io/pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png","https://jerryzhu1229.github.io/pic/mybatis-y-arch-4.png","https://jerryzhu1229.github.io/pic/fb8f06d7d8c544c8a9bf1885c44bf3be.png"],"datePublished":"2024-03-12T01:59:08.000Z","dateModified":"2024-04-09T10:33:31.144Z","author":{"@type":"Person","name":"Jerry Z"},"publisher":{"@type":"Organization","name":"hao","logo":{"@type":"ImageObject","url":"https://jerryzhu1229.github.io/img/2751710164138_.pic.jpg"}},"description":""}</script><link rel="canonical" href="https://jerryzhu1229.github.io/2024/03/12/MySQL/"><link rel="icon" href="/img/2751710164138_.pic.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/cs">计算机基础</a><a class="navbar-item" href="/categories/java">后端开发</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jerryzhu1229"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-12T01:59:08.000Z" title="2024/3/12 09:59:08">2024-03-12</time>发表</span><span class="level-item"><time dateTime="2024-04-09T10:33:31.144Z" title="2024/4/9 18:33:31">2024-04-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">2 小时读完 (大约20037个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MySQL</h1><div class="content"><html><head></head><body><h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><h2 id="慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。"><a href="#慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。" class="headerlink" title="慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。"></a>慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。</h2><p>原因</p>
<ol>
<li>索引失效</li>
<li>连接查询没有用到索引，执行了笛卡尔查询</li>
<li>大数据量排序与分组</li>
<li>复杂的子查询</li>
<li>表结构设计问题</li>
<li>事务锁竞争</li>
</ol>
<p>定位</p>
<ol>
<li>慢查询日志。MySQL的慢查询日志会记录执行时间超过long_query_time 的SQL语句</li>
<li>show processlist。实时展示当前MySQL正在执行的线程,可以通过processlist来发现一些状态显示为Lock等的慢查询。</li>
</ol>
<p>优化</p>
<ol>
<li>加索引</li>
<li>SQL 语句优化。去除无效查询条件,优化Join查询,避免全表扫描等。</li>
<li>优化表结构。去除冗余字段,拆分过大的表,适当垂直拆分或者水平拆分表。</li>
<li>使用视图。将复杂查询封装为视图,以简化查询过程。</li>
<li>加缓存优化数据统计类的慢查询</li>
<li>部署读写分离架构,主库负责写,从库负责读,分散数据库压力。</li>
</ol>
<h2 id="使用-explain-优化你的-mysql-性能"><a href="#使用-explain-优化你的-mysql-性能" class="headerlink" title="使用 explain 优化你的 mysql 性能"></a>使用 explain 优化你的 mysql 性能</h2><h3 id="Explain-特点"><a href="#Explain-特点" class="headerlink" title="Explain 特点"></a>Explain 特点</h3><ul>
<li>explain 返回的结果是以表为粒度的，每个表输出一行，这里的表示广义上的表，可以是一个子查询，也可以是一个 UNION 后的结果。</li>
<li>explain 只能解析 Select 查询，对于 update，insert 等都不支持，我们可以使用 select 来模拟 update 操作近似获取 update 的执行过程</li>
</ul>
<h3 id="Explain-中的列"><a href="#Explain-中的列" class="headerlink" title="Explain 中的列"></a>Explain 中的列</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p>
<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>select_type 表示了查询的类型, 它的常用取值有:</p>
<ul>
<li>SIMPLE：表示此查询不包含 UNION 查询或子查询</li>
<li>SUBQUERY：包含在 Select 列表中的子查询，也就是不在 FROM 子句中的子查询</li>
<li>DERIVED：表示包含在 From 子句中的 Select 查询</li>
<li>UNION：表示此查询是 UNION 的第二和随后的查询</li>
<li>UNION RESULT： 从 UNION 匿名临时表检索结果的 SELECT </li>
<li>PRIMARY, 表示此查询是最外层的查询</li>
<li>DEPENDENT UNION： UNION 中的第二个或后面的查询语句, DEPENDENT 意味着 Select 依赖于外层查询中发现的数据</li>
<li>DEPENDENT SUBQUERY: 包含在 Select 列表中的子查询， 但子查询依赖于外层查询的结果.</li>
</ul>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>查询的是哪个表，mysql 查询优化器执行的关联顺序并不和我们写 SQL 时关联的顺序一致，下面我们讲一下 Mysql 是如何对关联查询作优化的：</p>
<ul>
<li>Mysql 查询执行计划总是按照左侧深度优先树的规则去执行，也就是从一个表开始一直嵌套循环，并不会类似平衡二叉树一样两个分支同时执行</li>
<li>在多表关联时，可以通过多种不同的关联顺序获取相同的执行结果，查询优化器会评估不同的顺序选择一个代价最小的关联查询</li>
<li>如果你不想要优化器改变你的关联顺序，可以使用 STRAIGHT JOIN 关键字强制使用你的关联顺序去执行</li>
<li>如果关联表特别多时，超过 optimizer_search_depth 的限制时，优化器评估每一种关联顺序的执行成本太高，这时会选择“贪婪”的搜索模式</li>
</ul>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是全表扫描还是索引扫描等，type 类型的性能比较，通常来说, 不同的 type 类型的性能关系如下:</p>
<p>ALL &lt; index &lt; range &lt; ref &lt; eq_ref &lt; const &lt; system &lt; NULL</p>
<ul>
<li>NULL：这种访问意味着 Mysql 能在优化阶段分解查询语句，在执行阶段不需要访问表或者索引</li>
<li>system: 预先知道整个表中只有一条数据. 这个类型是特殊的 const 类型</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 因为表中backend_user是主键，所以子查询里最多可以选出一条数据，所以最外层查询的type是system，里层查询的type是const</span><br><span class="line">explain select * from (select * from backend_user where id = 1) a;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>const：针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可</li>
<li>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高.</li>
<li>ref：此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询，可能会查询出多个值</li>
<li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。但是对于同样的 type = range 的查询，性能上还是有区别的：</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 虽然是都是范围查询，其实第二个查询时多个等值条件查询</span><br><span class="line"># 对于第一个查询，mysql 无法再使用该列后面的其它查询索引了，而第二个则可以继续使用索引</span><br><span class="line">select id from actor where id &gt; 45 and class_id = 3;</span><br><span class="line">select id from actor where id in (44, 47, 48) and class_id = 3;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>index: 表示通过索引进行全表扫描和 ALL 类型类似, 有点是避免了排序，确定是需要承担按照索引次序读取表的开销。如果 Extra 列中出现了 “Using index” 表明是用了覆盖索引，此时开销非常小。</li>
<li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一。一般情况下都会从头到尾扫描所有行，除非使用了 Limit 或者 Extra 列中显示 “Using distinct/not exists”。</li>
</ul>
<h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>此次查询中可能选用的索引，这些索引列是根据查询的列以及比较操作符来判断的，可能在后续的真实查询中没有用到也有可能</p>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>此次查询中确切使用到的索引，如果在 possible_keys 中没有出现而在 key 中出现，说明优化器可能出于另外原因比如选择覆盖索引，所以 possiable_keys 揭示了哪一个索引有助于高效进行查找，而 key 显示了采用哪一个索引可以最小化查询成本。</p>
<h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到，比如我们建了一个组合索引(col1, col2)，那么如下两条查询虽然用到的都是这个组合索引，但是对应的key_len的只是不一样的。key_len 显示了在索引字段中可能的最大长度，而不是数据使用的实际字节数</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table1 where col1 = 1;</span><br><span class="line">select * from table1 where col1 = 1 and col2 = 2;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>这一列显示了之前的表在 key 列记录的索引中查找值所用的列或者常量</p>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数。这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。</p>
<ul>
<li>通过把每个表的 rows 值相乘可以粗略的估算出整个查询要检查的行数</li>
<li>这个值只是一个估算的值，不是实际查出来的值</li>
</ul>
<h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h4><p>filtered 是在 MYSQL 5.1 中加进来的，在使用 EXPLAIN EXTENDED 时出现，表示此查询条件所过滤的数据的百分比，将 rows 除以 filtered 可以估算出整个表数据行数。</p>
<h4 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h4><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>
<ul>
<li>Using filesort</li>
</ul>
<p>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大。 但是 Explain 不会告诉你 Mysql 将使用文件排序还是内存排序：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 比如我们建立索引为：KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)，那么如下两个查询</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM order_info ORDER BY product_name；    -- Using filesort，不能通过索引进行排序，需要优化</span><br><span class="line">EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name；-- 无 Using filesort，通过索引进行排序，优化成功</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>Using index</li>
</ul>
<p>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p>
<ul>
<li>Using where</li>
</ul>
<p>这意味着 Mysql 服务器在存储引擎检索行后再进行过滤，一般出现 “Using where” 会受益于不同的索引</p>
<ul>
<li>Using temporary</li>
</ul>
<p>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 临时表可能是内存临时表或者文件临时表</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="执行一条-SQL-查询语句，期间发生了什么？"><a href="#执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="执行一条 SQL 查询语句，期间发生了什么？"></a>执行一条 SQL 查询语句，期间发生了什么？</h2><ul>
<li><p>连接器：建立连接、管理链接、校验个人身份</p>
</li>
<li><p>查询缓存：key-value形式——查询语句是否命中</p>
</li>
<li><p>解析器：词法解析、语法解析，建立语法树</p>
</li>
<li><p>执行 SQL：</p>
<ul>
<li>预处理阶段：判断是否存在表面、字段名；将*替换成全部列</li>
<li>优化阶段：基于查询成本，选择最佳的执行计划</li>
<li>执行阶段：根据执行计划执行 SQL查询语句，从存储引擎读取记录，返回给客户端</li>
</ul>
</li>
</ul>
<p><img src="/../pic/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p>
<h2 id="MySQL-一行记录是怎么存储的？"><a href="#MySQL-一行记录是怎么存储的？" class="headerlink" title="MySQL 一行记录是怎么存储的？"></a>MySQL 一行记录是怎么存储的？</h2><blockquote>
<p>MySQL 的 NULL 值是怎么存放的？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p>
<p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p>
<blockquote>
<p>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p>
<blockquote>
<p>varchar(n) 中 n 最大取值为多少？</p>
</blockquote>
<p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p>
<p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p>
<p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。</p>
<p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535。</p>
<blockquote>
<p>行溢出后，MySQL 是怎么处理的？</p>
</blockquote>
<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p>
<p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p>
<p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p>
<h2 id="为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？"></a>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h2><p><em><strong>1、B+Tree vs B Tree</strong></em></p>
<p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的<strong>磁盘 I/O 次数</strong>下，就能查询更多的节点。</p>
<p>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的<strong>顺序查找</strong>，而 B 树无法做到这一点。</p>
<p>B+ 树<strong>有大量的冗余节点</strong>（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</p>
<p><em><strong>2、B+Tree vs 二叉树</strong></em></p>
<p>对于有 N 个叶子节点的 B+Tree，其<strong>搜索复杂度</strong>为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p>
<p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I/O 操作就能查询到目标数据。根节点可以包含的关键字数量范围是 [2, m-1]。 非根节点至少包含m/2个关键字，至多包含m-1个关键字。</p>
<p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的<strong>磁盘 I/O 次数要更多</strong>。</p>
<p><em><strong>3、B+Tree vs Hash</strong></em></p>
<p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p>
<p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p>
<h2 id="多表查询（各种join连接详解）"><a href="#多表查询（各种join连接详解）" class="headerlink" title="多表查询（各种join连接详解）"></a>多表查询（各种join连接详解）</h2><p><strong>A）内连接：join=inner join</strong></p>
<p><strong>B）外连接：left join=left outer join，right join=right outer join，union</strong></p>
<p><strong>C）交叉连接：cross join</strong></p>
<p><strong>2.1 内连接（只有一种场景）</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.*, b.* from tablea a</span><br><span class="line">inner join tableb b</span><br><span class="line">on a.id = b.id</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这种场景下得到的是满足某一条件的A，B内部的数据；正因为得到的是内部共有数据，所以连接方式称为内连接。</strong></p>
<p><img src="/../pic/Center.png" alt="img"></p>
<p><strong>2.2 外连接（六种场景）</strong></p>
<p><strong>2.2.1 left join 或者left outer join(等同于left join)</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.*, b.* from tablea a</span><br><span class="line">left outer join tableb b</span><br><span class="line">on a.id = b.id</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../pic/Center-20240315213232594.png" alt="img"></p>
<p>这种场景下得到的是A的所有数据，和满足某一条件的B的数据;</p>
<p><strong>2.2.2  [ left  join 或者left outer join(等同于left join) ]  +  [ where B.column is null ]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">left join tableb b</span><br><span class="line">on a.id = b.id</span><br><span class="line">Where b.id is null</span><br></pre></td></tr></tbody></table></figure>

<p>left join表a的数据全部显示，匹配表b的数据也显示，而b.id再次过滤掉 表b的id为空的。</p>
<p><img src="/../pic/Center-20240315221648863.png" alt="img"></p>
<p><strong>2.2.3  right join 或者right outer join(等同于right join)</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">right join tableb b</span><br><span class="line">on a.id = b.id</span><br></pre></td></tr></tbody></table></figure>



<p><strong>2.2.5 full join （mysql不支持，但是可以用 left join  union right join代替）</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">left join tableb b</span><br><span class="line">on a.id = b.id</span><br><span class="line">union</span><br><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">right join tableb b</span><br><span class="line">on a.id = b.id</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../pic/Center-20240315221737005.png" alt="img"></p>
<p><strong>这种场景下得到的是满足某一条件的公共记录，和独有的记录</strong></p>
<p><strong>2.2.6 full join + is null（mysql不支持，但是可以用 （left join + is null） union （right join+is null代替）</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">left join tableb b</span><br><span class="line">on a.id = b.id</span><br><span class="line">where b.id is null</span><br><span class="line">union</span><br><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">right join tableb b</span><br><span class="line">on a.id = b.id</span><br><span class="line">where a.id is null</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../pic/Center-20240315221810273.png" alt="img"></p>
<p><strong>2.3 交叉连接 （cross join）</strong></p>
<p><strong>2.3.1 实际应用中还有这样一种情形，想得到A，B记录的排列组合，即笛卡儿积，这个就不好用集合和元素来表示了。需要用到cross join：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">cross join tableb b</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2.3.2 还可以为cross  join指定条件 （where）：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">cross join tableb b</span><br><span class="line">where a.id = b.id</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这种情况下实际上实现了内连接的效果</strong></p>
<h2 id="MySql-数据的存储结构"><a href="#MySql-数据的存储结构" class="headerlink" title="MySql 数据的存储结构"></a>MySql 数据的存储结构</h2><p>聚簇索引（Innodb）和非聚簇索引（myISAM）</p>
<p><strong>对于InnoDB引擎来说，是按照聚簇索引的形式存储数据</strong></p>
<p><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p><strong>对于MyISAM引擎来说，是按照非聚簇索引的形式存储数据：</strong></p>
<p><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70-20240330214648097.png" alt="img"></p>
<p>存储引擎是InnoDB, 在data目录下会看到2类文件：.frm、.ibd<br>（1）.frm–表结构的文件。<br>（2）.ibd–表数据文件</p>
<p>存储引擎是MyISAM, 在data目录下会看到3类文件：.frm、.myi、.myd<br>（1）.frm–表定义，是描述表结构的文件。<br>（2）.MYD–”D”数据信息文件，是表的数据文件。<br>（3）.MYI–”I”索引信息文件，是表数据文件中任何索引的数据树</p>
<p>聚簇索引和非聚簇索引的存储方式区别：</p>
<ul>
<li>在MyISAM引擎索引和数据是分开存储的，而InnoDB是索引和数据是一起以idb文件的形式进行存储的。</li>
<li>在访问速度上，聚簇索引比非聚簇索引快。非聚簇索引需要先查询一遍索引文件，得到索引，跟据索引获取数据。而聚簇索引的索引树的叶子节点的直接指向要查找的数据行。</li>
</ul>
<h2 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="MyISAM 和 InnoDB 有什么区别？"></a>MyISAM 和 InnoDB 有什么区别？</h2><ol>
<li>事务支持：MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>表锁差异：InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度</li>
<li>读写过程：MyISAM在读写过程中相互阻塞；InnoDB读写阻塞与事务隔离级别相关</li>
<li>读写性能：MyISAM读取性能优越，但是写入性能差（如果执行大量的select，MyISAM是更好的选择）；InnoDB写入性能较强（如果执行大量的insert或者update，InnoDB是更好的选择）</li>
<li>外键支持：MyISAM 不支持外键，而 InnoDB 支持。</li>
<li>存储结构：MyISAM 不支持聚簇索引（数据保存在连续内存中，主键索引：主键列值+行号，二级索引：索引列值+行号）；InnoDB 的数据是存储在主键索引==聚簇索引中</li>
</ol>
<h3 id="innoDB-比-MyISAM-好在哪？"><a href="#innoDB-比-MyISAM-好在哪？" class="headerlink" title="innoDB 比 MyISAM 好在哪？"></a>innoDB 比 MyISAM 好在哪？</h3><p>事务支持</p>
<p>表锁差异</p>
<p>外键支持</p>
<p>数据库异常崩溃后的安全恢复</p>
<h3 id="MyISAM-适合什么场景"><a href="#MyISAM-适合什么场景" class="headerlink" title="MyISAM 适合什么场景"></a>MyISAM 适合什么场景</h3><p>读写性能：MyISAM读取性能优越，但是写入性能差（如果执行大量的select，MyISAM是更好的选择）；InnoDB写入性能较强（如果执行大量的insert或者update，InnoDB是更好的选择）</p>
<h2 id="InnoDB的底层结构"><a href="#InnoDB的底层结构" class="headerlink" title="InnoDB的底层结构"></a>InnoDB的底层结构</h2><p>InnoDB的底层结构主要由2部分组成：内存结构和磁盘结构。</p>
<p><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>2、内存结构由缓冲池（Buffer Pool），写缓冲（Change Buffer），日志缓冲（ Log Buffer），自适应hash索引（Adaptive Hash Index）组成。<br>3、缓冲池（Buffer Pool）主要是缓存表数据与索引数据，加快访问速度。内部采用基于LRU算法的变体算法来管理缓存对象。<br>4、写缓冲（Change Buffer）主要是缓存辅助索引的更新操作，加快辅助索引的更新速度。<br>5、日志缓冲（ Log Buffer）使大型事务可以运行，而无需在事务提交之前将redo日志数据写入磁盘，节省了磁盘I/O。注意事务提交时刷redo log有三种策略。</p>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p>第一范式（1NF)：每列的原子性【不可再分】</p>
<p>第二范式（2NF)：确保表中每列与主键相关，而不能只与主键的某部分相关【消除部分函数依赖】</p>
<p>第三范式（3NF): 属性不依赖于其他非主属性【消除传递依赖】</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="联合索引范围查询"><a href="#联合索引范围查询" class="headerlink" title="联合索引范围查询"></a>联合索引范围查询</h2><p>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><ul>
<li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li>
<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li>
</ul>
<h2 id="什么时候需要-不需要创建索引？"><a href="#什么时候需要-不需要创建索引？" class="headerlink" title="什么时候需要 / 不需要创建索引？"></a>什么时候需要 / 不需要创建索引？</h2><p>需要： 字段唯一；经常用于where查询、 groupby条件和 orderby条件 的字段</p>
<p>不需要：区分度小的；数据少的；经常更新的</p>
<h2 id="设置索引的时候会考虑哪些方面"><a href="#设置索引的时候会考虑哪些方面" class="headerlink" title="设置索引的时候会考虑哪些方面"></a>设置索引的时候会考虑哪些方面</h2><p>设计原则</p>
<ol>
<li><p><strong>针对你的SQL语句里的where条件、order by条件以及group by条件去设计索引</strong></p>
<p>where条件里是要根据哪些字段来筛选数据？order by要根据哪些字段来排序？group by要根据哪些字段来分组聚合</p>
<p>考虑方向：</p>
<p>（1）字段基数，尽量选择值多的，发挥 B+树快速二分查找的优势。判断方式——<strong>select count(distinct(column_name))/count(*) from table_name;</strong> 超过了0.5就适合做索引，越接近1越适合</p>
<p>（2）选字段类型小的列，占用磁盘空间小，查询性能好</p>
<p>（3）频繁更新的字段不适合做主键。<strong>主键一定是自增的而且业务无关</strong>，防止聚簇索引频繁页分裂</p>
<p>（4）查询语句不加函数，不然回走全表扫描</p>
</li>
<li><p><strong>根据这些字段设计一个或者两个联合索引</strong></p>
<p>哪些字段要放到联合索引中去？在联合索引里，字段的顺序要怎么排列呢？</p>
<p>（1）尽量让每一个联合索引都尽量去包含上你的where、order by、group by里的字段。</p>
<p>（2）字段顺序要符合<strong>最左匹配原则</strong>：仔细审查每个SQL语句，是不是每个where、order by、group by后面跟的字段顺序，都是某个联合索引的最左侧字段开始的部分字段。</p>
<p>（3）先让联合索引最左侧开始的多个字段使用等值匹配，最最后一个字段使用范围匹配</p>
</li>
</ol>
<h2 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h2><ul>
<li><p>前缀索引优化；</p>
<p>提高索引的查询速度；减小索引项的大小</p>
</li>
<li><p>覆盖索引优化；</p>
<p>不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。</p>
</li>
<li><p>主键索引最好是自增的；</p>
<p>避免<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p>
</li>
<li><p>防止索引失效；</p>
<ul>
<li>使用<strong>左或者左右模糊匹配</strong>的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式</li>
<li>在查询条件中对索引列做了计算（+ - * /）、函数、类型转换操作</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，or 的前后字段都要上索引</li>
<li>列和列对比，这种情况会被认为还不如走全表扫描。</li>
<li>存在NULL值条件(is null/ is not null)，索引中无法存储NULL值，所以where条件判断如果对字段进行了NULL值判断（is NULL/ is not null），则数据库放弃索引而进行全表查询</li>
</ul>
</li>
</ul>
<h2 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h2><h3 id="SELECT-FROM-t-order-ORDER-BY-text-LIMIT-1000000-10"><a href="#SELECT-FROM-t-order-ORDER-BY-text-LIMIT-1000000-10" class="headerlink" title="SELECT * FROM t_order ORDER BY text LIMIT 1000000, 10"></a>SELECT * FROM t_order ORDER BY text LIMIT 1000000, 10</h3><p><strong>1、使用覆盖索引</strong></p>
<p>SELECT id, ‘text’ FROM t_order ORDER BY text LIMIT 1000000, 10</p>
<p>因为实际开发中，用SELECT查询一两列操作是非常少的，因此上述的覆盖索引的适用范围就比较有限。</p>
<p><strong>2、子查询优化</strong></p>
<p>可以通过把分页的SQL语句改写成子查询的方法获得性能上的提升。</p>
<p>SELECT * FROM t_order where id&gt;=(select id from t_order order by text limit 1000000, 1) LIMIT 10</p>
<p>但是这种优化方法也有局限性：这种写法，要求主键ID必须是连续的</p>
<p><strong>3、延迟关联</strong></p>
<p>和上述的子查询做法类似，我们可以使用JOIN，先在索引列上完成分页操作，然后再回表获取所需要的列。</p>
<p>SELECT a.* FROM t_order as a inner join ( select id from t_order order by text limit 1000000, 10) as b on a.id = b.id</p>
<p><strong>4、记录上次查询结束的位置</strong></p>
<p>和上面使用的方法都不同，记录上次结束位置优化思路是使用某种变量记录上一次数据的位置，下次分页时直接从这个变量的位置开始扫描，从而避免MySQL扫描大量的数据再抛弃的操作。</p>
<p>SELECT * FROM t_order where id&gt;=1000000 LIMIT 10</p>
<h2 id="聚簇索引-二级索引"><a href="#聚簇索引-二级索引" class="headerlink" title="聚簇索引&amp;二级索引"></a>聚簇索引&amp;二级索引</h2><p><strong>聚簇索引</strong>是一种特殊类型的索引，它定义了表中数据的物理排序方式。在聚簇索引中，表中的行按照索引的顺序存储在磁盘上。</p>
<p>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p>
<p>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</p>
<h2 id="MySQL-使用-like-“-x“，索引一定会失效吗？"><a href="#MySQL-使用-like-“-x“，索引一定会失效吗？" class="headerlink" title="MySQL 使用 like “%x“，索引一定会失效吗？"></a>MySQL 使用 like “%x“，索引一定会失效吗？</h2><p>从这个思考题我们知道了，使用左模糊匹配（like “%xx”）并不一定会走全表扫描，关键还是看数据表中的字段。</p>
<p>如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。</p>
<h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p>
<p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
<p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p><strong>原子性（Atomicity）</strong></p>
<p>一个事务中的所有操作，要么全部完成，要么全部不完成</p>
<p><strong>一致性（Consistency）</strong></p>
<p>数据满足完整性约束，数据库保持一致性状态</p>
<p><strong>隔离性（Isolation）</strong></p>
<p>隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</p>
<p><strong>持久性（Durability）</strong></p>
<p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h2 id="InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？"><a href="#InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？" class="headerlink" title="InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？"></a>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</h2><p>原子性是通过 undo log（回滚日志）;</p>
<p>一致性则是通过持久性+原子性+隔离性来保证；</p>
<p>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</p>
<p>持久性是通过 redo log （重做日志）来保证的；</p>
<h2 id="并行事务会引发什么问题？"><a href="#并行事务会引发什么问题？" class="headerlink" title="并行事务会引发什么问题？"></a>并行事务会引发什么问题？</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</p>
<p><img src="/../pic/d37bfa1678eb71ae7e33dc8f211d1ec1.png" alt="图片"></p>
<h2 id="事务的隔离级别有哪些？各自的应用场景"><a href="#事务的隔离级别有哪些？各自的应用场景" class="headerlink" title="事务的隔离级别有哪些？各自的应用场景"></a>事务的隔离级别有哪些？各自的应用场景</h2><p><img src="/../pic/cce766a69dea725cd8f19b90db2d0430.png" alt="图片"></p>
<p><img src="/../pic/4e98ea2e60923b969790898565b4d643.png" alt="图片"></p>
<p><strong>读未提交(Read Uncommitted)</strong></p>
<ul>
<li><p>特点：事务中的修改操作(INSERT、UPDATE、DELETE)立即生效，无需等待事务提交；事务读取数据时可以读取其他事务未提交的数据。</p>
</li>
<li><p>应用场景：对于一些对数据一致性要求不高的场景，比如读取系统的实时监控数据。</p>
</li>
</ul>
<p><strong>读已提交(Read Committed)</strong></p>
<ul>
<li>特点：事务中的修改操作需要等待事务提交后才生效；事务读取数据时只能读取其他事务已提交的数据。</li>
<li>应用场景：适用于大部分常规业务场景，能够保证读取的数据具有较高的一致性。</li>
</ul>
<p>可重复读(Repeatable Read)：</p>
<ul>
<li>特点：事务中的修改操作需要等待事务提交后才生效；事务读取数据时只能读取事务开始时的快照数据，其他事务对数据的修改不可见。</li>
<li>应用场景：适用于需要保证读取数据一致性的应用，例如订单交易等。</li>
</ul>
<p>串行化(Serializable)：</p>
<ul>
<li>特点：事务中的修改操作需要等待事务提交后才生效；事务读取数据时只能读取事务开始时的快照数据，并且其他事务对数据进行了读取和修改的过程中，该数据将被锁定，其他事务无法访问。</li>
<li>应用场景：适用于对数据一致性要求极高的场景，例如金融领域的转账操作。</li>
</ul>
<h2 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h2><ul>
<li>Read View 中四个字段作用；</li>
</ul>
<p><img src="/../pic/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p>
<ul>
<li>聚簇索引记录中两个跟事务有关的隐藏列；</li>
</ul>
<p><img src="/../pic/f595d13450878acd04affa82731f76c5.png" alt="图片"></p>
<p>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</p>
<p>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>核心包括：<strong>undo log、版本链、read view</strong></p>
<p>通过「事务的 Read View 里的事务 id」和「版本链中记录的事务 id」的比对,来控制并发事务访问一个记录的行为叫 MVCC（多版本并发控制）。</p>
<p><img src="/../pic/a463e5d8f8493c4696716e44e96748af-20240324212007851.png" alt="image-20220417154044146"></p>
<p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p>
<p><img src="/../pic/ReadView.drawio.png" alt="img"></p>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ol>
<li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，可见</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，不可见</li>
<li>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，需要判断 trx_id 是否在 m_ids 列表中：在——不可见；不在——可见</li>
</ol>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p>
<ul>
<li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View</li>
<li>「可重复读」隔离级别是启动事务时生成一个 Read View</li>
</ul>
<p>对于幻读现象，不建议将隔离级别升级为串行化。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong></li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong></li>
</ul>
<h2 id="MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p>场景一：<img src="/../pic/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png" alt="img"></p>
<p>对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p>
<p>场景二：</p>
<ul>
<li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</li>
<li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li>
<li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li>
</ul>
<p>解决幻读的场景：</p>
<p>事务在处理跟查询数量有关的操作时候。事务在查询某个范围内的订单数量，然后另一个事务插入了一个新的订单，导致第一个事务再次查询时，订单数量增加了。</p>
<p>总结：</p>
<p>所以，<strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p>
<p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>要使用全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></tbody></table></figure>

<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></tbody></table></figure>

<p>当然，当会话断开了，全局锁会被自动释放。</p>
<blockquote>
<p>全局锁应用场景是什么？</p>
</blockquote>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<blockquote>
<p>加全局锁又会带来什么缺点呢？</p>
</blockquote>
<p>加上全局锁，意味着整个数据库都是只读状态。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<blockquote>
<p>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p>
</blockquote>
<p>有的，如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作，不会影响备份的数据。</p>
<p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><blockquote>
<p>MySQL 表级锁有哪些？具体怎么用的。</p>
</blockquote>
<p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li><p>表锁；</p>
<p>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p>
</li>
<li><p>元数据锁（MDL）;</p>
<p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
</li>
<li><p>意向锁；</p>
<p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。表锁和行锁是满足读读共享、读写互斥、写写互斥的。<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>，从而判断是否能加表锁。</p>
</li>
<li><p>AUTO-INC 锁；</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
</li>
</ul>
<h2 id="什么-SQL-语句会加行级锁？"><a href="#什么-SQL-语句会加行级锁？" class="headerlink" title="什么 SQL 语句会加行级锁？"></a>什么 SQL 语句会加行级锁？</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎 的。</p>
<p>普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。</p>
<p>如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为<strong>锁定读</strong>。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加共享锁(S型锁)</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。</p>
<p>**除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)**。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> .... <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</p>
<p><img src="/../pic/x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="img"></p>
<h2 id="行级锁有哪些种类？"><a href="#行级锁有哪些种类？" class="headerlink" title="行级锁有哪些种类？"></a>行级锁有哪些种类？</h2><p>不同隔离级别下，行级锁的种类是不同的。</p>
<p>在读已提交隔离级别下，行级锁的种类只有记录锁（<strong>解决脏读</strong>），也就是仅仅把一条记录锁上。</p>
<p>在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（<strong>避免幻读</strong>），所以行级锁的种类主要有三类：</p>
<ul>
<li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
<li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是<strong>防止插入幻影</strong>记录而提出的。</li>
<li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<h2 id="MySQL-行级锁的加锁规则"><a href="#MySQL-行级锁的加锁规则" class="headerlink" title="MySQL 行级锁的加锁规则"></a>MySQL 行级锁的加锁规则</h2><p>唯一索引等值查询：</p>
<ul>
<li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li>
<li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</li>
</ul>
<p>非唯一索引等值查询：</p>
<ul>
<li><p>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会<strong>退化成间隙锁</strong>。同时，在符合查询条件的记录的<strong>主键索引上加记录锁</strong>。</p>
<p><img src="/../pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png" alt="img"></p>
</li>
<li><p>当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会<strong>退化成间隙锁</strong>。因为不存在满足查询条件的记录，所以<strong>不会对主键索引加锁</strong>。</p>
<p><img src="/../pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png" alt="img"></p>
</li>
</ul>
<p>唯一索引的<strong>范围查询</strong></p>
<ul>
<li>对每一个扫描到的索引加 next-key 锁</li>
</ul>
<ul>
<li><p>唯一索引在满足一些条件的时候，索引的 next-key lock <strong>退化为间隙锁或者记录锁</strong>。</p>
<ul>
<li><p>「大于等于」找到满足的记录加上 next-key lock，找到等值的记录会退化成记录锁</p>
<p><img src="/../pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E15.drawio.png" alt="img"></p>
</li>
<li><p>「小于等于、小于」出现第一个不匹配的会退化成间隙锁</p>
<p><img src="/../pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E6.drawio-20240331091327727.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<p>非唯一索引的<strong>范围查询</strong></p>
<ul>
<li><p>对每一个扫描到的非唯一索引加 next-key 锁（不会退化），并对匹配的主键索引加记录锁</p>
<p><img src="/../pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png" alt="img"></p>
</li>
</ul>
<p>其实理解 MySQL 为什么要这样加锁，主要要以避免幻读角度去分析，这样就很容易理解这些加锁的规则了。</p>
<h2 id="update-没加索引会锁全表？"><a href="#update-没加索引会锁全表？" class="headerlink" title="update 没加索引会锁全表？"></a>update 没加索引会锁全表？</h2><p>还有一件很重要的事情，在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，**==如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了==**，这是挺严重的问题。</p>
<p>解决方案：</p>
<ol>
<li><p>打开 MySQL sql_safe_updates 参数</p>
</li>
<li><p>使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引</p>
</li>
</ol>
<h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h2><p>在 MySQL 的可重复读隔离级别下，针对当前读的语句会对<strong>索引</strong>加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。</p>
<h2 id="MySQL-死锁了，怎么办？"><a href="#MySQL-死锁了，怎么办？" class="headerlink" title="MySQL 死锁了，怎么办？"></a>MySQL 死锁了，怎么办？</h2><p><img src="/../pic/90c1e01d0345de639e3426cea0390e80.png" alt="img"></p>
<p>避免死锁：</p>
<ol>
<li><strong>设置事务等待锁的超时时间</strong></li>
<li><strong>开启主动死锁检测</strong></li>
</ol>
<p><img src="/../pic/%E5%AD%97%E8%8A%82mysql%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="img"></p>
<p>两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。</p>
<p>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</p>
<p>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>三种日志：</p>
<ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<h2 id="为什么需要-undo-log？"><a href="#为什么需要-undo-log？" class="headerlink" title="为什么需要 undo log？"></a>为什么需要 undo log？</h2><p>执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会<strong>隐式开启事务</strong>来执行“增删改”语句的，执行完就自动提交事务的，这样就保证了执行完“增删改”语句后，我们可以及时在数据库表看到“增删改”的结果了。</p>
<p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p>
<ul>
<li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li>
<li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li>
<li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li>
</ul>
<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。</p>
<p>undo log 两大作用：</p>
<ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
<p><strong>刷盘策略</strong></p>
<p>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</p>
<p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p>
<h2 id="为什么需要-Buffer-Pool？"><a href="#为什么需要-Buffer-Pool？" class="headerlink" title="为什么需要 Buffer Pool？"></a>为什么需要 Buffer Pool？</h2><p>Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p>
<p>有了 Buffer Poo 后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li>
</ul>
<h2 id="为什么需要-redo-log-？"><a href="#为什么需要-redo-log-？" class="headerlink" title="**为什么需要 redo log ？"></a>**为什么需要 redo log ？</h2><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。</p>
<p><img src="/../pic/wal.png" alt="img"></p>
<blockquote>
<p>什么是 redo log？</p>
</blockquote>
<p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<blockquote>
<p>被修改 Undo 页面，需要记录对应 redo log 吗？</p>
</blockquote>
<p>需要的。</p>
<p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p>
<p>不过，<strong>在内存修改该 Undo 页面后，需要记录对应的 redo log</strong>。</p>
<blockquote>
<p>redo log 和 undo log 区别在哪？</p>
</blockquote>
<p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务。</p>
<p>所以有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>（崩溃恢复）。可以看出来， <strong>redo log 保证了事务四大特性中的持久性</strong>。</p>
<blockquote>
<p>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</p>
</blockquote>
<p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。</p>
<p>针对为什么需要 redo log 这个问题我们有两个答案：</p>
<ul>
<li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li>
</ul>
<blockquote>
<p>产生的 redo log 是直接写入磁盘的吗？</p>
</blockquote>
<p>不是的。</p>
<p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘如下图：</p>
<h3 id="redo-log-什么时候刷盘？"><a href="#redo-log-什么时候刷盘？" class="headerlink" title="redo log 什么时候刷盘？"></a>redo log 什么时候刷盘？</h3><p>主要有下面几个时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（由innodb_flush_log_at_trx_commit控制）<ul>
<li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到操作系统的<strong>文件缓存</strong>（page cache）。</li>
</ul>
</li>
</ul>
<p><img src="/../pic/innodb_flush_log_at_trx_commit.drawio.png" alt="img"></p>
<p>InnoDB 的后台线程每隔 1 秒：</p>
<ul>
<li>针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</li>
<li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。<strong>所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li>
</ul>
<p><img src="/../pic/innodb_flush_log_at_trx_commit2.drawio.png" alt="img"></p>
<p>这三个参数的数据安全性和写入性能的比较如下：</p>
<ul>
<li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li>
<li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li>
</ul>
<h3 id="redo-log-文件写满了怎么办？"><a href="#redo-log-文件写满了怎么办？" class="headerlink" title="redo log 文件写满了怎么办？"></a>redo log 文件写满了怎么办？</h3><p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成</p>
<p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p>
<p><img src="/../pic/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png" alt="重做日志文件组写入过程"></p>
<p><img src="/../pic/checkpoint.png" alt="img"></p>
<p>图中的：</p>
<ul>
<li>write pos 和 checkpoint 的移动都是顺时针方向；</li>
<li>write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；</li>
<li>check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li>
</ul>
<p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p>
<h2 id="为什么需要-binlog-？"><a href="#为什么需要-binlog-？" class="headerlink" title="为什么需要 binlog ？"></a>为什么需要 binlog ？</h2><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<h3 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h3><p>为什么有了 binlog， 还要有 redo log？</p>
<p><em>1、适用对象不同：</em></p>
<ul>
<li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li>
<li>redo log 是 Innodb 存储引擎实现的日志；</li>
</ul>
<p><em>2、文件格式不同：</em></p>
<ul>
<li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul>
<li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li>
<li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li>
<li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li>
</ul>
</li>
<li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li>
</ul>
<p><em>3、写入方式不同：</em></p>
<ul>
<li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li>
<li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li>
</ul>
<p><em>4、用途不同：</em></p>
<ul>
<li>binlog 用于备份恢复、主从复制；</li>
<li>redo log 用于掉电等故障恢复。</li>
</ul>
<blockquote>
<p>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</p>
</blockquote>
<p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</p>
<p>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p>
<p>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</p>
<blockquote>
<p>什么时候 binlog cache 会写到 binlog 文件？</p>
</blockquote>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<h3 id="主从复制是怎么实现？"><a href="#主从复制是怎么实现？" class="headerlink" title="主从复制是怎么实现？"></a>主从复制是怎么实现？</h3><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p>
<p><img src="/../pic/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png" alt="MySQL 主从复制过程"></p>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<ul>
<li><p><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</p>
</li>
<li><p><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</p>
</li>
<li><p><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</p>
</li>
</ul>
<p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p>
<p><img src="/../pic/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png" alt="MySQL 主从架构"></p>
<blockquote>
<p>从库是不是越多越好？</p>
</blockquote>
<p>不是的。</p>
<p>因为从库数量增加，从库连接上来的 I/O 线程也比较多，<strong>主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽</strong>。</p>
<p>所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。</p>
<blockquote>
<p>MySQL 主从复制还有哪些模型？</p>
</blockquote>
<p>主要有三种：</p>
<ul>
<li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li>
<li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li>
<li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，<strong>只要数据成功复制到任意一个从库上</strong>，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li>
</ul>
<h3 id="binlog-什么时候刷盘？"><a href="#binlog-什么时候刷盘？" class="headerlink" title="binlog 什么时候刷盘？"></a>binlog 什么时候刷盘？</h3><blockquote>
<p>什么时候 binlog cache 会写到 binlog 文件？</p>
</blockquote>
<p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。如下图：</p>
<p><img src="/../pic/binlogcache.drawio.png" alt="binlog cach"></p>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p>
<p>而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。</p>
<p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。</p>
<h2 id="为什么需要两阶段提交？"><a href="#为什么需要两阶段提交？" class="headerlink" title="为什么需要两阶段提交？"></a>为什么需要两阶段提交？</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p>
<p>举个例子，假设 id = 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 <code>UPDATE t_user SET name = 'xiaolin' WHERE id = 1;</code> 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p>
<ul>
<li><p><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。</p>
</li>
<li><p><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。</p>
</li>
</ul>
<p>在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p>
<h3 id="两阶段提交的过程是怎样的？"><a href="#两阶段提交的过程是怎样的？" class="headerlink" title="两阶段提交的过程是怎样的？"></a>两阶段提交的过程是怎样的？</h3><p><img src="/../pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png" alt="两阶段提交"></p>
<p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p>
<ul>
<li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</li>
<li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li>
</ul>
<h3 id="异常重启会出现什么现象？"><a href="#异常重启会出现什么现象？" class="headerlink" title="异常重启会出现什么现象？"></a>异常重启会出现什么现象？</h3><p><img src="/../pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png" alt="时刻 A 与时刻 B"></p>
<p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p>
<ul>
<li><p><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</p>
</li>
<li><p><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</p>
</li>
</ul>
<p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p>
<p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p>
<blockquote>
<p>处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?</p>
</blockquote>
<p>binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。</p>
<p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p>
<blockquote>
<p>事务没提交的时候，redo log 会被持久化到磁盘吗？</p>
</blockquote>
<p>会的。</p>
<p>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。</p>
<p>也就是说，<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。</p>
<p>但不会造成数据不一致，mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</p>
<p>redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。</p>
<h3 id="两阶段提交有什么问题？"><a href="#两阶段提交有什么问题？" class="headerlink" title="两阶段提交有什么问题？"></a>两阶段提交有什么问题？</h3><ul>
<li><p><strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</p>
</li>
<li><p><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</p>
</li>
</ul>
<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><p>具体更新一条记录 <code>UPDATE t_user SET name = 'xiaolin' WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：<ul>
<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。</p>
<p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p>
<p>Innodb 通过三种链表来管理缓页：</p>
<ul>
<li>Free List （空闲页链表），管理空闲页；</li>
<li>Flush List （脏页链表），管理脏页；</li>
<li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</li>
</ul>
<p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p>
<ul>
<li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li>
<li>当<strong>「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」</strong>时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li>
</ul>
<p>可以通过调整 <code>innodb_old_blocks_pct</code> 参数，设置 young 区域和 old 区域比例。</p>
<p>在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p><img src="/../pic/mybatis-y-arch-4.png" alt="img"></p>
<h2 id="mybatis-的执行流程"><a href="#mybatis-的执行流程" class="headerlink" title="mybatis 的执行流程"></a>mybatis 的执行流程</h2><p><img src="/../pic/fb8f06d7d8c544c8a9bf1885c44bf3be.png" alt="在这里插入图片描述"></p>
<ol>
<li>首先读取配置文件，然后加载映射文件，由SqlSessionFactory工厂对象去创建核心对象SqlSession，SqlSession对象会通过Executor执行器对象执行sql。</li>
<li>然后Executor执行器对象会调用StatementHandler对象去真正的访问数据库执行sql语句。在执行sql语句前MapperStatement会先对映射信息进行封装，存储要映射的SQL语句的id、参数等信息</li>
<li>然后调用ParameterHandler去设置编译参数【#{}，${}】</li>
<li>然后TypeHandler进行数据库类型和JavaBean类型映射处理。</li>
<li>然后调用JBDC原生API进行处理，获取执行结果，这个执行结果交给ResultSetHandler 来进行结果集封装，然后将结果返回给StatementHandler。</li>
</ol>
</body></html></div><div class="article-licensing box"><div class="licensing-title"><p>MySQL</p><p><a href="https://jerryzhu1229.github.io/2024/03/12/MySQL/">https://jerryzhu1229.github.io/2024/03/12/MySQL/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jerry Z</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-04-09</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/03/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">操作系统</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/12/JVM/"><span class="level-item">JVM</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#综合题"><span class="level-left"><span class="level-item">1</span><span class="level-item">综合题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。</span></span></a></li><li><a class="level is-mobile" href="#使用-explain-优化你的-mysql-性能"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">使用 explain 优化你的 mysql 性能</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Explain-特点"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">Explain 特点</span></span></a></li><li><a class="level is-mobile" href="#Explain-中的列"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">Explain 中的列</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#基础"><span class="level-left"><span class="level-item">2</span><span class="level-item">基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#执行一条-SQL-查询语句，期间发生了什么？"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">执行一条 SQL 查询语句，期间发生了什么？</span></span></a></li><li><a class="level is-mobile" href="#MySQL-一行记录是怎么存储的？"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">MySQL 一行记录是怎么存储的？</span></span></a></li><li><a class="level is-mobile" href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</span></span></a></li><li><a class="level is-mobile" href="#多表查询（各种join连接详解）"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">多表查询（各种join连接详解）</span></span></a></li><li><a class="level is-mobile" href="#MySql-数据的存储结构"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">MySql 数据的存储结构</span></span></a></li><li><a class="level is-mobile" href="#MyISAM-和-InnoDB-有什么区别？"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">MyISAM 和 InnoDB 有什么区别？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#innoDB-比-MyISAM-好在哪？"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">innoDB 比 MyISAM 好在哪？</span></span></a></li><li><a class="level is-mobile" href="#MyISAM-适合什么场景"><span class="level-left"><span class="level-item">2.6.2</span><span class="level-item">MyISAM 适合什么场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#InnoDB的底层结构"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">InnoDB的底层结构</span></span></a></li><li><a class="level is-mobile" href="#三大范式"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">三大范式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#索引"><span class="level-left"><span class="level-item">3</span><span class="level-item">索引</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#联合索引范围查询"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">联合索引范围查询</span></span></a></li><li><a class="level is-mobile" href="#索引下推"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">索引下推</span></span></a></li><li><a class="level is-mobile" href="#什么时候需要-不需要创建索引？"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">什么时候需要 / 不需要创建索引？</span></span></a></li><li><a class="level is-mobile" href="#设置索引的时候会考虑哪些方面"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">设置索引的时候会考虑哪些方面</span></span></a></li><li><a class="level is-mobile" href="#有什么优化索引的方法？"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">有什么优化索引的方法？</span></span></a></li><li><a class="level is-mobile" href="#优化案例"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">优化案例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#SELECT-FROM-t-order-ORDER-BY-text-LIMIT-1000000-10"><span class="level-left"><span class="level-item">3.6.1</span><span class="level-item">SELECT * FROM t_order ORDER BY text LIMIT 1000000, 10</span></span></a></li></ul></li><li><a class="level is-mobile" href="#聚簇索引-二级索引"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">聚簇索引&amp;二级索引</span></span></a></li><li><a class="level is-mobile" href="#MySQL-使用-like-“-x“，索引一定会失效吗？"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">MySQL 使用 like “%x“，索引一定会失效吗？</span></span></a></li><li><a class="level is-mobile" href="#count-和-count-1-有什么区别？哪个性能最好？"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">count(*) 和 count(1) 有什么区别？哪个性能最好？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#事务"><span class="level-left"><span class="level-item">4</span><span class="level-item">事务</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#事务有哪些特性？"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">事务有哪些特性？</span></span></a></li><li><a class="level is-mobile" href="#InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</span></span></a></li><li><a class="level is-mobile" href="#并行事务会引发什么问题？"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">并行事务会引发什么问题？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#脏读"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">脏读</span></span></a></li><li><a class="level is-mobile" href="#不可重复读"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">不可重复读</span></span></a></li><li><a class="level is-mobile" href="#幻读"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">幻读</span></span></a></li></ul></li><li><a class="level is-mobile" href="#事务的隔离级别有哪些？各自的应用场景"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">事务的隔离级别有哪些？各自的应用场景</span></span></a></li><li><a class="level is-mobile" href="#Read-View"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">Read View</span></span></a></li><li><a class="level is-mobile" href="#MVCC"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">MVCC</span></span></a></li><li><a class="level is-mobile" href="#MySQL-可重复读隔离级别，完全解决幻读了吗？"><span class="level-left"><span class="level-item">4.7</span><span class="level-item">MySQL 可重复读隔离级别，完全解决幻读了吗？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#锁"><span class="level-left"><span class="level-item">5</span><span class="level-item">锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#全局锁"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">全局锁</span></span></a></li><li><a class="level is-mobile" href="#表级锁"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">表级锁</span></span></a></li><li><a class="level is-mobile" href="#什么-SQL-语句会加行级锁？"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">什么 SQL 语句会加行级锁？</span></span></a></li><li><a class="level is-mobile" href="#行级锁有哪些种类？"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">行级锁有哪些种类？</span></span></a></li><li><a class="level is-mobile" href="#MySQL-行级锁的加锁规则"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">MySQL 行级锁的加锁规则</span></span></a></li><li><a class="level is-mobile" href="#update-没加索引会锁全表？"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">update 没加索引会锁全表？</span></span></a></li><li><a class="level is-mobile" href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</span></span></a></li><li><a class="level is-mobile" href="#MySQL-死锁了，怎么办？"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">MySQL 死锁了，怎么办？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#日志"><span class="level-left"><span class="level-item">6</span><span class="level-item">日志</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么需要-undo-log？"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">为什么需要 undo log？</span></span></a></li><li><a class="level is-mobile" href="#为什么需要-Buffer-Pool？"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">为什么需要 Buffer Pool？</span></span></a></li><li><a class="level is-mobile" href="#为什么需要-redo-log-？"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">**为什么需要 redo log ？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#redo-log-什么时候刷盘？"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">redo log 什么时候刷盘？</span></span></a></li><li><a class="level is-mobile" href="#redo-log-文件写满了怎么办？"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">redo log 文件写满了怎么办？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#为什么需要-binlog-？"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">为什么需要 binlog ？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#redo-log-和-binlog-有什么区别？"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">redo log 和 binlog 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#主从复制是怎么实现？"><span class="level-left"><span class="level-item">6.4.2</span><span class="level-item">主从复制是怎么实现？</span></span></a></li><li><a class="level is-mobile" href="#binlog-什么时候刷盘？"><span class="level-left"><span class="level-item">6.4.3</span><span class="level-item">binlog 什么时候刷盘？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#为什么需要两阶段提交？"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">为什么需要两阶段提交？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#两阶段提交的过程是怎样的？"><span class="level-left"><span class="level-item">6.5.1</span><span class="level-item">两阶段提交的过程是怎样的？</span></span></a></li><li><a class="level is-mobile" href="#异常重启会出现什么现象？"><span class="level-left"><span class="level-item">6.5.2</span><span class="level-item">异常重启会出现什么现象？</span></span></a></li><li><a class="level is-mobile" href="#两阶段提交有什么问题？"><span class="level-left"><span class="level-item">6.5.3</span><span class="level-item">两阶段提交有什么问题？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MySQL日志"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">MySQL日志</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内存"><span class="level-left"><span class="level-item">7</span><span class="level-item">内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Buffer-Pool"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">Buffer Pool</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MyBatis"><span class="level-left"><span class="level-item">8</span><span class="level-item">MyBatis</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#mybatis-的执行流程"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">mybatis 的执行流程</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/cs/"><span class="level-start"><span class="level-item">cs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a><p class="is-size-7"><span>&copy; 2024 Jerry Z</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>