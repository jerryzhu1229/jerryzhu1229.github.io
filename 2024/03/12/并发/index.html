<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>并发 - hao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="hao"><meta name="msapplication-TileImage" content="/img/2751710164138_.pic.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="hao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="hao"><meta property="og:url" content="https://jerryzhu1229.github.io/2024/03/12/%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="hao"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/640-1295355.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331150208347.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331151309247.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331151635615.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/java-thread-x-key-schronized-2.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/0e617593ca8a4000a9131a72d1f8730e.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/clh-queue-structure.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/clh-queue-state.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/27605d483e8935da683a93be015713f331378.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/3f1e1a44f5b7d77000ba4f9476189b2e32806.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/b8b53a70984668bc68653efe9531573e78636.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/java-thread-x-juc-reentrantlock-1.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/0dde2d343b11b15140fcfec3ef247eba.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/java-thread-x-executors-1.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/640.png"><meta property="article:published_time" content="2024-03-12T01:54:55.000Z"><meta property="article:modified_time" content="2024-04-08T13:02:56.281Z"><meta property="article:author" content="Jerry Z"><meta property="article:tag" content="面经"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jerryzhu1229.github.io/pic/640-1295355.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerryzhu1229.github.io/2024/03/12/%E5%B9%B6%E5%8F%91/"},"headline":"并发","image":["https://jerryzhu1229.github.io/pic/640-1295355.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331150208347.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331151309247.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331151635615.png","https://jerryzhu1229.github.io/pic/java-thread-x-key-schronized-2.png","https://jerryzhu1229.github.io/pic/0e617593ca8a4000a9131a72d1f8730e.png","https://jerryzhu1229.github.io/pic/clh-queue-structure.png","https://jerryzhu1229.github.io/pic/clh-queue-state.png","https://jerryzhu1229.github.io/pic/27605d483e8935da683a93be015713f331378.png","https://jerryzhu1229.github.io/pic/3f1e1a44f5b7d77000ba4f9476189b2e32806.png","https://jerryzhu1229.github.io/pic/b8b53a70984668bc68653efe9531573e78636.png","https://jerryzhu1229.github.io/pic/java-thread-x-juc-reentrantlock-1.png","https://jerryzhu1229.github.io/pic/0dde2d343b11b15140fcfec3ef247eba.png","https://jerryzhu1229.github.io/pic/java-thread-x-executors-1.png","https://jerryzhu1229.github.io/pic/640.png"],"datePublished":"2024-03-12T01:54:55.000Z","dateModified":"2024-04-08T13:02:56.281Z","author":{"@type":"Person","name":"Jerry Z"},"publisher":{"@type":"Organization","name":"hao","logo":{"@type":"ImageObject","url":"https://jerryzhu1229.github.io/img/2751710164138_.pic.jpg"}},"description":""}</script><link rel="canonical" href="https://jerryzhu1229.github.io/2024/03/12/%E5%B9%B6%E5%8F%91/"><link rel="icon" href="/img/2751710164138_.pic.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/cs">计算机基础</a><a class="navbar-item" href="/categories/java">后端开发</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jerryzhu1229"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-12T01:54:55.000Z" title="2024/3/12 09:54:55">2024-03-12</time>发表</span><span class="level-item"><time dateTime="2024-04-08T13:02:56.281Z" title="2024/4/8 21:02:56">2024-04-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">1 小时读完 (大约8317个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">并发</h1><div class="content"><html><head></head><body><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="线程有哪几种状态-分别说明从一种状态到另一种状态转变有哪些方式"><a href="#线程有哪几种状态-分别说明从一种状态到另一种状态转变有哪些方式" class="headerlink" title="线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?"></a>线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?</h3><p><img src="/../pic/640-1295355.png" alt="Java 线程状态变迁图"></p>
<h3 id="线程有哪几种创建方式"><a href="#线程有哪几种创建方式" class="headerlink" title="线程有哪几种创建方式?"></a>线程有哪几种创建方式?</h3><h4 id="方式一：继承于Thread类"><a href="#方式一：继承于Thread类" class="headerlink" title="方式一：继承于Thread类"></a><strong>方式一：继承于Thread类</strong></h4><blockquote>
<p>步骤：<br>1.创建一个继承于Thread类的子类<br>2.重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中<br>3.创建Thread类的子类的对象<br>4.通过此对象调用start()执行线程</p>
</blockquote>
<h4 id="方式二：实现Runnable接口"><a href="#方式二：实现Runnable接口" class="headerlink" title="方式二：实现Runnable接口"></a><strong>方式二：实现Runnable接口</strong></h4><blockquote>
<p>步骤：<br>1.创建一个实现了Runnable接口的类<br>2.实现类去实现Runnable中的抽象方法：run()<br>3.创建实现类的对象<br>4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象<br>5.通过Thread类的对象调用start()<br>① 启动线程<br>②调用当前线程的run()–&gt;调用了Runnable类型的target的run()</p>
</blockquote>
<p>方式一和方式二的比较：</p>
<ul>
<li>开发中优先选择实现Runnable接口的方式</li>
<li>原因：<br>（1）实现的方式没有类的单继承性的局限性<br>（2）实现的方式更适合来处理多个线程有共享数据的情况</li>
</ul>
<h4 id="方式三：实现Callable接口"><a href="#方式三：实现Callable接口" class="headerlink" title="方式三：实现Callable接口"></a>方式三：实现Callable接口</h4><blockquote>
<p>步骤：<br>1.创建一个实现Callable的实现类<br>2.实现call方法，将此线程需要执行的操作声明在call()中<br>3.创建Callable接口实现类的对象<br>4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象<br>5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()<br>6.获取Callable中call方法的返回值</p>
</blockquote>
<p>实现Callable接口的方式创建线程的强大之处</p>
<ul>
<li>call()可以有返回值的</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的</li>
</ul>
<h4 id="方式四：使用线程池"><a href="#方式四：使用线程池" class="headerlink" title="方式四：使用线程池"></a>方式四：使用线程池</h4><blockquote>
<p>步骤：<br>1.以方式二或方式三创建好实现了Runnable接口的类或实现Callable的实现类<br>2.实现run或call方法<br>3.创建线程池<br>4.调用线程池的execute方法执行某个线程，参数是之前实现Runnable或Callable接口的对象</p>
</blockquote>
<p>线程池好处：<br>1.提高响应速度（减少了创建新线程的时间）<br>2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>3.便于线程管理</p>
<h3 id="基础线程机制有哪些"><a href="#基础线程机制有哪些" class="headerlink" title="基础线程机制有哪些?"></a>基础线程机制有哪些?</h3><h3 id="线程的中断方式有哪些"><a href="#线程的中断方式有哪些" class="headerlink" title="线程的中断方式有哪些?"></a>线程的中断方式有哪些?</h3><h3 id="线程的互斥同步方式有哪些-如何比较和选择"><a href="#线程的互斥同步方式有哪些-如何比较和选择" class="headerlink" title="线程的互斥同步方式有哪些? 如何比较和选择?"></a>线程的互斥同步方式有哪些? 如何比较和选择?</h3><h3 id="线程之间有哪些协作方式"><a href="#线程之间有哪些协作方式" class="headerlink" title="线程之间有哪些协作方式?"></a>线程之间有哪些协作方式?</h3><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&amp;&amp;悲观锁"></a>乐观锁&amp;&amp;悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>认为在访问数据的时候，其他线程不怎么会对该数据进行修改，所以不加锁。只是在修改的时候通过一种验证数据是否被修改的机制来解决并发问题。</p>
<p>有两种方式：</p>
<ol>
<li>CAS</li>
<li>版本号</li>
</ol>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>认为数据经常会被其他线程修改，所以在某一个线程抢占到该数据时，对其上锁，其他线程想要访问会被阻塞。</p>
<h3 id="CAS-的问题"><a href="#CAS-的问题" class="headerlink" title="CAS 的问题"></a>CAS 的问题</h3><p><strong>CAS引发的ABA问题</strong>：</p>
<p>ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。ABA问题的解决思路是，每次变量更新的时候把变量的版本号加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题。</p>
<p><strong>CAS导致自旋消耗</strong>：</p>
<p>多个线程争夺同一个资源时，如果自旋一直不成功，将会一直占用CPU。</p>
<p>解决方法：破坏掉for死循环，当超过一定时间或者一定次数时，return退出。</p>
<p><strong>CAS只能单变量：</strong></p>
<p>CAS的原子操作只能针对一个共享变量，假如需要针对多个变量进行原子操作也是可以解决的。</p>
<p><strong>方法：</strong>CAS操作是针对一个变量的，如果对多个变量操作，1. 可以加锁来解决。2 .封装成对象类解决。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="**Synchronized"></a>**Synchronized</h2><h3 id="Synchronized-可以作用在哪"><a href="#Synchronized-可以作用在哪" class="headerlink" title="Synchronized 可以作用在哪"></a>Synchronized 可以作用在哪</h3><p>分为对象锁、类锁</p>
<p>对象锁：</p>
<ul>
<li>方法锁：synchronized 修饰普通方法，锁对象默认 this</li>
<li>代码块锁：手动指定锁对象</li>
</ul>
<p>类锁：</p>
<ul>
<li>方法锁：synchronized 修饰静态方法</li>
<li>代码块锁：手动指定锁对象为 Class 对象</li>
</ul>
<h3 id="Synchronized本质上是通过什么保证线程安全的"><a href="#Synchronized本质上是通过什么保证线程安全的" class="headerlink" title="Synchronized本质上是通过什么保证线程安全的"></a>Synchronized本质上是通过什么保证线程安全的</h3><h4 id="加锁、释放锁原理"><a href="#加锁、释放锁原理" class="headerlink" title="加锁、释放锁原理"></a>加锁、释放锁原理</h4><p>无锁-》偏向锁-》轻量级锁-》重量级锁</p>
<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p><strong>可重入</strong>：同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁</p>
<h4 id="保证可见性原理"><a href="#保证可见性原理" class="headerlink" title="保证可见性原理"></a>保证可见性原理</h4><p>Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。且解锁前的结果对于加锁后的操作是可见的</p>
<h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="**锁的升级"></a>**锁的升级</h3><p> Java中锁主要存在四种状态：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，随着竞争的激烈而逐渐升级。==锁只能升级而不能降级==</p>
<p><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>首先简单说下先偏向锁、轻量级锁、重量级锁三者各自的应用场景：</p>
<blockquote>
<p>偏向锁：只有一个线程进入临界区；<br>轻量级锁：多个线程交替进入临界区；<br>重量级锁：多个线程同时进入临界区。</p>
</blockquote>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>流程：</p>
<p>​	==JVM使用CAS操作把线程ID记录到对象的Mark Word当中，并修改标识位==。此时进入偏向模式，若接下来没有其他线程进入临界区，该线程可以不用执行任何同步操作进入临界区。</p>
<p>​	线程不会自己释放偏向锁，当其他线程想要抢占锁时，会进行判断之前的占有线程是否完成，（1）如果在运行中，则持有偏向锁的线程会被挂起，<strong>JVM会消除它身上的偏向锁，将锁升级到轻量级锁</strong>（可能多个线程交替进入临界区）；（2）如果不在运行中，则利用 CAS 更改对象头的线程 ID<br><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331150208347.png" alt="在这里插入图片描述"></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>​	轻量级锁是由偏向级锁升级来的，一段时间内有两个线程进入临界区，偏向锁就会升级为轻量级锁。</p>
<p>流程：</p>
<ol>
<li>首先，JVM会将锁对象的Mark Word恢复成为无锁状态，<strong>在当前两线程的栈桢中各自分配一个空间，叫做Lock Record，把锁对象的Mark Word在两线程的栈桢中各自复制了一份，官方称为：Displaced Mark Word</strong></li>
<li>然后一个线程尝试使用CAS将对象头中的Mak Word替换为指向锁记录的指针，如果替换成功，则当前线程获得锁，如果失败，则当前线程<strong>自旋</strong>重新尝试获取锁。当自旋获取锁失败超过 10 次时，表示竞争比较激烈，<strong>则轻量级锁会膨胀成重量级锁</strong></li>
<li>轻量级解锁时，会使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。</li>
</ol>
<p><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331151309247.png" alt="在这里插入图片描述"></p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>当多个线程竞争同一个锁时，会导致除锁的拥有者外，其余线程都会自旋，这将导致自旋次数过多，cpu效率下降，所以会将锁升级为重量级锁。</p>
<p> <strong>重量级锁需要操作系统的介入，依赖操作系统底层的Mutex Lock</strong>。JVM会创建一个monitor对象，把这个对象的地址更新到Mark Word中。</p>
<p><img src="/../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NvbG9yZnVsX1g=,size_16,color_FFFFFF,t_70-20240331151635615.png" alt="在这里插入图片描述"></p>
<p>当一个线程获取了该锁后，其余线程想要获取锁，必须等到这个线程释放锁后才可能获取到，没有获取到锁的线程，就进入了阻塞状态。</p>
<p><strong>具体流程：</strong></p>
<p>加锁、释放锁通过「monitor 对象」。在并发抢占时，一个对象对应一个 monitor，同一时间只有一个线程能获得 monitor。</p>
<p>主要指令有「monitorenter」尝试获取monitor 所有权 和 「monitorexit」释放monitor 所有权</p>
<p>调用「monitorenter」时有三种情况：</p>
<ol>
<li>当 monitor 计数器为 0，说明没有其他线程抢占，enter 成功，线程获取该 monitor，计数器+1</li>
<li>已经获取该monitor的线程，可以重复执行 enter，执行依次计数器+1</li>
<li>若 monitor 计数器不为 0，说明锁已经被其他线程获取，需要等待锁的释放。</li>
</ol>
<p>调用「monitorexit」时：</p>
<p>释放对于monitor的所有权，将monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p>
<p><img src="/../pic/java-thread-x-key-schronized-2.png" alt="img"></p>
<p>该图可以看出，任意线程获取Object锁的时候，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。</p>
<h3 id="Synchronized有什么样的缺陷？Lock解决相应问题？如何选择？"><a href="#Synchronized有什么样的缺陷？Lock解决相应问题？如何选择？" class="headerlink" title="Synchronized有什么样的缺陷？Lock解决相应问题？如何选择？"></a>Synchronized有什么样的缺陷？Lock解决相应问题？如何选择？</h3><ol>
<li>灵活性低：加锁释放锁的时机单一</li>
<li>效率低：锁的释放情况少，只有代码完成或者异常退出的时候才释放；不能中断一个正在使用锁的进程，不能对试图获取锁的进程设置超时。Lock 可以中断和超时</li>
<li>无法知道是否成功获得锁：Lock 可以拿到是否获取到锁的状态</li>
</ol>
<p>Lock类这里不做过多解释，主要看里面的4个方法:</p>
<ul>
<li><code>lock()</code>: 加锁</li>
<li><code>unlock()</code>: 解锁</li>
<li><code>tryLock()</code>: 尝试获取锁，返回一个boolean值</li>
<li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li>
</ul>
<p>建议：</p>
<p>1.如果可以的话，尽量就不使用lock也不要使用Synchronized关键字而是使用java.Util.concurrent中的各种包中的类<br>2.如果Synchronized在程序中适用，那么我们就优先选择Synchronized，因为这样可以减少我们所需要编写的代码，可以减少出错率<br>3.如果特别需要用的lock的时候，我们再使用lock</p>
<h3 id="Synchronized在使用时有何注意事项"><a href="#Synchronized在使用时有何注意事项" class="headerlink" title="Synchronized在使用时有何注意事项?"></a>Synchronized在使用时有何注意事项?</h3><p><strong>锁对象不能为空，作用域不宜过大，避免死锁</strong></p>
<p><strong>锁对象不能为空</strong>：就是我们如果指定了一个对象为我们的锁对象，那么他就必须是被实例化过的，就是被new过的，不是一个空对象，因为我们的Synchronized是放在我们的对象头中修饰的，如果这个对象为空，更没有对象头，那么这个锁是没有办法工作的<br><strong>作用域不宜过大</strong>：作用域是指被Synchronized代码块所包括的范围，如果我们尽量多的代码都被Synchronized所修饰，那么我们代码就会达到安全的目的，但是对于效率就会降低，我们多线程编程，目的是为了提高效率，再不需要安全的情况下，我们并行去执行，是可以提高运行的效率，所以如果我们把Synchronized作用域设置的过大，就会影响我们程序的执行效率的。</p>
<h3 id="多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程"><a href="#多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程" class="headerlink" title="多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程?"></a>多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程?</h3><p><img src="/../pic/0e617593ca8a4000a9131a72d1f8730e.png" alt="在这里插入图片描述"></p>
<p>队列：</p>
<ul>
<li>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</li>
<li>Entry List：候选者队列，Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</li>
<li>WaitSet：阻塞队列，哪些调用wait方法被阻塞的线程被放置在这里，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中；</li>
</ul>
<p>线程：</p>
<ul>
<li>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck，<strong>从 EntryList 中选出</strong>。</li>
<li>Owner：从刚刚申请的线程和 OnDeck 选一个最终获得锁，当前已经获取到所资源的线程被称为Owner；</li>
</ul>
<p>根据 JVM 随机选择，要么是候选者队列中的线程，要么是刚刚申请获取锁的线程</p>
<p>所以——synchronized实际上是非公平的，新来的线程先尝试自旋获取锁，如果获取不到就进入竞争队列，而在等待区中等候已久的线程可能再次等待，<strong>这样有利于提高性能，但是也可能会导致饥饿现象</strong>。</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS核心思想？如何实现？底层数据结构？"><a href="#AQS核心思想？如何实现？底层数据结构？" class="headerlink" title="AQS核心思想？如何实现？底层数据结构？"></a>AQS核心思想？如何实现？底层数据结构？</h3><p><strong>核心思想</strong>：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。这个机制主要用的是 CLH 队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p><strong>实现</strong>：</p>
<ol>
<li>state：volatile int state变量，表示同步状态</li>
<li>通过内置的 FIFO 队列来完成资源获取的排队工作</li>
<li>通过 CAS 完成对 State 值的修改。</li>
</ol>
<p><strong>state</strong>：</p>
<ol>
<li>独占模式 state=0，说明可以抢资源，&gt;0 说明不能</li>
<li>共享模式 state&gt;0，说明可以抢资源，=0 说明不能</li>
</ol>
<p><strong>设计模式：</strong></p>
<p>模版方法</p>
<p><strong>底层数据结构</strong>：</p>
<ol>
<li>同步队列：</li>
</ol>
<p>CLH 锁是对自旋锁的一种改进，是单向链表，AQS又对 CLH 锁进行改进, 变成一个==虚拟的双向队列，即同步队列==（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），AQS 是通过将每条请求共享资源的线程封装成一个Node节点来实现锁的分配；当获取同步状态成功的线程释放同步状态的时候，唤醒队列中下一个节点去抢同步状态。</p>
<p>共享模式的区别在于，唤醒的时候，可能会唤醒队列里一批的节点</p>
<blockquote>
<p>在 CLH 队列锁中，一个节点表示一个线程，它保存着<strong>线程的引用</strong>（thread）、 <strong>当前节点在队列中的状态</strong>（waitStatus）、<strong>前驱节点</strong>（prev）、<strong>后继节点</strong>（next）。</p>
<p><img src="/../pic/clh-queue-structure.png" alt="CLH 队列结构"></p>
<p>AQS 每个节点的状态如下所示，在源码中如下所示：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile int waitStatus;</span><br></pre></td></tr></tbody></table></figure>

<p>AQS 同样提供了该状态变量的原子读写操作，但和同步器状态不同的是，节点状态在 AQS 中被清晰的定义，如下表所示：</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIGNAL</td>
<td>表示该节点正常等待</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>应将 releaseShared 传播到其他节点</td>
</tr>
<tr>
<td>CONDITION</td>
<td>该节点位于条件队列，不能用于同步队列节点</td>
</tr>
<tr>
<td>CANCELLED</td>
<td>由于超时、中断或其他原因，该节点被取消</td>
</tr>
</tbody></table>
</blockquote>
<ol start="2">
<li>condition等待队列： AQS通过内部类ConditionObject构建等待队列（可有多个），当Condition调用wait()方法后，线程将会加入等待队列中，而当Condition调 用signal()方法后 ，线程将从等待队列转移动同步队列中进行锁竞争 。</li>
</ol>
<p><strong>AQS 的核心原理图</strong></p>
<p><img src="/../pic/clh-queue-state.png" alt="CLH 队列"></p>
<p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>CLH 队列</strong>来完成获取资源线程的排队工作。</p>
<p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p>
<p><strong>同步状态</strong></p>
<p>状态信息 <code>state</code> 可以通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> {</span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line">}</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> {</span><br><span class="line">     state = newState;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> {</span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="AQS定义什么样的资源获取方式"><a href="#AQS定义什么样的资源获取方式" class="headerlink" title="AQS定义什么样的资源获取方式?"></a>AQS定义什么样的资源获取方式?</h3><p>==可以通过修改 State 字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。==</p>
<p><img src="/../pic/27605d483e8935da683a93be015713f331378.png" alt="img"></p>
<p><img src="/../pic/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="img"></p>
<h3 id="AQS有哪些核心的方法"><a href="#AQS有哪些核心的方法" class="headerlink" title="AQS有哪些核心的方法?"></a>AQS有哪些核心的方法?</h3><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><p>该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>以独占模式释放对象</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) { <span class="comment">// 释放成功</span></span><br><span class="line">        <span class="comment">// 保存头节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 头节点不为空并且头节点状态不为0</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">//释放头节点的后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="**ReentrantLock"></a>**ReentrantLock</h2><p>修改 State 字段为 0 来实现独占方式</p>
<p>再实现两个 AQS 提供的模板方法 tryAcquire和tryRelease。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><p><img src="/../pic/b8b53a70984668bc68653efe9531573e78636.png" alt="img"></p>
<h3 id="如何实现可重入"><a href="#如何实现可重入" class="headerlink" title="如何实现可重入"></a><strong>如何实现可重入</strong></h3><p>比较拥有同步状态的线程是否和当前请求同步状态的线程相同，若相同则cas 让 state+1，</p>
<h3 id="有公平锁和非公平锁两种"><a href="#有公平锁和非公平锁两种" class="headerlink" title="有公平锁和非公平锁两种"></a><strong>有公平锁和非公平锁两种</strong></h3><ol>
<li>公平锁：在请求共享资源时发现资源被占用，该线程就会添加到sync queue中的尾部，而不会先尝试获取资源。</li>
<li>非公平锁：每一次都会尝试去获取资源，如果此时该资源恰好被释放，则会被当前线程获取，这就造成了不公平的现象，当获取不成功，再加入队列尾部。</li>
</ol>
<p>默认用非公平锁</p>
<h3 id="三个内部类："><a href="#三个内部类：" class="headerlink" title="三个内部类："></a><strong>三个内部类：</strong></h3><p><img src="/../pic/java-thread-x-juc-reentrantlock-1.png" alt="image"></p>
<p>说明: ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。</p>
<h2 id="ReentrantLock和-Synchornized-关系"><a href="#ReentrantLock和-Synchornized-关系" class="headerlink" title="ReentrantLock和 Synchornized 关系"></a>ReentrantLock和 Synchornized 关系</h2><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><ol>
<li>独占锁</li>
<li>可重入</li>
</ol>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><ol>
<li>syn 是关键字，reen 是类</li>
<li>syn 基于 monitor，reen 基于AQS</li>
<li>syn 只有非公平方式，reen 有公平方式和非公平方式</li>
<li>syn不可以响应中断，reen 可以同时获取锁时可以限时等待</li>
<li>syn 利用 object 的 wait() 和 notify() 实现线程间的等待通知机制；reen 使用Condition的 await() 和 signal() 实现</li>
<li>syn 自动释放 monitor，reen 需要显式调用unlock（）释放锁</li>
<li>syn 只能关联一个条件队列（waitset），reen可以关联多个条件队列（lock.newCondition()生成多个 condition 对象）</li>
</ol>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>syn 由于使用方便简单，建议在竞争不激烈的时候使用。在竞争激烈的时候 reen 性能会好点</p>
<p>reen 由于具有 syn 所不具有的灵活性、可中断、有限等待等特性，可以用于时间锁等待、可中断锁等待</p>
<h2 id="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"><a href="#CountdownLatch和CyclicBarrier的区别使用场景与具体实现" class="headerlink" title="CountdownLatch和CyclicBarrier的区别使用场景与具体实现"></a>CountdownLatch和CyclicBarrier的区别使用场景与具体实现</h2><p>CountdownLatch和CyclicBarrier都属于线程同步的工具</p>
<h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>顾名思义CountdownLatch可以当做一个<strong>计数器</strong>来使用,比如某线程需要等待其他几个线程都执行过某个时间节点后才能继续执行 我们来模拟一个场景,某公司一共有十个人,门卫要等十个人都来上班以后,才可以休息,代码实现如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"正在赶路"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"到公司了"</span>);</span><br><span class="line">                    <span class="comment">//调用latch的countDown方法使计数器-1</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"开始工作"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"门卫等待员工上班中..."</span>);</span><br><span class="line">            <span class="comment">//主线程阻塞等待计数器归零</span></span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">"员工都来了,门卫去休息了"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到子线程并没有因为调用latch.countDown而阻塞,会继续进行该做的工作,只是通知计数器-1,即完成了我们如上说的场景,只需要在所有进程都进行到某一节点后才会执行被阻塞的进程.如果我们想要多个线程在同一时间进行就要用到CyclicBarrier了</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CountDownLatch是共享锁的一种实现，通过 AQS 实现，内部使用 syn类。将 state 设置为 count。主要有两个重要方法countDown()和 await()，countDown()调用tryReleaseShared()以 CAS 的方式减少 state，直至 state 为 0 。调用 await()则是会一直阻塞线程，直至 state 为 0，线程才会被唤醒，执行后续语句。</p>
<p>我们先来看看CountdownLatch的构造方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> {</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>Sync是CountdownLatch的静态内部类,继承了AbstractQueuedSynchronizer(即AQS,提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的工具,回头单讲)抽象类, 在Sync的构造方法中,调用了setState方法,可以视作初始化了一个标记来记录当前计数器的数量</p>
<p>CountdownLatch的两个核心方法,await和countdown,先来看await</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">//可以视作将线程阻塞</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>await调用的是AQS的方法,可以视作阻塞线程</p>
<p>countdown方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> {</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>调用了sync的一个方法,再来看看这个方法的实现</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> {</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) {</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>再来看这个tryReleaseShared方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> {</span><br><span class="line">            <span class="keyword">for</span> (;;) {</span><br><span class="line">                <span class="comment">//获取标记位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//用cas的方式更新标记位</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到在调用tryReleaseShared实际上是将标记位-1并且返回标记位是否为0,如果标记位为0 那么调用的doReleaseShared可以视作将阻塞的线程放行,这样整个的流程就通了</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>我们重新模拟一个新的场景,就用已经被说烂的跑步场景吧,十名运动员各自准备比赛,需要等待所有运动员都准备好以后,裁判才能说开始然后所有运动员一起跑,代码实现如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>,()-&gt;{</span><br><span class="line">            System.out.println(<span class="string">"所有人都准备好了裁判开始了"</span>);</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            <span class="comment">//lambda中只能只用final的变量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"正在准备"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> * times);</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"准备好了"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"开始跑了"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } <span class="keyword">catch</span> (BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到所有线程在其他线程没有准备好之前都在被阻塞中,等到所有线程都准备好了才继续执行 我们在创建CyclicBarrier对象时传入了一个方法,当调用CyclicBarrier的await方法后,当前线程会被阻塞等到所有线程都调用了await方法后 调用传入CyclicBarrier的方法,然后让所有的被阻塞的线程一起运行</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>CyclicBarrier是利用ReentrantLock的condition的 await()和 signalAll()来进行线程的阻塞和唤醒【类似Object.wait()和notifyAll()】在count不为0时阻塞,在count=0时唤醒所有线程</p>
<p><img src="/../pic/0dde2d343b11b15140fcfec3ef247eba.png" alt="img"></p>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><ul>
<li>CountDownLatch减计数，CyclicBarrier加计数。</li>
<li>CountDownLatch是一次性的，CyclicBarrier可以重用。</li>
<li>CountDownLatch和CyclicBarrier都有让多个线程等待同步然后再开始下一步动作的意思，但是CountDownLatch的下一步的动作实施者是主线程，具有不可重复性；而CyclicBarrier的下一步动作实施者还是“其他线程”本身，具有往复多次实施动作的特点。</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池、为什么要用、底层实现"><a href="#什么是线程池、为什么要用、底层实现" class="headerlink" title="什么是线程池、为什么要用、底层实现"></a>什么是线程池、为什么要用、底层实现</h3><p>线程池是一种池化技术，主要思想是资源复用。</p>
<p>优点：减少创建销毁的开销；任务响应快；限制线程数量，防止资源利用率过高</p>
<p>底层逻辑是使用<code>线程+阻塞队列</code>实现，队列中有任务线程就会消费，假如没有线程就会被阻塞，等待队列中新的任务的到来，假如队列满了，则会出发设定的<code>饱和策略</code>（包括抛出异常、原线程执行、丢弃任务、丢弃最早未处理任务）</p>
<p><img src="/../pic/java-thread-x-executors-1.png" alt="img"></p>
<h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit,</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler)</span></span><br></pre></td></tr></tbody></table></figure>

<p>一般使用 TreadPoolExecutor 建立线程池，有三个重要参数（核心线程数、最大线程数、阻塞队列）。不使用 Executors 去创建的原因：fixedThreadPool 阻塞队列的长度是 Integer.MAX_VALUE，cachedThreadPool 的线程数量最大是Integer.MAX_VALUE。都会导致 OOM</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><strong>workQueue</strong>: 用来保存等待被执行的任务的阻塞队列</p>
<ul>
<li><code>LinkedBlockingQueue</code>无界队列: 基于链表结构的阻塞队列，按FIFO排序任务；</li>
</ul>
<ul>
<li><code>SynchronousQueue</code>同步队列: 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM</li>
<li><code>DelayQueue</code>（延迟阻塞队列）：<code>DelayQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。</li>
</ul>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p><code>handler </code>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p>
<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>
</ul>
<h3 id="线程池处理任务的流程"><a href="#线程池处理任务的流程" class="headerlink" title="线程池处理任务的流程"></a>线程池处理任务的流程</h3><p><img src="/../pic/640.png" alt="图片"></p>
<p><code>submit()</code>or <code>execute()</code>一个任务的流程</p>
<p>当前线程数量&lt;核心线程数，新建线程处理任务</p>
<p>阻塞队列未满，加到阻塞队列等待执行</p>
<p>阻塞队列满&amp;当前线程数&lt;最大线程数，新建线程处理</p>
<p>达到最大线程数，使用饱和策略</p>
<h3 id="提交任务的方法"><a href="#提交任务的方法" class="headerlink" title="提交任务的方法"></a>提交任务的方法</h3><h4 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h4><p>submit()方法可以接收Callable、Runnable两种类型的参数</p>
<p>submit()方法也用于启动任务的执行，但是启动之后会返回Future对象，代表一个异步执行实例，可以通过该异步执行实例去获取结果。</p>
<p>submit()方法返回的Future对象（异步执行实例），可以进行异步执行过程中的异常捕获。</p>
<h4 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h4><p>Execute()方法只能接收Runnable类型的参数</p>
<p>execute()方法主要用于启动任务的执行，而任务的执行结果和可能的异常调用者并不关心。</p>
<p>execute()方法在启动任务执行后，任务执行过程中可能发生的异常调用者并不关心</p>
<h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>在ThreadPoolExecutor类的实现中，内部核心的任务提交方法是execute()方法，虽然用户程序通过submit()也可以提交任务，但是实际上submit()方法中最终调用的还是execute()方法。</p>
<blockquote>
<p>Callable类型的任务是可以返回执行结果的，而Runnable类型的任务不可以返回执行结果。</p>
<p>Runnable和Callable的主要区别为：Callable允许有返回值，Runnable不允许有返回值；Runnable不允许抛出异常，Callable允许抛出异常。</p>
</blockquote>
<h3 id="内置线程池类型"><a href="#内置线程池类型" class="headerlink" title="内置线程池类型"></a>内置线程池类型</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">	nThreads, </span><br><span class="line">	nThreads,</span><br><span class="line">	<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></tbody></table></figure>

<p>核心线程数和最大线程数一样，且线程没有过期时间，线程池的线程数量达corePoolSize后，即使线程池没有可执行任务时，也不会释放线程。</p>
<p>使用了<code>LinkedBlockingQueue</code>无界队列, 所以FixedThreadPool永远不会拒绝, 即饱和策略失效</p>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">		<span class="number">1</span>, </span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br></pre></td></tr></tbody></table></figure>

<p>初始化的线程池中只有一个线程</p>
<p>使用了<code>LinkedBlockingQueue</code>无界队列, 所以SingleThreadPool永远不会拒绝, 即饱和策略失效</p>
<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	Integer.MAX_VALUE,</span><br><span class="line">	<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></tbody></table></figure>

<p>最大线程数为Integer.MAX_VALUE</p>
<p>使用<code>SynchronousQueue</code>同步队列； 线程有过期时间，空闲会释放线程</p>
<h4 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>(</span><br><span class="line">	corePoolSize, </span><br><span class="line">	Integer.MAX_VALUE, </span><br><span class="line">	<span class="number">0</span>, NANOSECONDS,</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br></pre></td></tr></tbody></table></figure>

<p>最大线程数为Integer.MAX_VALUE</p>
<p>使用无界的<code>DelayedWorkQueue</code>延迟阻塞队列</p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>遍历线程池中的所有线程，然后逐个调用线程的interrupt方法来中断线程.</p>
<h4 id="关闭方式-shutdown"><a href="#关闭方式-shutdown" class="headerlink" title="关闭方式 - shutdown"></a>关闭方式 - shutdown</h4><p>将线程池里的线程状态设置成SHUTDOWN状态, 然后中断所有没有正在执行任务的线程.</p>
<h4 id="关闭方式-shutdownNow"><a href="#关闭方式-shutdownNow" class="headerlink" title="关闭方式 - shutdownNow"></a>关闭方式 - shutdownNow</h4><p>将线程池里的线程状态设置成STOP状态, 然后停止所有正在执行或暂停任务的线程. 只要调用这两个关闭方法中的任意一个, isShutDown() 返回true. 当所有任务都成功关闭了, isTerminated()返回true.</p>
<h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h3><p>==execute –&gt; addWorker –&gt;runworker (getTask)==</p>
<p><strong>addWorker方法</strong>：主要负责创建新的线程并执行任务 线程池创建新线程执行任务时，需要获取全局锁:</p>
<p>线程池的工作线程通过Woker类实现，启动线程本质是执行了Worker的runWorker方法。</p>
<p><strong>线程执行完任务怎么通知阻塞队列？</strong></p>
<p>firstTask执行完成之后，通过==getTask==方法从阻塞队列中获取等待的任务，如果队列中没有任务，getTask方法会被阻塞并挂起，不会占用cpu资源；</p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>是 JDK1.8 中引入的一个基于事件驱动的异步回调类。</p>
<p>当使用异步线程去执行一个任务时，在任务完成后触发一个后续动作。可以实现任务的编排，主要方法有：</p>
<ol>
<li>thenCombine。两个任务都执行结束后触发事件回调</li>
<li>thenCompose。第一个任务执行玩后自动触发执行第二个任务</li>
</ol>
</body></html></div><div class="article-licensing box"><div class="licensing-title"><p>并发</p><p><a href="https://jerryzhu1229.github.io/2024/03/12/并发/">https://jerryzhu1229.github.io/2024/03/12/并发/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jerry Z</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-04-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/03/12/JVM/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">JVM</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/12/%E9%9B%86%E5%90%88/"><span class="level-item">集合</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#线程基础"><span class="level-left"><span class="level-item">1</span><span class="level-item">线程基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#线程有哪几种状态-分别说明从一种状态到另一种状态转变有哪些方式"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?</span></span></a></li><li><a class="level is-mobile" href="#线程有哪几种创建方式"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">线程有哪几种创建方式?</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#方式一：继承于Thread类"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">方式一：继承于Thread类</span></span></a></li><li><a class="level is-mobile" href="#方式二：实现Runnable接口"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">方式二：实现Runnable接口</span></span></a></li><li><a class="level is-mobile" href="#方式三：实现Callable接口"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">方式三：实现Callable接口</span></span></a></li><li><a class="level is-mobile" href="#方式四：使用线程池"><span class="level-left"><span class="level-item">1.2.4</span><span class="level-item">方式四：使用线程池</span></span></a></li></ul></li><li><a class="level is-mobile" href="#基础线程机制有哪些"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">基础线程机制有哪些?</span></span></a></li><li><a class="level is-mobile" href="#线程的中断方式有哪些"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">线程的中断方式有哪些?</span></span></a></li><li><a class="level is-mobile" href="#线程的互斥同步方式有哪些-如何比较和选择"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">线程的互斥同步方式有哪些? 如何比较和选择?</span></span></a></li><li><a class="level is-mobile" href="#线程之间有哪些协作方式"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">线程之间有哪些协作方式?</span></span></a></li></ul></li><li><a class="level is-mobile" href="#乐观锁-悲观锁"><span class="level-left"><span class="level-item">2</span><span class="level-item">乐观锁&amp;&amp;悲观锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#乐观锁"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">乐观锁</span></span></a></li><li><a class="level is-mobile" href="#悲观锁"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">悲观锁</span></span></a></li><li><a class="level is-mobile" href="#CAS-的问题"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">CAS 的问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Synchronized"><span class="level-left"><span class="level-item">3</span><span class="level-item">**Synchronized</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Synchronized-可以作用在哪"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Synchronized 可以作用在哪</span></span></a></li><li><a class="level is-mobile" href="#Synchronized本质上是通过什么保证线程安全的"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Synchronized本质上是通过什么保证线程安全的</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#加锁、释放锁原理"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">加锁、释放锁原理</span></span></a></li><li><a class="level is-mobile" href="#可重入原理"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">可重入原理</span></span></a></li><li><a class="level is-mobile" href="#保证可见性原理"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">保证可见性原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#锁的升级"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">**锁的升级</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用场景"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">应用场景</span></span></a></li><li><a class="level is-mobile" href="#偏向锁"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">偏向锁</span></span></a></li><li><a class="level is-mobile" href="#轻量级锁"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">轻量级锁</span></span></a></li><li><a class="level is-mobile" href="#重量级锁"><span class="level-left"><span class="level-item">3.3.4</span><span class="level-item">重量级锁</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Synchronized有什么样的缺陷？Lock解决相应问题？如何选择？"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Synchronized有什么样的缺陷？Lock解决相应问题？如何选择？</span></span></a></li><li><a class="level is-mobile" href="#Synchronized在使用时有何注意事项"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">Synchronized在使用时有何注意事项?</span></span></a></li><li><a class="level is-mobile" href="#多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程?</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AQS"><span class="level-left"><span class="level-item">4</span><span class="level-item">AQS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#AQS核心思想？如何实现？底层数据结构？"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">AQS核心思想？如何实现？底层数据结构？</span></span></a></li><li><a class="level is-mobile" href="#AQS定义什么样的资源获取方式"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">AQS定义什么样的资源获取方式?</span></span></a></li><li><a class="level is-mobile" href="#AQS有哪些核心的方法"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">AQS有哪些核心的方法?</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#acquire"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">acquire</span></span></a></li><li><a class="level is-mobile" href="#release"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">release</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#ReentrantLock"><span class="level-left"><span class="level-item">5</span><span class="level-item">**ReentrantLock</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#流程"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">流程</span></span></a></li><li><a class="level is-mobile" href="#如何实现可重入"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">如何实现可重入</span></span></a></li><li><a class="level is-mobile" href="#有公平锁和非公平锁两种"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">有公平锁和非公平锁两种</span></span></a></li><li><a class="level is-mobile" href="#三个内部类："><span class="level-left"><span class="level-item">5.4</span><span class="level-item">三个内部类：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ReentrantLock和-Synchornized-关系"><span class="level-left"><span class="level-item">6</span><span class="level-item">ReentrantLock和 Synchornized 关系</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#相同"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">相同</span></span></a></li><li><a class="level is-mobile" href="#不同"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">不同</span></span></a></li><li><a class="level is-mobile" href="#应用场景-1"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">应用场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CountdownLatch和CyclicBarrier的区别使用场景与具体实现"><span class="level-left"><span class="level-item">7</span><span class="level-item">CountdownLatch和CyclicBarrier的区别使用场景与具体实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#CountdownLatch"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">CountdownLatch</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用场景"><span class="level-left"><span class="level-item">7.1.1</span><span class="level-item">使用场景</span></span></a></li><li><a class="level is-mobile" href="#原理"><span class="level-left"><span class="level-item">7.1.2</span><span class="level-item">原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CyclicBarrier"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">CyclicBarrier</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用场景-1"><span class="level-left"><span class="level-item">7.2.1</span><span class="level-item">使用场景</span></span></a></li><li><a class="level is-mobile" href="#原理-1"><span class="level-left"><span class="level-item">7.2.2</span><span class="level-item">原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二者区别"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">二者区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#线程池"><span class="level-left"><span class="level-item">8</span><span class="level-item">线程池</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是线程池、为什么要用、底层实现"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">什么是线程池、为什么要用、底层实现</span></span></a></li><li><a class="level is-mobile" href="#如何创建"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">如何创建</span></span></a></li><li><a class="level is-mobile" href="#阻塞队列"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">阻塞队列</span></span></a></li><li><a class="level is-mobile" href="#饱和策略"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">饱和策略</span></span></a></li><li><a class="level is-mobile" href="#线程池处理任务的流程"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">线程池处理任务的流程</span></span></a></li><li><a class="level is-mobile" href="#提交任务的方法"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">提交任务的方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#submit"><span class="level-left"><span class="level-item">8.6.1</span><span class="level-item">submit()</span></span></a></li><li><a class="level is-mobile" href="#execute"><span class="level-left"><span class="level-item">8.6.2</span><span class="level-item">execute()</span></span></a></li><li><a class="level is-mobile" href="#联系"><span class="level-left"><span class="level-item">8.6.3</span><span class="level-item">联系</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内置线程池类型"><span class="level-left"><span class="level-item">8.7</span><span class="level-item">内置线程池类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#FixedThreadPool"><span class="level-left"><span class="level-item">8.7.1</span><span class="level-item">FixedThreadPool</span></span></a></li><li><a class="level is-mobile" href="#SingleThreadExecutor"><span class="level-left"><span class="level-item">8.7.2</span><span class="level-item">SingleThreadExecutor</span></span></a></li><li><a class="level is-mobile" href="#CachedThreadPool"><span class="level-left"><span class="level-item">8.7.3</span><span class="level-item">CachedThreadPool</span></span></a></li><li><a class="level is-mobile" href="#ScheduledThreadPool"><span class="level-left"><span class="level-item">8.7.4</span><span class="level-item">ScheduledThreadPool</span></span></a></li></ul></li><li><a class="level is-mobile" href="#关闭线程池"><span class="level-left"><span class="level-item">8.8</span><span class="level-item">关闭线程池</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关闭方式-shutdown"><span class="level-left"><span class="level-item">8.8.1</span><span class="level-item">关闭方式 - shutdown</span></span></a></li><li><a class="level is-mobile" href="#关闭方式-shutdownNow"><span class="level-left"><span class="level-item">8.8.2</span><span class="level-item">关闭方式 - shutdownNow</span></span></a></li></ul></li><li><a class="level is-mobile" href="#任务的执行"><span class="level-left"><span class="level-item">8.9</span><span class="level-item">任务的执行</span></span></a></li></ul></li><li><a class="level is-mobile" href="#CompletableFuture"><span class="level-left"><span class="level-item">9</span><span class="level-item">CompletableFuture</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/cs/"><span class="level-start"><span class="level-item">cs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a><p class="is-size-7"><span>&copy; 2024 Jerry Z</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>