<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>MySQL基础原理 - hao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="hao"><meta name="msapplication-TileImage" content="/img/2751710164138_.pic.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="hao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="hao"><meta property="og:url" content="https://jerryzhu1229.github.io/2024/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="hao"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center-20240315213232594.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center-20240315221648863.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center-20240315221737005.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/Center-20240315221810273.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/image-20240820114027032.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70-20240330214648097.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1721709935338-fe01a58d-da89-47b5-9288-0f0e966937ca.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/929817-20210424100143998-788227492.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/d37bfa1678eb71ae7e33dc8f211d1ec1.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1717913436378-906c5ccf-b284-4fa8-89ea-3e832afd7cc9.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1717913436386-ec8e4aa9-6bd9-4555-9802-c18567b762df.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1717913436123-4db9c815-cc4b-4861-b2ff-3a293e37416d.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/cce766a69dea725cd8f19b90db2d0430.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/4e98ea2e60923b969790898565b4d643.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/readview%E7%BB%93%E6%9E%84.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/f595d13450878acd04affa82731f76c5.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/a463e5d8f8493c4696716e44e96748af-20240324212007851.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/ReadView.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1720433609532-38aec7fc-734e-4b35-a802-4e6ba3339ffa.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/x%E9%94%81%E5%92%8Cs%E9%94%81.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E15.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E6.drawio-20240331091327727.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/90c1e01d0345de639e3426cea0390e80.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E5%AD%97%E8%8A%82mysql%E9%9D%A2%E8%AF%95%E9%A2%98.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1711526947543-96b555cc-646f-4194-b2b3-343b3b6dd769.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1717920811388-2146eb90-98bd-4b2d-b6a8-9c207fbdacc4.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/wal.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/innodb_flush_log_at_trx_commit.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/innodb_flush_log_at_trx_commit2.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/checkpoint.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/binlogcache.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/1720420604941-9fafd933-6a90-4f02-a23c-0e577790f040.webp"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/mybatis-y-arch-4.png"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/fb8f06d7d8c544c8a9bf1885c44bf3be.png"><meta property="article:published_time" content="2024-03-12T01:59:08.000Z"><meta property="article:modified_time" content="2024-09-17T02:52:38.000Z"><meta property="article:author" content="Jerry Z"><meta property="article:tag" content="面经"><meta property="article:tag" content="mysql"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jerryzhu1229.github.io/pic/Center.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerryzhu1229.github.io/2024/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"},"headline":"MySQL基础原理","image":["https://jerryzhu1229.github.io/pic/Center.png","https://jerryzhu1229.github.io/pic/Center-20240315213232594.png","https://jerryzhu1229.github.io/pic/Center-20240315221648863.png","https://jerryzhu1229.github.io/pic/Center-20240315221737005.png","https://jerryzhu1229.github.io/pic/Center-20240315221810273.png","https://jerryzhu1229.github.io/pic/image-20240820114027032.png","https://jerryzhu1229.github.io/pic/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70-20240330214648097.png","https://jerryzhu1229.github.io/pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70.png","https://jerryzhu1229.github.io/pic/1721709935338-fe01a58d-da89-47b5-9288-0f0e966937ca.png","https://jerryzhu1229.github.io/pic/929817-20210424100143998-788227492.png","https://jerryzhu1229.github.io/pic/d37bfa1678eb71ae7e33dc8f211d1ec1.png","https://jerryzhu1229.github.io/pic/1717913436378-906c5ccf-b284-4fa8-89ea-3e832afd7cc9.png","https://jerryzhu1229.github.io/pic/1717913436386-ec8e4aa9-6bd9-4555-9802-c18567b762df.png","https://jerryzhu1229.github.io/pic/1717913436123-4db9c815-cc4b-4861-b2ff-3a293e37416d.png","https://jerryzhu1229.github.io/pic/cce766a69dea725cd8f19b90db2d0430.png","https://jerryzhu1229.github.io/pic/4e98ea2e60923b969790898565b4d643.png","https://jerryzhu1229.github.io/pic/readview%E7%BB%93%E6%9E%84.drawio.png","https://jerryzhu1229.github.io/pic/f595d13450878acd04affa82731f76c5.png","https://jerryzhu1229.github.io/pic/a463e5d8f8493c4696716e44e96748af-20240324212007851.png","https://jerryzhu1229.github.io/pic/ReadView.drawio.png","https://jerryzhu1229.github.io/pic/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png","https://jerryzhu1229.github.io/pic/1720433609532-38aec7fc-734e-4b35-a802-4e6ba3339ffa.png","https://jerryzhu1229.github.io/pic/x%E9%94%81%E5%92%8Cs%E9%94%81.png","https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png","https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png","https://jerryzhu1229.github.io/pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E15.drawio.png","https://jerryzhu1229.github.io/pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E6.drawio-20240331091327727.png","https://jerryzhu1229.github.io/pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png","https://jerryzhu1229.github.io/pic/90c1e01d0345de639e3426cea0390e80.png","https://jerryzhu1229.github.io/pic/%E5%AD%97%E8%8A%82mysql%E9%9D%A2%E8%AF%95%E9%A2%98.png","https://jerryzhu1229.github.io/pic/1711526947543-96b555cc-646f-4194-b2b3-343b3b6dd769.png","https://jerryzhu1229.github.io/pic/1717920811388-2146eb90-98bd-4b2d-b6a8-9c207fbdacc4.png","https://jerryzhu1229.github.io/pic/wal.png","https://jerryzhu1229.github.io/pic/innodb_flush_log_at_trx_commit.drawio.png","https://jerryzhu1229.github.io/pic/innodb_flush_log_at_trx_commit2.drawio.png","https://jerryzhu1229.github.io/pic/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png","https://jerryzhu1229.github.io/pic/checkpoint.png","https://jerryzhu1229.github.io/pic/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png","https://jerryzhu1229.github.io/pic/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png","https://jerryzhu1229.github.io/pic/binlogcache.drawio.png","https://jerryzhu1229.github.io/pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png","https://jerryzhu1229.github.io/pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png","https://jerryzhu1229.github.io/pic/1720420604941-9fafd933-6a90-4f02-a23c-0e577790f040.webp","https://jerryzhu1229.github.io/pic/mybatis-y-arch-4.png","https://jerryzhu1229.github.io/pic/fb8f06d7d8c544c8a9bf1885c44bf3be.png"],"datePublished":"2024-03-12T01:59:08.000Z","dateModified":"2024-09-17T02:52:38.000Z","author":{"@type":"Person","name":"Jerry Z"},"publisher":{"@type":"Organization","name":"hao","logo":{"@type":"ImageObject","url":"https://jerryzhu1229.github.io/img/2751710164138_.pic.jpg"}},"description":""}</script><link rel="canonical" href="https://jerryzhu1229.github.io/2024/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"><link rel="icon" href="/img/2751710164138_.pic.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/cs">计算机基础</a><a class="navbar-item" href="/categories/java">后端开发</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jerryzhu1229"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-12T01:59:08.000Z" title="2024/3/12 09:59:08">2024-03-12</time>发表</span><span class="level-item"><time dateTime="2024-09-17T02:52:38.000Z" title="2024/9/17 10:52:38">2024-09-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/mysql/">mysql</a></span><span class="level-item">3 小时读完 (大约22863个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">MySQL基础原理</h1><div class="content"><html><head></head><body><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="SQL-和-NOSQL-区别"><a href="#SQL-和-NOSQL-区别" class="headerlink" title="SQL 和 NOSQL 区别"></a>SQL 和 NOSQL 区别</h2><ul>
<li><p>ACID vs BASE</p>
<p>关系型数据库支持 ACID 即原子性，一致性，隔离性和持续性。相对而言，NoSQL 采用更宽松的模型 BASE ， 即基本可用，软状态和最终一致性。</p>
</li>
<li><p>扩展性对比</p>
<p>NoSQL数据之间无关系，这样就非常容易扩展。相反关系型数据库的数据之间存在关联性，水平扩展较难。</p>
</li>
</ul>
<h2 id="三大范式✨"><a href="#三大范式✨" class="headerlink" title="三大范式✨"></a>三大范式✨</h2><p>第一范式（1NF)：每列的原子性【不可再分】</p>
<p>第二范式（2NF)：确保表中每列与主键相关，而不能只与主键的某部分相关<strong>（主要针对联合主键而言）</strong>【消除部分函数依赖】</p>
<p>第三范式（3NF):  非主属性不依赖于其他非主属性【消除传递依赖】</p>
<h2 id="MySQL如何避免重复插入数据？"><a href="#MySQL如何避免重复插入数据？" class="headerlink" title="MySQL如何避免重复插入数据？"></a>MySQL如何避免重复插入数据？</h2><ul>
<li><p>建表时，使用 UNIQUE 约束</p>
<p>在表的相关列上添加UNIQUE约束，确保每个值在该列中唯一</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>插入时，使用 insert …… on duplicate key update</p>
<p>这种语句允许在插入记录时处理重复键的情况。如果插入的记录与现有记录冲突，可以选择更新现有记录</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (email, name) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'example@example.com'</span>, <span class="string">'John Doe'</span>)</span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> name <span class="operator">=</span> <span class="keyword">VALUES</span>(name);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>插入时，使用 insert ignore </p>
<p>该语句会在插入记录时忽略那些因重复键而导致的插入错误</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> users (email, name) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'example@example.com'</span>, <span class="string">'John Doe'</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>总结</strong>：</p>
<p>选择哪种方法取决于具体的需求：</p>
<ul>
<li>如果需要保证全局唯一性，使用UNIQUE约束是最佳做法。</li>
<li>如果需要插入和更新结合可以使用<code>ON DUPLICATE KEY UPDATE</code>。</li>
<li>对于快速忽略重复插入，<code>INSERT IGNORE</code>是合适的选择。</li>
</ul>
<h2 id="CHAR-和-VARCHAR有什么区别？"><a href="#CHAR-和-VARCHAR有什么区别？" class="headerlink" title="CHAR 和 VARCHAR有什么区别？"></a>CHAR 和 VARCHAR有什么区别？</h2><ul>
<li>CHAR是固定长度的字符串类型，定义时需要指定固定长度，存储时会在末尾补足空格。CHAR适合存储长度固定的数据，如固定长度的代码、状态等，存储空间固定，对于短字符串效率较高。</li>
<li>VARCHAR是可变长度的字符串类型，定义时需要指定最大长度，实际存储时根据实际长度占用存储空间。VARCHAR适合存储长度可变的数据，如用户输入的文本、备注等，节约存储空间。</li>
</ul>
<h2 id="Text数据类型可以无限大吗？"><a href="#Text数据类型可以无限大吗？" class="headerlink" title="Text数据类型可以无限大吗？"></a>Text数据类型可以无限大吗？</h2><p>MySQL 3 种text类型的最大长度如下：</p>
<ul>
<li>TEXT：65,535 bytes ~64kb</li>
<li>MEDIUMTEXT：16,777,215 bytes ~16Mb</li>
<li>LONGTEXT：4,294,967,295 bytes ~4Gb</li>
</ul>
<h2 id="说一下外键约束"><a href="#说一下外键约束" class="headerlink" title="说一下外键约束"></a>说一下外键约束</h2><p>外键约束的作用是维护表与表之间的关系，确保数据的完整性和一致性。</p>
<p>比如，<code>students</code>表中的<code>course_id</code>字段是一个外键，它指向<code>courses</code>表中的<code>id</code>字段。这个外键约束确保了每个学生所选的课程在<code>courses</code>表中都存在，从而维护了数据的完整性和一致性。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  course_id <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (course_id) <span class="keyword">REFERENCES</span> courses(id)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>



<h2 id="多表查询（各种join连接详解）"><a href="#多表查询（各种join连接详解）" class="headerlink" title="多表查询（各种join连接详解）"></a>多表查询（各种join连接详解）</h2><p><strong>A）内连接：join=inner join</strong></p>
<p><strong>B）外连接：left join=left outer join，right join=right outer join，union</strong></p>
<p><strong>C）交叉连接：cross join</strong></p>
<p><strong>2.1 内连接（只有一种场景）</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.*, b.* from tablea a</span><br><span class="line">inner join tableb b</span><br><span class="line">on a.id = b.id</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这种场景下得到的是满足某一条件的A，B内部的数据；正因为得到的是内部共有数据，所以连接方式称为内连接。</strong></p>
<p><img src="/../../pic/Center.png" alt="img"></p>
<p><strong>2.2 外连接（六种场景）</strong></p>
<p><strong>2.2.1 left join 或者left outer join(等同于left join)</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.*, b.* from tablea a</span><br><span class="line">left outer join tableb b</span><br><span class="line">on a.id = b.id</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../pic/Center-20240315213232594.png" alt="img"></p>
<p>左外连接返回左表中的所有行，即使在右表中没有匹配的行。未匹配的右表列会包含NULL</p>
<p><strong>2.2.2  [ left  join 或者left outer join(等同于left join) ]  +  [ where B.column is null ]</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">left join tableb b</span><br><span class="line">on a.id = b.id</span><br><span class="line">Where b.id is null</span><br></pre></td></tr></tbody></table></figure>

<p>left join表a的数据全部显示，匹配表b的数据也显示，而b.id再次过滤掉 表b的id为空的。</p>
<p><img src="/../../pic/Center-20240315221648863.png" alt="img"></p>
<p><strong>2.2.3  right join 或者right outer join(等同于right join)</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">right join tableb b</span><br><span class="line">on a.id = b.id</span><br></pre></td></tr></tbody></table></figure>



<p><strong>2.2.5 full join （mysql不支持，但是可以用 left join  union right join代替）</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">left join tableb b</span><br><span class="line">on a.id = b.id</span><br><span class="line">union</span><br><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">right join tableb b</span><br><span class="line">on a.id = b.id</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../pic/Center-20240315221737005.png" alt="img"></p>
<p><strong>这种场景下得到的是满足某一条件的公共记录，和独有的记录</strong></p>
<p><strong>2.2.6 full join + is null（mysql不支持，但是可以用 （left join + is null） union （right join+is null代替）</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">left join tableb b</span><br><span class="line">on a.id = b.id</span><br><span class="line">where b.id is null</span><br><span class="line">union</span><br><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">right join tableb b</span><br><span class="line">on a.id = b.id</span><br><span class="line">where a.id is null</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../pic/Center-20240315221810273.png" alt="img"></p>
<p><strong>2.3 交叉连接 （cross join）</strong></p>
<p><strong>2.3.1 实际应用中还有这样一种情形，想得到A，B记录的排列组合，即笛卡儿积，这个就不好用集合和元素来表示了。需要用到cross join：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">cross join tableb b</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2.3.2 还可以为cross  join指定条件 （where）：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select a.id aid,a.age,b.id bid,b.name from tablea a</span><br><span class="line">cross join tableb b</span><br><span class="line">where a.id = b.id</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这种情况下实际上实现了内连接的效果</strong></p>
<h2 id="MySQL的关键字in和exist"><a href="#MySQL的关键字in和exist" class="headerlink" title="MySQL的关键字in和exist"></a>MySQL的关键字in和exist</h2><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><p><code>IN</code> 用于检查左边的表达式是否存在于右边的列表或子查询的结果集中。如果存在，则<code>IN</code> 返回<code>TRUE</code>，否则返回<code>FALSE</code>。</p>
<h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><p><code>EXISTS</code> 用于判断子查询是否至少能返回一行数据。它不关心子查询返回什么数据，只关心是否有结果。如果子查询有结果，则<code>EXISTS</code> 返回<code>TRUE</code>，否则返回<code>FALSE</code>。</p>
<p>一种通俗的可以理解为：<strong>将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果取非空值，则EXISTS子句返回TRUE。</strong></p>
<p><strong>总结</strong></p>
<p>相同点：<code>IN</code> 和 <code>EXISTS</code> 都是用来处理子查询的关键词</p>
<p>区别与选择：</p>
<ul>
<li><strong>性能差异</strong>：在很多情况下，<code>EXISTS</code> 的性能优于 <code>IN</code>，特别是当子查询的表很大时。<strong>这是因为<code>EXISTS</code> 一旦找到匹配项就会立即停止查询，而<code>IN</code>可能会扫描整个子查询结果集。</strong></li>
<li><strong>使用场景</strong>：如果子查询结果集较小且不频繁变动，<code>IN</code> 可能更直观易懂。而当子查询涉及外部查询的每一行判断，并且子查询的效率较高时，<code>EXISTS</code> 更为合适。</li>
<li><strong>NULL值处理</strong>：<code>IN</code> 能够正确处理子查询中包含NULL值的情况，而<code>EXISTS</code> 不受子查询结果中NULL值的影响，因为它关注的是行的存在性，而不是具体值。</li>
</ul>
<h2 id="SQL查询语句的执行顺序是怎么样的？"><a href="#SQL查询语句的执行顺序是怎么样的？" class="headerlink" title="SQL查询语句的执行顺序是怎么样的？"></a><strong>SQL查询语句的执行顺序是怎么样的？</strong></h2><p><img src="/../pic/image-20240820114027032.png" alt="SQL查询语句的执行顺序"></p>
<p>所有的查询语句都是从FROM开始执行，在执行过程中，每个步骤都会生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入，最后一个步骤产生的虚拟表即为输出结果。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">9</span>) <span class="keyword">SELECT</span> </span><br><span class="line">(<span class="number">10</span>) <span class="keyword">DISTINCT</span> <span class="operator">&lt;</span><span class="keyword">column</span><span class="operator">&gt;</span>,</span><br><span class="line">(<span class="number">6</span>) AGG_FUNC <span class="operator">&lt;</span><span class="keyword">column</span><span class="operator">&gt;</span> <span class="keyword">or</span> <span class="operator">&lt;</span>expression<span class="operator">&gt;</span>, ...</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">FROM</span> <span class="operator">&lt;</span>left_table<span class="operator">&gt;</span> </span><br><span class="line">    (<span class="number">3</span>) <span class="operator">&lt;</span>join_type<span class="operator">&gt;</span><span class="keyword">JOIN</span><span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line">    (<span class="number">2</span>) <span class="keyword">ON</span><span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">4</span>) <span class="keyword">WHERE</span> <span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">5</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">7</span>) <span class="keyword">WITH</span> {<span class="keyword">CUBE</span><span class="operator">|</span><span class="keyword">ROLLUP</span>}</span><br><span class="line">(<span class="number">8</span>) <span class="keyword">HAVING</span> <span class="operator">&lt;</span>having_condtion<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">11</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>order_by_list<span class="operator">&gt;</span></span><br><span class="line">(<span class="number">12</span>) LIMIT <span class="operator">&lt;</span>limit_number<span class="operator">&gt;</span>;</span><br></pre></td></tr></tbody></table></figure>



<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="执行一条-SQL-查询语句，期间发生了什么-✨"><a href="#执行一条-SQL-查询语句，期间发生了什么-✨" class="headerlink" title="执行一条 SQL 查询语句，期间发生了什么?✨"></a>执行一条 SQL 查询语句，期间发生了什么?✨</h2><ul>
<li><p>连接器：建立连接、管理链接、校验个人身份</p>
</li>
<li><p>查询缓存：key-value形式——查询语句是否命中</p>
</li>
<li><p>解析器：词法解析、语法解析，建立语法树</p>
</li>
<li><p>执行 SQL：</p>
<ul>
<li>预处理阶段：判断是否存在表面、字段名；将*替换成全部列</li>
<li>优化阶段：基于查询成本，选择最佳的执行计划</li>
<li>执行阶段：根据执行计划执行 SQL查询语句，从存储引擎读取记录，返回给客户端</li>
</ul>
</li>
</ul>
<p><img src="/../../pic/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p>
<h2 id="MySQL-一行记录是怎么存储的？"><a href="#MySQL-一行记录是怎么存储的？" class="headerlink" title="MySQL 一行记录是怎么存储的？"></a>MySQL 一行记录是怎么存储的？</h2><blockquote>
<p>MySQL 的 NULL 值是怎么存放的？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p>
<p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p>
<blockquote>
<p>MySQL 怎么知道 varchar(n) 实际占用数据的大小？</p>
</blockquote>
<p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p>
<blockquote>
<p>varchar(n) 中 n 最大取值为多少？</p>
</blockquote>
<p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p>
<p>如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。</p>
<p>计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。</p>
<p>如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535。</p>
<blockquote>
<p>行溢出后，MySQL 是怎么处理的？</p>
</blockquote>
<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p>
<p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p>
<p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p>
<h2 id="MySql-数据的存储结构✨"><a href="#MySql-数据的存储结构✨" class="headerlink" title="MySql 数据的存储结构✨"></a>MySql 数据的存储结构✨</h2><p>聚簇索引（Innodb）和非聚簇索引（myISAM）</p>
<p><strong>对于InnoDB引擎来说，是按照聚簇索引的形式存储数据</strong></p>
<p><img src="/../../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p><strong>对于MyISAM引擎来说，是按照非聚簇索引的形式存储数据：</strong></p>
<p><img src="/../../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70-20240330214648097.png" alt="img"></p>
<p>存储引擎是InnoDB, 在data目录下会看到2类文件：.frm、.ibd<br>（1）.frm–表结构的文件。<br>（2）.ibd–表数据文件</p>
<p>存储引擎是MyISAM, 在data目录下会看到3类文件：.frm、.myi、.myd<br>（1）.frm–表定义，是描述表结构的文件。<br>（2）.MYD–”D”数据信息文件，是表的数据文件。<br>（3）.MYI–”I”索引信息文件，是表数据文件中任何索引的数据树</p>
<p>聚簇索引和非聚簇索引的存储方式区别：</p>
<ul>
<li>在MyISAM引擎索引和数据是分开存储的，而InnoDB是索引和数据是一起以idb文件的形式进行存储的。</li>
<li>在访问速度上，聚簇索引比非聚簇索引快。非聚簇索引需要先查询一遍索引文件，得到索引，跟据索引获取数据。而聚簇索引的索引树的叶子节点的直接指向要查找的数据行。</li>
</ul>
<h2 id="MyISAM-和-InnoDB-✨"><a href="#MyISAM-和-InnoDB-✨" class="headerlink" title="MyISAM 和 InnoDB ✨"></a>MyISAM 和 InnoDB ✨</h2><h3 id="MyISAM-和-InnoDB有什么区别？"><a href="#MyISAM-和-InnoDB有什么区别？" class="headerlink" title="MyISAM 和 InnoDB有什么区别？"></a>MyISAM 和 InnoDB有什么区别？</h3><ol>
<li>事务支持：MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。（默认引擎更换重要原因）</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>表锁差异：InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度(一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限)</li>
<li>读写过程：MyISAM在读写过程中相互阻塞；InnoDB读写阻塞与事务隔离级别相关</li>
<li>读写性能：MyISAM读取性能优越，但是写入性能差（如果执行大量的select，MyISAM是更好的选择）；InnoDB写入性能较强（如果执行大量的insert或者update，InnoDB是更好的选择）</li>
<li>外键支持：MyISAM 不支持外键，而 InnoDB 支持。</li>
<li>存储结构：MyISAM 不支持聚簇索引（数据保存在连续内存中，数据文件是分离的，索引保存的是数据文件的指针, 主键索引：主键列值+行号，二级索引：索引列值+行号）；InnoDB 的数据是存储在主键索引==聚簇索引中</li>
</ol>
<h3 id="innoDB-比-MyISAM-好在哪？为什么是默认引擎"><a href="#innoDB-比-MyISAM-好在哪？为什么是默认引擎" class="headerlink" title="innoDB 比 MyISAM 好在哪？为什么是默认引擎"></a>innoDB 比 MyISAM 好在哪？为什么是默认引擎</h3><p>事务支持</p>
<p>表锁差异</p>
<p>外键支持</p>
<p>数据库异常崩溃后的安全恢复(redolog日志进行崩溃恢复)</p>
<h3 id="各自适合什么场景"><a href="#各自适合什么场景" class="headerlink" title="各自适合什么场景"></a>各自适合什么场景</h3><p>MyISAM读取性能优越，但是写入性能差（如果执行大量的select，MyISAM是更好的选择）；</p>
<p>InnoDB写入性能较强（如果执行大量的insert或者update，InnoDB是更好的选择）</p>
<p>Memory：Memory引擎将数据存储在内存中，适用于对性能要求较高的读操作，但是在服务器重启或崩溃时数据会丢失。它不支持事务、行级锁和外键约束</p>
<h2 id="InnoDB的底层结构"><a href="#InnoDB的底层结构" class="headerlink" title="InnoDB的底层结构"></a>InnoDB的底层结构</h2><p>InnoDB的底层结构主要由2部分组成：内存结构和磁盘结构。</p>
<p><img src="/../../pic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMDE0MDc0Nzk0,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>2、内存结构由缓冲池（Buffer Pool），写缓冲（Change Buffer），日志缓冲（ Log Buffer），自适应hash索引（Adaptive Hash Index）组成。<br>3、缓冲池（Buffer Pool）主要是缓存表数据与索引数据，加快访问速度。内部采用基于LRU算法的变体算法来管理缓存对象。<br>4、写缓冲（Change Buffer）主要是缓存辅助索引的更新操作，加快辅助索引的更新速度。<br>5、日志缓冲（ Log Buffer）使大型事务可以运行，而无需在事务提交之前将redo日志数据写入磁盘，节省了磁盘I/O。注意事务提交时刷redo log有三种策略。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引的分类是什么？"><a href="#索引的分类是什么？" class="headerlink" title="索引的分类是什么？"></a>索引的分类是什么？</h2><p>按照数据结构:</p>
<ul>
<li>B+树索引</li>
<li>hash索引</li>
<li>full-text索引</li>
</ul>
<p>按照物理存储:</p>
<ul>
<li>聚簇索引</li>
<li>二级索引</li>
</ul>
<p>按照字段特性:</p>
<ul>
<li>主键索引</li>
<li>唯一索引</li>
<li>普通索引</li>
<li>前缀索引</li>
</ul>
<p>按照字段个数:</p>
<ul>
<li>单列索引</li>
<li>联合索引</li>
</ul>
<h2 id="聚簇索引与二级索引的区别✨"><a href="#聚簇索引与二级索引的区别✨" class="headerlink" title="聚簇索引与二级索引的区别✨"></a>聚簇索引与二级索引的区别✨</h2><ul>
<li><p>数据存储: <strong>聚簇索引</strong>是一种特殊类型的索引，它定义了表中数据的物理排序方式。在聚簇索引中，<strong>数据行按照索引的顺序存储在磁盘上</strong>。即数据行本身存储在聚簇索引中。</p>
</li>
<li><p>唯一性: 如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p>
</li>
<li><p>效率: 在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。所以, <strong>对于范围查询和排序查询, 聚簇索引通常更有效率</strong></p>
</li>
</ul>
<p><img src="/../../pic/1721709935338-fe01a58d-da89-47b5-9288-0f0e966937ca.png" alt="InnoDB 和 MyISAM 索引存储"></p>
<h2 id="为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？✨"><a href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？✨" class="headerlink" title="为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？✨"></a>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？✨</h2><h3 id="B-Tree-vs-B-Tree"><a href="#B-Tree-vs-B-Tree" class="headerlink" title="B+Tree vs B Tree"></a>B+Tree vs B Tree</h3><ol>
<li><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的非叶子节点能存放更多索引，因此 B+树更加「矮胖」，查询底层节点的<strong>磁盘 I/O 次数</strong>更少，查找的性能更加稳定</p>
</li>
<li><p>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的<strong>顺序查找</strong>，而 B 树需要通过遍历来完成范围查询，会涉及多个节点的磁盘 I/O，效率低。</p>
</li>
<li><p>B+ 树<strong>有大量的冗余节点</strong>（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</p>
</li>
</ol>
<h3 id="B-Tree-vs-二叉树"><a href="#B-Tree-vs-二叉树" class="headerlink" title="B+Tree vs 二叉树"></a>B+Tree vs 二叉树</h3><p>对于有 N 个叶子节点的 B+Tree，其<strong>搜索复杂度</strong>为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p>
<p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I/O 操作就能查询到目标数据。根节点可以包含的关键字数量范围是 [2, m-1]。 非根节点至少包含m/2个关键字，至多包含m-1个关键字。</p>
<p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的<strong>磁盘 I/O 次数要更多</strong>。</p>
<h3 id="B-Tree-vs-Hash"><a href="#B-Tree-vs-Hash" class="headerlink" title="B+Tree vs Hash"></a>B+Tree vs Hash</h3><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p>
<p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p>
<h2 id="B-树叶子节点数据如何存储，以及如何查找某一条数据✨"><a href="#B-树叶子节点数据如何存储，以及如何查找某一条数据✨" class="headerlink" title="B+树叶子节点数据如何存储，以及如何查找某一条数据✨"></a>B+树叶子节点数据如何存储，以及如何查找某一条数据✨</h2><p>数据库表中的数据都是存储在<strong>页</strong>里</p>
<p>一个页可以存放多少条记录取决于一行记录的大小是多少（假如一行数据大小是1k，那么理论上一页就可以放16条数据）</p>
<p>InnoDB 存储引擎通过 B+树来构建聚簇索引来查询数据：按照每张表的主键构造一颗B+树，<strong>叶子节点存放的是整行记录数据</strong>，在<strong>非叶子节点上存放的是键值以及指向数据页的指针</strong>，同时每个数据页之间都通过一个双向链表来进行链接。</p>
<p><img src="/../../pic/929817-20210424100143998-788227492.png" alt="聚簇索引B+树结构"></p>
<ol>
<li>数据记录按照主键排序，放在不同的页中。</li>
<li>当需要通过主键来查询时，先找到根页面（page offset=3），然后通过二分查找主键所在的页的指针</li>
<li>把所在页载入到内存，再通过二分查找定位到具体的记录</li>
</ol>
<h2 id="联合索引范围查询"><a href="#联合索引范围查询" class="headerlink" title="联合索引范围查询"></a>联合索引范围查询</h2><p>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</p>
<p>注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配 (对于符合=情况, 后面的字段是有序的, 因而不会停止匹配)</p>
<p>参考:[【MySQL | 第十篇】重新认识MySQL索引匹配过程-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_61440595/article/details/138393806#:~:text=%E6%AD%A3%E7%A1%AE%E7%BB%93%E8%AE%BA%EF%BC%9A,%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%8C%E5%9C%A8%E9%81%87%E5%88%B0%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%A6%82">https://blog.csdn.net/weixin_61440595/article/details/138393806#:~:text=正确结论：,联合索引的最左匹配原则，在遇到范围查询（如</a> &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。)</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><ul>
<li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li>
<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li>
</ul>
<h2 id="什么时候创建索引？✨"><a href="#什么时候创建索引？✨" class="headerlink" title="什么时候创建索引？✨"></a>什么时候创建索引？✨</h2><p>需要： 字段唯一；经常用于where查询、 groupby条件和 orderby条件 的字段</p>
<p>不需要：区分度小的；数据少的；经常更新的</p>
<blockquote>
<p>区分度:  指字段在数据库中的不重复比</p>
<p>区分度的计算规则如下:  字段去重后的总数与全表总记录数的商。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span>(name))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> t_base_user; </span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h2 id="有什么优化索引的方法？✨"><a href="#有什么优化索引的方法？✨" class="headerlink" title="有什么优化索引的方法？✨"></a>有什么优化索引的方法？✨</h2><ul>
<li><p>前缀索引优化；</p>
<p>提高索引的查询速度；减小索引项的大小</p>
</li>
<li><p>覆盖索引优化；</p>
<p>不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。</p>
</li>
<li><p>主键索引最好是自增的；</p>
<p>避免<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p>
</li>
<li><p>防止索引失效；</p>
<ul>
<li>使用<strong>左或者左右模糊匹配</strong>的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式</li>
<li>在查询条件中对索引列做了计算（+ - * /）、函数、类型转换操作</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，or 的前后字段都要上索引</li>
<li>列和列对比，这种情况会被认为还不如走全表扫描。</li>
<li>存在NULL值条件(is null/ is not null)，索引中无法存储NULL值，所以where条件判断如果对字段进行了NULL值判断（is NULL/ is not null），则数据库放弃索引而进行全表查询</li>
</ul>
</li>
</ul>
<h2 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h2><h3 id="SELECT-FROM-t-order-ORDER-BY-text-LIMIT-1000000-10"><a href="#SELECT-FROM-t-order-ORDER-BY-text-LIMIT-1000000-10" class="headerlink" title="SELECT * FROM t_order ORDER BY text LIMIT 1000000, 10"></a>SELECT * FROM t_order ORDER BY text LIMIT 1000000, 10</h3><p><strong>1、使用覆盖索引</strong></p>
<p>SELECT id, ‘text’ FROM t_order ORDER BY text LIMIT 1000000, 10</p>
<p>因为实际开发中，用SELECT查询一两列操作是非常少的，因此上述的覆盖索引的适用范围就比较有限。</p>
<p><strong>2、子查询优化</strong></p>
<p>可以通过把分页的SQL语句改写成子查询的方法获得性能上的提升。</p>
<p>SELECT * FROM t_order where id&gt;=(select id from t_order order by text limit 1000000, 1) LIMIT 10</p>
<p>但是这种优化方法也有局限性：这种写法，要求主键ID必须是连续的</p>
<p><strong>3、延迟关联</strong></p>
<p>和上述的子查询做法类似，我们可以使用JOIN，先在索引列上完成分页操作，然后再回表获取所需要的列。</p>
<p>SELECT a.* FROM t_order as a inner join ( select id from t_order order by text limit 1000000, 10) as b on a.id = b.id</p>
<p><strong>4、记录上次查询结束的位置</strong></p>
<p>和上面使用的方法都不同，记录上次结束位置优化思路是使用某种变量记录上一次数据的位置，下次分页时直接从这个变量的位置开始扫描，从而避免MySQL扫描大量的数据再抛弃的操作。</p>
<p>SELECT * FROM t_order where id&gt;=1000000 LIMIT 10</p>
<h2 id="MySQL-使用-like-“-x“，索引一定会失效吗？"><a href="#MySQL-使用-like-“-x“，索引一定会失效吗？" class="headerlink" title="MySQL 使用 like “%x“，索引一定会失效吗？"></a>MySQL 使用 like “%x“，索引一定会失效吗？</h2><p>从这个思考题我们知道了，使用左模糊匹配（like “%xx”）并不一定会走全表扫描，关键还是看数据表中的字段。</p>
<p>如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。</p>
<h2 id="count-和-count-1-有什么区别？哪个性能最好？"><a href="#count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p>
<p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p>
<p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务有哪些特性？"><a href="#事务有哪些特性？" class="headerlink" title="事务有哪些特性？"></a>事务有哪些特性？</h2><p><strong>原子性（Atomicity）</strong></p>
<p>一个事务中的所有操作，要么全部完成，要么全部不完成</p>
<p><strong>一致性（Consistency）</strong></p>
<p>数据满足完整性约束，数据库保持一致性状态</p>
<p><strong>隔离性（Isolation）</strong></p>
<p>隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</p>
<p><strong>持久性（Durability）</strong></p>
<p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h2 id="InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？"><a href="#InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？" class="headerlink" title="InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？"></a>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</h2><p>原子性是通过 undo log（回滚日志）;</p>
<p>一致性则是通过持久性+原子性+隔离性来保证；</p>
<p>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</p>
<p>持久性是通过 redo log （重做日志）来保证的；</p>
<h2 id="并行事务会引发什么问题？✨"><a href="#并行事务会引发什么问题？✨" class="headerlink" title="并行事务会引发什么问题？✨"></a>并行事务会引发什么问题？✨</h2><ul>
<li>脏读：读到其他事务未提交的数据；</li>
<li>不可重复读：前后读取的数据不一致；</li>
<li>幻读：前后读取的记录数量不一致。</li>
</ul>
<p><img src="/../../pic/d37bfa1678eb71ae7e33dc8f211d1ec1.png" alt="严重性排序"></p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p>
<p><img src="/../../pic/1717913436378-906c5ccf-b284-4fa8-89ea-3e832afd7cc9.png" alt="脏读"></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p>
<p><img src="/../../pic/1717913436386-ec8e4aa9-6bd9-4555-9802-c18567b762df.png" alt="不可重复读"></p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的<strong>记录数量</strong>不一样的情况，就意味着发生了「幻读」现象。</p>
<p><img src="/../../pic/1717913436123-4db9c815-cc4b-4861-b2ff-3a293e37416d.png" alt="幻读"></p>
<h2 id="事务的隔离级别有哪些？各自的应用场景✨"><a href="#事务的隔离级别有哪些？各自的应用场景✨" class="headerlink" title="事务的隔离级别有哪些？各自的应用场景✨"></a>事务的隔离级别有哪些？各自的应用场景✨</h2><p><img src="/../../pic/cce766a69dea725cd8f19b90db2d0430.png" alt="隔离水平高低排序"></p>
<p><img src="/../../pic/4e98ea2e60923b969790898565b4d643.png" alt="图片"></p>
<p><strong>读未提交(Read Uncommitted)</strong></p>
<ul>
<li><p>特点：一个事务还没提交时，它做的变更就能被其他事务看到</p>
</li>
<li><p>应用场景：对于一些对数据一致性要求不高的场景，比如读取系统的实时监控数据。</p>
</li>
</ul>
<p><strong>读已提交(Read Committed)</strong></p>
<ul>
<li>特点：一个事务提交之后，它做的变更才能被其他事务看到；事务读取数据时会生成新的快照数据Read View。</li>
<li>应用场景：适用于大部分常规业务场景，能够保证读取的数据具有较高的一致性。</li>
</ul>
<p><strong>可重复读(Repeatable Read)</strong> ==默认级别==</p>
<ul>
<li>特点：事务中的修改操作需要等待事务提交后才生效；事务读取数据时只能读取事务开始时的快照数据Read View，对其他事务对数据的修改不可见。</li>
<li>应用场景：适用于需要保证读取数据一致性的应用，例如订单交易等。</li>
</ul>
<p><strong>串行化(Serializable)</strong></p>
<ul>
<li>特点：事务中的修改操作需要等待事务提交后才生效；会对记录加上<strong>读写锁</strong>，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
<li>应用场景：适用于对数据一致性要求极高的场景，例如金融领域的转账操作。</li>
</ul>
<h2 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h2><ul>
<li>Read View 中四个字段作用；</li>
</ul>
<p><img src="/../../pic/readview%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p>
<ul>
<li>聚簇索引记录中两个跟事务有关的隐藏列；</li>
</ul>
<p><img src="/../../pic/f595d13450878acd04affa82731f76c5.png" alt="图片"></p>
<p>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</p>
<p>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</p>
<h2 id="MVCC✨"><a href="#MVCC✨" class="headerlink" title="MVCC✨"></a>MVCC✨</h2><p>核心包括：<strong>undo log、版本链、read view</strong></p>
<p>==通过「事务的 Read View 里的事务 id」和「版本链中记录的事务 id」的比对,来控制并发事务访问一个记录的行为叫 MVCC（多版本并发控制）==</p>
<p><img src="/../../pic/a463e5d8f8493c4696716e44e96748af-20240324212007851.png" alt="undo日志、版本链"></p>
<p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p>
<p><img src="/../../pic/ReadView.drawio.png" alt="事务 id 分类"></p>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ol>
<li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，可见</li>
<li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，不可见</li>
<li>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，需要判断 trx_id 是否在 m_ids 列表中：在——不可见；不在——可见</li>
</ol>
<p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p>
<ul>
<li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View</li>
<li>「可重复读」隔离级别是启动事务时生成一个 Read View</li>
</ul>
<p>对于幻读现象，不建议将隔离级别升级为串行化。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</p>
<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong></li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong></li>
</ul>
<h2 id="MySQL-可重复读隔离级别，完全解决幻读了吗？✨"><a href="#MySQL-可重复读隔离级别，完全解决幻读了吗？✨" class="headerlink" title="MySQL 可重复读隔离级别，完全解决幻读了吗？✨"></a>MySQL 可重复读隔离级别，完全解决幻读了吗？✨</h2><p><strong>可重复读隔离级别下虽然很大程度上避免了幻读，但是还是没有能完全解决幻读</strong>。</p>
<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p><img src="/../../pic/%E5%B9%BB%E8%AF%BB%E5%8F%91%E7%94%9F.drawio.png"></p>
<p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p>
<p>对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</p>
<p>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</p>
<p>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</p>
<p>所以，<strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p>
<h3 id="如何解决幻读的场景"><a href="#如何解决幻读的场景" class="headerlink" title="如何解决幻读的场景"></a>如何解决幻读的场景</h3><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 <code>select ... for update</code> 这类当前读的语句，因为它会对记录加 <code>next-key lock</code>，从而避免其他事务插入一条新记录。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="mysql有哪些锁？"><a href="#mysql有哪些锁？" class="headerlink" title="mysql有哪些锁？"></a>mysql有哪些锁？</h2><p>根据加锁的范围，可以分为<strong>全局锁、表级锁和行锁</strong>三类。</p>
<p><img src="/../../pic/1720433609532-38aec7fc-734e-4b35-a802-4e6ba3339ffa.png" alt="mysql 中锁类型"></p>
<h2 id="表锁和行锁的作用"><a href="#表锁和行锁的作用" class="headerlink" title="表锁和行锁的作用"></a>表锁和行锁的作用</h2><p><strong>表锁作用</strong>：</p>
<ul>
<li>整体控制</li>
<li>粒度大：可能会引起锁竞争和性能问题</li>
<li>适用于大批量操作：表的重建、大量数据的加载</li>
</ul>
<p><strong>行锁作用</strong>：</p>
<ul>
<li>细粒度控制</li>
<li>减少锁冲突</li>
<li>适用于频繁蛋黄操作</li>
</ul>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>要使用全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></tbody></table></figure>

<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如 insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></tbody></table></figure>

<p>当然，当会话断开了，全局锁会被自动释放。</p>
<h3 id="全局锁应用场景"><a href="#全局锁应用场景" class="headerlink" title="全局锁应用场景"></a>全局锁应用场景</h3><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<h3 id="加全局锁的缺点"><a href="#加全局锁的缺点" class="headerlink" title="加全局锁的缺点"></a>加全局锁的缺点</h3><p>加上全局锁，意味着整个数据库都是只读状态。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<h3 id="既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？"><a href="#既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？" class="headerlink" title="既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？"></a>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</h3><p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么==在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作，不会影响备份的数据==。</p>
<p>备份数据库的工具是 <code>mysqldump</code>，在使用 <code>mysqldump</code> 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL 里面表级别的锁有这几种：</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p>
<ul>
<li><p>优势：开销小；加锁快；无死锁</p>
</li>
<li><p>劣势：锁粒度大，发生锁冲突的概率高，并发能力差</p>
</li>
<li><p>加锁方法：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享读锁：lock tables tableName read;</span><br><span class="line">独占写锁：lock tables tableName write;</span><br><span class="line">批量解锁：unlock tables;</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p><strong>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</strong></p>
<h4 id="MDL-不需要显示调用，那它是在什么时候释放的"><a href="#MDL-不需要显示调用，那它是在什么时候释放的" class="headerlink" title="MDL 不需要显示调用，那它是在什么时候释放的?"></a>MDL 不需要显示调用，那它是在什么时候释放的?</h4><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，<strong>只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突</strong>。</p>
<p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>，从而判断是否能加表锁。</p>
<blockquote>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
</blockquote>
<h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h3><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p>
<p>缺点：AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>解决： 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<h2 id="行级锁✨"><a href="#行级锁✨" class="headerlink" title="行级锁✨"></a>行级锁✨</h2><p>不同隔离级别下，行级锁的种类是不同的。</p>
<p>在读已提交隔离级别下，行级锁的种类只有记录锁（<strong>解决脏读</strong>），也就是仅仅把一条记录锁上。</p>
<p>在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（<strong>避免幻读</strong>），所以行级锁的种类主要有三类：</p>
<h3 id="Record-Lock-记录锁"><a href="#Record-Lock-记录锁" class="headerlink" title="Record Lock-记录锁"></a>Record Lock-记录锁</h3><p>锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的</p>
<p><img src="/../../pic/x%E9%94%81%E5%92%8Cs%E9%94%81.png" alt="兼容性"></p>
<h3 id="Gap-Lock-间隙锁"><a href="#Gap-Lock-间隙锁" class="headerlink" title="Gap Lock-间隙锁"></a>Gap Lock-间隙锁</h3><p>锁定一个范围，但是不包含记录本身；间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，==因为间隙锁的目的是<strong>防止插入幻影</strong>记录而提出的==。</p>
<h3 id="Next-Key-Lock-临键锁"><a href="#Next-Key-Lock-临键锁" class="headerlink" title="Next-Key Lock-临键锁"></a>Next-Key Lock-临键锁</h3><p>Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<h2 id="什么-SQL-语句会加行级锁？"><a href="#什么-SQL-语句会加行级锁？" class="headerlink" title="什么 SQL 语句会加行级锁？"></a>什么 SQL 语句会加行级锁？</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎 的。</p>
<p>普通的 select 语句是不会对记录加锁的（除了串行化隔离级别），因为它属于快照读，是通过 MVCC（多版本并发控制）实现的。</p>
<p>如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为<strong>锁定读</strong>。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加共享锁(S型锁)</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。</p>
<p>**除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)**。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> .... <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</p>
<h2 id="MySQL-行级锁的加锁规则"><a href="#MySQL-行级锁的加锁规则" class="headerlink" title="MySQL 行级锁的加锁规则"></a>MySQL 行级锁的加锁规则</h2><p>唯一索引等值查询：</p>
<ul>
<li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li>
<li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</li>
</ul>
<p>非唯一索引等值查询：</p>
<ul>
<li><p>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会<strong>退化成间隙锁</strong>。同时，在符合查询条件的记录的<strong>主键索引上加记录锁</strong>。</p>
<p><img src="/../../pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png"></p>
</li>
<li><p>当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会<strong>退化成间隙锁</strong>。因为不存在满足查询条件的记录，所以<strong>不会对主键索引加锁</strong>。</p>
<p><img src="/../../pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png"></p>
</li>
</ul>
<p>唯一索引的<strong>范围查询</strong></p>
<ul>
<li>对每一个扫描到的索引加 next-key 锁</li>
</ul>
<ul>
<li><p>唯一索引在满足一些条件的时候，索引的 next-key lock <strong>退化为间隙锁或者记录锁</strong>。</p>
<ul>
<li><p>「大于等于」找到满足的记录加上 next-key lock，找到等值的记录会退化成记录锁</p>
<p><img src="/../../pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E15.drawio.png"></p>
</li>
<li><p>「小于等于、小于」出现第一个不匹配的会退化成间隙锁</p>
<p><img src="/../../pic/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E6.drawio-20240331091327727.png"></p>
</li>
</ul>
</li>
</ul>
<p>非唯一索引的<strong>范围查询</strong></p>
<ul>
<li><p>对每一个扫描到的非唯一索引加 next-key 锁（不会退化），并对匹配的主键索引加记录锁</p>
<p><img src="/../../pic/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png"></p>
</li>
</ul>
<p>其实理解 MySQL 为什么要这样加锁，主要要以避免幻读角度去分析，这样就很容易理解这些加锁的规则了。</p>
<h2 id="update-没加索引会锁全表？"><a href="#update-没加索引会锁全表？" class="headerlink" title="update 没加索引会锁全表？"></a>update 没加索引会锁全表？</h2><p>还有一件很重要的事情，在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，**==如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了==**，这是挺严重的问题。</p>
<p>解决方案：</p>
<ol>
<li><p>打开 MySQL sql_safe_updates 参数</p>
</li>
<li><p>使用 <code>force index([index_name])</code> 可以告诉优化器使用哪个索引</p>
</li>
</ol>
<h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h2><p>在 MySQL 的可重复读隔离级别下，针对当前读的语句会对<strong>索引</strong>加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。</p>
<h2 id="MySQL-死锁了，怎么办？"><a href="#MySQL-死锁了，怎么办？" class="headerlink" title="MySQL 死锁了，怎么办？"></a>MySQL 死锁了，怎么办？</h2><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p><img src="/../../pic/90c1e01d0345de639e3426cea0390e80.png"></p>
<ul>
<li>两个事务中的锁定读各自会在（1006， +∞）生成间隙锁，间隙锁是兼容的。但假如有记录锁，就会存在 xs、xx 互斥，那么事务 B 的锁定读就会被阻塞</li>
<li>而事务 A 在进行 insert 的时候会尝试在插入间隙上获取「插入意向锁」，但是间隙上已经有事务 B 的间隙锁，所以insert 被阻塞</li>
<li>同理，事务 B 的 insert 也会被阻塞</li>
</ul>
<p>因为当我们执行插入语句时，会在插入间隙上获取插入意向锁，<strong>而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以两个事务中 <code>select ... for update</code> 语句并不会相互影响</strong>。</p>
<p>避免死锁：</p>
<ol>
<li><strong>设置事务等待锁的超时时间</strong></li>
<li><strong>开启主动死锁检测</strong></li>
</ol>
<h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p><img src="/../../pic/%E5%AD%97%E8%8A%82mysql%E9%9D%A2%E8%AF%95%E9%A2%98.png"></p>
<p>两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。</p>
<p>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</p>
<p>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁。</p>
<h2 id="MySQL的update阻塞问题"><a href="#MySQL的update阻塞问题" class="headerlink" title="MySQL的update阻塞问题"></a>MySQL的update阻塞问题</h2><h3 id="MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？"><a href="#MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？" class="headerlink" title="MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？"></a>MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？</h3><p>如果是两个事务同时更新了 id = 1，比如 update … where id = 1，那么是会阻塞的。因为 InnoDB 存储引擎实现了行级锁。</p>
<p>当A事务对 id =1 这行记录进行更新时，会对主键 id 为 1 的记录加X类型的记录锁，这样第二事务对 id = 1 进行更新时，发现已经有记录锁了，就会陷入阻塞状态。</p>
<h3 id="两条update语句处理一张表的不同的主键范围的记录，一个15，会不会遇到阻塞？底层是为什么的？"><a href="#两条update语句处理一张表的不同的主键范围的记录，一个15，会不会遇到阻塞？底层是为什么的？" class="headerlink" title="两条update语句处理一张表的不同的主键范围的记录，一个<10，一个>15，会不会遇到阻塞？底层是为什么的？"></a>两条update语句处理一张表的不同的主键范围的记录，一个&lt;10，一个&gt;15，会不会遇到阻塞？底层是为什么的？</h3><p>不会，因为锁住的范围不一样，不会形成冲突。</p>
<ul>
<li>第一条 update sql 的话（ id&lt;10），锁住的范围是（-♾️，10）</li>
<li>第二条 update sql 的话（id &gt;15），锁住的范围是（15，+♾️）</li>
</ul>
<h3 id="如果2个范围不是主键或索引？还会阻塞吗？"><a href="#如果2个范围不是主键或索引？还会阻塞吗？" class="headerlink" title="如果2个范围不是主键或索引？还会阻塞吗？"></a>如果2个范围不是主键或索引？还会阻塞吗？</h3><p>如果2个范围查询的字段不是索引的话，那就代表 update 没有用到索引，这时候触发了全表扫描，全部索引都会加行级锁，这时候第二条 update 执行的时候，就会阻塞了。</p>
<p>因为如果 update 没有用到索引，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表。</p>
<p><img src="/../../pic/1711526947543-96b555cc-646f-4194-b2b3-343b3b6dd769.png" alt="行级锁"></p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>三种日志：</p>
<ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。（存放在Buffer Pool里面的undo页中，其持久性受redo log控制）</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>。（物理日志）</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<h2 id="undo-log✨"><a href="#undo-log✨" class="headerlink" title="undo log✨"></a>undo log✨</h2><p>undo log 是一种用于撤销回退的日志，<strong>它保证了事务的</strong> <strong>ACID 特性中的原子性</strong>（Atomicity）。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：</p>
<p><img src="/../../pic/1717920811388-2146eb90-98bd-4b2d-b6a8-9c207fbdacc4.png" alt="undo log回滚"></p>
<p>每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：</p>
<ul>
<li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li>
<li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li>
<li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li>
</ul>
<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。</p>
<h3 id="两大作用"><a href="#两大作用" class="headerlink" title="两大作用"></a>两大作用</h3><ul>
<li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li>
<li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
<h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a><strong>刷盘策略</strong></h3><p><strong>undo log 和数据页的刷盘策略是一样的</strong>，都需要通过 redo log 保证持久化。</p>
<p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p>
<h2 id="为什么需要-Buffer-Pool？"><a href="#为什么需要-Buffer-Pool？" class="headerlink" title="为什么需要 Buffer Pool？"></a>为什么需要 Buffer Pool？</h2><p>Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p>
<p>有了 Buffer Poo 后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li>
</ul>
<h2 id="redo-log✨"><a href="#redo-log✨" class="headerlink" title="redo log✨"></a>redo log✨</h2><h3 id="有了undolog为啥还需要redolog？"><a href="#有了undolog为啥还需要redolog？" class="headerlink" title="有了undolog为啥还需要redolog？"></a>有了undolog为啥还需要redolog？</h3><p>undo log只是保证了原子性，但是不能保证持久性。</p>
<p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，<strong>这个时候更新就算完成了</strong>。</p>
<p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。</p>
<p>==WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。==</p>
<p><img src="/../../pic/wal.png" alt="WAL"></p>
<h3 id="什么是-redo-log？"><a href="#什么是-redo-log？" class="headerlink" title="什么是 redo log？"></a>什么是 redo log？</h3><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<p>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p>
<h3 id="被修改-Undo-页面，需要记录对应-redo-log-吗？"><a href="#被修改-Undo-页面，需要记录对应-redo-log-吗？" class="headerlink" title="被修改 Undo 页面，需要记录对应 redo log 吗？"></a>被修改 Undo 页面，需要记录对应 redo log 吗？</h3><p>需要的。</p>
<p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p>
<p>不过，<strong>在内存修改该 Undo 页面后，需要记录对应的 redo log</strong>。</p>
<h3 id="redo-log-和-undo-log-区别在哪？✨"><a href="#redo-log-和-undo-log-区别在哪？✨" class="headerlink" title="redo log 和 undo log 区别在哪？✨"></a>redo log 和 undo log 区别在哪？✨</h3><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p>
<ul>
<li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li>
<li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li>
</ul>
<p>==事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务==。</p>
<p>所以==有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>（崩溃恢复）==。可以看出来， <strong>redo log 保证了事务四大特性中的持久性</strong>。</p>
<h3 id="redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？"><a href="#redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？" class="headerlink" title="redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？"></a>redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</h3><p>可以说这是 WAL 技术的另外一个优点：<strong>MySQL 的写操作从磁盘的「随机写」变成了「顺序写」</strong>，提升语句的执行性能。</p>
<h3 id="redo-log怎么保证持久性？✨"><a href="#redo-log怎么保证持久性？✨" class="headerlink" title="redo log怎么保证持久性？✨"></a>redo log怎么保证持久性？✨</h3><ul>
<li><strong>Write-ahead logging（WAL）</strong>：在事务提交之前，将事务所做的修改操作记录到redo log中，然后再将数据写入磁盘。这样即使在数据写入磁盘之前发生了宕机，系统可以通过redo log中的记录来恢复数据。（如何实现）</li>
<li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。（为什么这么实现）</li>
<li><strong>Checkpoint机制</strong>：MySQL会定期将内存中的数据刷新到磁盘，同时将最新的LSN（Log Sequence Number）记录到磁盘中，这个LSN可以确保redo log中的操作是按顺序执行的。在恢复数据时，系统会根据LSN来确定从哪个位置开始应用redo log。（如何定位）</li>
</ul>
<h3 id="产生的-redo-log-是直接写入磁盘的吗？"><a href="#产生的-redo-log-是直接写入磁盘的吗？" class="headerlink" title="产生的 redo log 是直接写入磁盘的吗？"></a>产生的 redo log 是直接写入磁盘的吗？</h3><p>不是的。</p>
<p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I/O 操作，而且磁盘的运行速度远慢于内存。</p>
<p>所以，redo log 也有自己的缓存—— <strong>redo log buffer</strong>，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘</p>
<h3 id="redo-log-什么时候刷盘？✨"><a href="#redo-log-什么时候刷盘？✨" class="headerlink" title="redo log 什么时候刷盘？✨"></a>redo log 什么时候刷盘？✨</h3><p>主要有下面几个时机：</p>
<ul>
<li>MySQL 正常关闭时；</li>
<li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li>
<li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li>
<li>提交事务：每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（由innodb_flush_log_at_trx_commit控制）<ul>
<li>当设置该<strong>参数为 0 时</strong>，表示每次事务提交时 ，还是<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该<strong>参数为 1 时</strong>，表示每次事务提交时，都<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该<strong>参数为 2 时</strong>，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到操作系统的<strong>文件缓存</strong>（page cache）。</li>
</ul>
</li>
</ul>
<p><img src="/../../pic/innodb_flush_log_at_trx_commit.drawio.png" alt="img"></p>
<p>InnoDB 的后台线程每隔 1 秒：</p>
<ul>
<li>针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</li>
<li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。<strong>所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li>
</ul>
<p><img src="/../../pic/innodb_flush_log_at_trx_commit2.drawio.png" alt="img"></p>
<p>这三个参数的数据安全性和写入性能的比较如下：</p>
<ul>
<li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li>
<li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li>
</ul>
<h3 id="redo-log-文件写满了怎么办？"><a href="#redo-log-文件写满了怎么办？" class="headerlink" title="redo log 文件写满了怎么办？"></a>redo log 文件写满了怎么办？</h3><p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成</p>
<p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p>
<p><img src="/../../pic/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.drawio.png" alt="重做日志文件组写入过程"></p>
<p><img src="/../../pic/checkpoint.png" alt="checkpoint机制"></p>
<p>图中的：</p>
<ul>
<li>write pos 和 checkpoint 的移动都是顺时针方向；</li>
<li>write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；</li>
<li>check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li>
</ul>
<p>如果 write pos 追上了 checkpoint，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（<em>因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要</em>），此时<strong>会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><h3 id="为什么需要-binlog-？"><a href="#为什么需要-binlog-？" class="headerlink" title="为什么需要 binlog ？"></a>为什么需要 binlog ？</h3><p>binlog 是 server 层实现的日志，所有存储引擎都能用；而最开始 MySQL 中并没有 InnoDB，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有崩溃恢复能力，所以通过插件的方式引入 InnoDB， 通过 redo log 来实现 crash-safe（崩溃恢复）</p>
<p><strong>binlog 只用于归档</strong>：binlog 文件是记录了所有数据库表结构变更和表数据修改的操作日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p>
<h3 id="能不能只用binlog不用redo-log？"><a href="#能不能只用binlog不用redo-log？" class="headerlink" title="能不能只用binlog不用redo log？"></a>能不能只用binlog不用redo log？</h3><p>不行，binlog是 server 层的日志，记录所有的表结构变动和表数据变动的语句，是全量日志，没有 checkpoint 机制来判断哪些脏页还没有刷盘，redolog 是存储引擎层的日志，可以记录哪些脏页还没有刷盘，这样崩溃恢复的时候，就能恢复那些还没有被刷盘的脏页数据。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43698257/article/details/110676515">为什么 redo log 具有 crash-safe 的能力，是 binlog 无法替代的？-CSDN博客</a></p>
<h3 id="redo-log-和-binlog-有什么区别？"><a href="#redo-log-和-binlog-有什么区别？" class="headerlink" title="redo log 和 binlog 有什么区别？"></a>redo log 和 binlog 有什么区别？</h3><p>为什么有了 binlog， 还要有 redo log？</p>
<ol>
<li><p>适用对象不同：</p>
<ul>
<li><p>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</p>
</li>
<li><p>redo log 是 Innodb 存储引擎实现的日志；</p>
</li>
</ul>
</li>
<li><p>文件格式不同：</p>
<ul>
<li><p>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：</p>
<ul>
<li><p><code>STATEMENT</code>：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。</p>
<p>问题：但 STATEMENT 有<strong>动态函数</strong>的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</p>
</li>
<li><p><code>ROW</code>：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。</p>
<p>问题：但 ROW 的缺点是每行数据的<strong>变化结果都会被记录</strong>，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</p>
</li>
<li><p><code>MIXED</code>：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</p>
</li>
</ul>
</li>
<li><p>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</p>
</li>
</ul>
</li>
<li><p>写入方式不同：</p>
<ul>
<li><p>binlog 是<strong>追加写</strong>，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</p>
</li>
<li><p>redo log 是<strong>循环写</strong>，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</p>
</li>
</ul>
</li>
<li><p>用途不同：</p>
<ul>
<li><p>binlog 用于备份恢复、主从复制；</p>
</li>
<li><p>redo log 用于掉电等故障恢复。</p>
</li>
</ul>
</li>
</ol>
<h3 id="如果不小心整个数据库的数据被删除了，能使用-redo-log-文件恢复数据吗？"><a href="#如果不小心整个数据库的数据被删除了，能使用-redo-log-文件恢复数据吗？" class="headerlink" title="如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？"></a>如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</h3><p>不可以使用 redo log 文件恢复，只能使用 binlog 文件恢复。</p>
<p>因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。</p>
<p>binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。</p>
<h3 id="主从复制是怎么实现？✨"><a href="#主从复制是怎么实现？✨" class="headerlink" title="主从复制是怎么实现？✨"></a>主从复制是怎么实现？✨</h3><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p>
<p><img src="/../../pic/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B.drawio.png" alt="MySQL 主从复制过程"></p>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p>
<ul>
<li><p><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</p>
</li>
<li><p><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</p>
</li>
<li><p><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</p>
</li>
</ul>
<p>在完成主从复制之后，你就可以在写数据时只写主库，在读数据时只读从库，这样即使写请求会锁表或者锁记录，也不会影响读请求的执行。</p>
<p><img src="/../../pic/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.drawio.png" alt="MySQL 主从架构"></p>
<p>在主库端一旦有新的日志产生后，立刻会发送一次广播，Binglog Dump线程在收到广播后，则会读取二进制日志并通过网络向备库传输日志，所以这是一个<strong>主库向备库不断推送</strong>的过程。</p>
<h4 id="从库是不是越多越好？"><a href="#从库是不是越多越好？" class="headerlink" title="从库是不是越多越好？"></a>从库是不是越多越好？</h4><p>不是的。</p>
<p>因为从库数量增加，从库连接上来的 I/O 线程也比较多，<strong>主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽</strong>。</p>
<p>所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。</p>
<h4 id="MySQL-主从复制还有哪些模型？"><a href="#MySQL-主从复制还有哪些模型？" class="headerlink" title="MySQL 主从复制还有哪些模型？"></a>MySQL 主从复制还有哪些模型？</h4><p>主要有三种：</p>
<ul>
<li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li>
<li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li>
<li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，<strong>只要数据成功复制到任意一个从库上</strong>，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li>
</ul>
<h3 id="binlog-什么时候刷盘？"><a href="#binlog-什么时候刷盘？" class="headerlink" title="binlog 什么时候刷盘？"></a>binlog 什么时候刷盘？</h3><blockquote>
<p>什么时候 binlog cache 会写到 binlog 文件？</p>
</blockquote>
<p>在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。如下图：</p>
<p><img src="/../../pic/binlogcache.drawio.png" alt="binlog cach"></p>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog = 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog = 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog =N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>在MySQL中系统默认的设置是 sync_binlog = 0，也就是不做任何强制性的磁盘刷新指令，这时候的性能是最好的，但是风险也是最大的。因为一旦主机发生异常重启，还没持久化到磁盘的数据就会丢失。</p>
<p>而当 sync_binlog 设置为 1 的时候，是最安全但是性能损耗最大的设置。因为当设置为 1 的时候，即使主机发生异常重启，最多丢失一个事务的 binlog，而已经持久化到磁盘的数据就不会有影响，不过就是对写入性能影响太大。</p>
<p>如果能容少量事务的 binlog 日志丢失的风险，为了提高写入的性能，一般会 sync_binlog 设置为 100~1000 中的某个数值。</p>
<h2 id="为什么需要两阶段提交？✨"><a href="#为什么需要两阶段提交？✨" class="headerlink" title="为什么需要两阶段提交？✨"></a>为什么需要两阶段提交？✨</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p>
<p>举个例子，假设 id = 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 <code>UPDATE t_user SET name = 'xiaolin' WHERE id = 1;</code> 如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p>
<ul>
<li><p><strong>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入</strong>。</p>
</li>
<li><p><strong>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入</strong>。</p>
</li>
</ul>
<p>==在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。==</p>
<h3 id="两阶段提交的过程是怎样的？"><a href="#两阶段提交的过程是怎样的？" class="headerlink" title="两阶段提交的过程是怎样的？"></a>两阶段提交的过程是怎样的？</h3><p><img src="/../../pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.drawio.png" alt="两阶段提交"></p>
<p>从图中可看出，事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog</strong>，具体如下：</p>
<ul>
<li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</li>
<li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li>
</ul>
<h3 id="异常重启会出现什么现象？"><a href="#异常重启会出现什么现象？" class="headerlink" title="异常重启会出现什么现象？"></a>异常重启会出现什么现象？</h3><p><img src="/../../pic/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%B4%A9%E6%BA%83%E7%82%B9.drawio.png" alt="时刻 A 与时刻 B"></p>
<p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p>
<ul>
<li><p><strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况。</p>
</li>
<li><p><strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</p>
</li>
</ul>
<p>可以看到，<strong>对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p>
<p>所以说，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong>，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p>
<blockquote>
<p>处于 prepare 阶段的 redo log 加上完整 binlog，重启就提交事务，MySQL 为什么要这么设计?</p>
</blockquote>
<p>binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。</p>
<p>所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p>
<blockquote>
<p>事务没提交的时候，redo log 会被持久化到磁盘吗？</p>
</blockquote>
<p>会的。</p>
<p>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些缓存在 redo log buffer 里的 redo log 也会被「后台线程」每隔一秒一起持久化到磁盘。</p>
<p>也就是说，<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。</p>
<p>但不会造成数据不一致，mysql 重启会进行回滚操作，因为事务没提交的时候，binlog 是还没持久化到磁盘的。</p>
<p>redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘。</p>
<h3 id="两阶段提交有什么问题？"><a href="#两阶段提交有什么问题？" class="headerlink" title="两阶段提交有什么问题？"></a>两阶段提交有什么问题？</h3><ul>
<li><p><strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</p>
</li>
<li><p><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</p>
</li>
</ul>
<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><p>具体更新一条记录 <code>UPDATE t_user SET name = 'xiaolin' WHERE id = 1;</code> 的流程如下:</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录：<ul>
<li>如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
<li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li>至此，一条更新语句执行完成。</li>
</ol>
<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。✨"><a href="#慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。✨" class="headerlink" title="慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。✨"></a>慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。✨</h2><p>原因</p>
<ol>
<li>索引失效</li>
<li>连接查询没有用到索引，执行了笛卡尔查询</li>
<li>大数据量排序与分组</li>
<li>复杂的子查询</li>
<li>表结构设计问题</li>
<li>事务锁竞争</li>
</ol>
<p>定位</p>
<ol>
<li><strong>慢查询日志</strong>。MySQL的慢查询日志会记录执行时间超过long_query_time 的SQL语句</li>
<li><code>show processlist</code>。实时展示当前MySQL正在执行的线程,可以通过processlist来发现一些状态显示为Lock等的慢查询。</li>
</ol>
<p>分析查询语句</p>
<p>使用EXPLAIN命令分析SQL执行计划，找出慢查询的原因，比如是否使用了全表扫描，是否存在索引未被利用的情况等，并根据相应情况对索引进行适当修改。</p>
<p>优化</p>
<ol>
<li>创建或优化索引。<ul>
<li>对于 where、order by、group by、join 连表查询的字典；</li>
<li>对于查询经常涉及多个字段，考虑创建联合索引。</li>
</ul>
</li>
<li>避免索引失效。<ul>
<li>左模糊匹配；</li>
<li>函数计算；</li>
<li>表达式计算；</li>
<li>类型转换；</li>
<li>where 子句 or 都要有索引；</li>
<li>列与列比较；</li>
<li>is null 判断</li>
</ul>
</li>
<li>查询语句优化。<ul>
<li>避免使用SELECT *，只查询真正需要的列；</li>
<li>使用覆盖索引，即索引包含所有查询的字段；</li>
<li>联表查询最好要以小表驱动大表，并且被驱动表的字段要有索引，当然最好通过冗余字段的设计，避免联表查询。</li>
</ul>
</li>
<li>优化表结构。去除冗余字段,拆分过大的表,适当垂直拆分或者水平拆分表。</li>
<li>使用视图。将复杂查询封装为视图,以简化查询过程。</li>
<li>加缓存优化数据统计类的慢查询</li>
<li>部署读写分离架构,主库负责写,从库负责读,分散数据库压力。</li>
</ol>
<h2 id="使用-explain-优化你的-mysql-性能✨"><a href="#使用-explain-优化你的-mysql-性能✨" class="headerlink" title="使用 explain 优化你的 mysql 性能✨"></a>使用 explain 优化你的 mysql 性能✨</h2><h3 id="Explain-特点"><a href="#Explain-特点" class="headerlink" title="Explain 特点"></a>Explain 特点</h3><ul>
<li>explain 返回的结果是以表为粒度的，每个表输出一行，这里的表示广义上的表，可以是一个子查询，也可以是一个 UNION 后的结果。</li>
<li>explain 只能解析 Select 查询，对于 update，insert 等都不支持，我们可以使用 select 来模拟 update 操作近似获取 update 的执行过程</li>
</ul>
<h3 id="Explain-中的列"><a href="#Explain-中的列" class="headerlink" title="Explain 中的列"></a>Explain 中的列</h3><p>explain 是查看 sql 的执行计划，主要用来分析 sql 语句的执行过程，比如有没有走索引，有没有外部排序，有没有索引覆盖等等。</p>
<p><img src="/../pic/1720420604941-9fafd933-6a90-4f02-a23c-0e577790f040.webp" alt="explain 示例"></p>
<h4 id="type✨"><a href="#type✨" class="headerlink" title="type✨"></a>type✨</h4><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是全表扫描还是索引扫描等，type 类型的性能比较，通常来说, 不同的 type 类型的性能关系如下:</p>
<p>ALL &lt; index &lt; range &lt; ref &lt; eq_ref &lt; const </p>
<ul>
<li><p>const（结果只有一条的主键或唯一索引扫描）：<strong>const 是与常量进行比较，查询效率会更快</strong>。</p>
</li>
<li><p>eq_ref（唯一索引扫描）： <strong>eq_ref 通常用于多表联查中</strong></p>
</li>
<li><p>ref（非唯一索引扫描）</p>
</li>
<li><p>range（索引范围扫描）: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。<strong>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong>。</p>
<p>但是对于同样的 type = range 的查询，性能上还是有区别的：</p>
</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 虽然是都是范围查询，其实第二个查询时多个等值条件查询</span><br><span class="line"># 对于第一个查询，mysql 无法再使用该列后面的其它查询索引了，而第二个则可以继续使用索引</span><br><span class="line">select id from actor where id &gt; 45 and class_id = 3;</span><br><span class="line">select id from actor where id in (44, 47, 48) and class_id = 3;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>index（全索引扫描）: 表示通过索引进行全表扫描和 ALL 类型类似, 有点是<strong>避免了排序</strong>，确定是需要承担按照索引次序读取表的开销。</li>
<li>ALL（全表扫描）: 这个类型的查询是性能最差的查询之一。一般情况下都会从头到尾扫描所有行，除非使用了 Limit 或者 Extra 列中显示 “Using distinct/not exists”。</li>
</ul>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>此次查询中确切使用到的索引，如果在 possible_keys 中没有出现而在 key 中出现，说明优化器可能出于另外原因比如选择覆盖索引，所以 possiable_keys 揭示了哪一个索引有助于高效进行查找，而 key 显示了采用哪一个索引可以最小化查询成本。</p>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, <strong>估算 SQL 要查找到结果集需要扫描读取的数据行数</strong>。这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。</p>
<ul>
<li>通过把每个表的 rows 值相乘可以粗略的估算出整个查询要检查的行数</li>
<li>这个值只是一个估算的值，不是实际查出来的值</li>
</ul>
<h4 id="Extra✨"><a href="#Extra✨" class="headerlink" title="Extra✨"></a>Extra✨</h4><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>
<ul>
<li>Using filesort</li>
</ul>
<p>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大。 但是 Explain 不会告诉你 Mysql 将使用文件排序还是内存排序：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 比如我们建立索引为：KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)，那么如下两个查询</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM order_info ORDER BY product_name；    -- Using filesort，不能通过索引进行排序，需要优化</span><br><span class="line">EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name；-- 无 Using filesort，通过索引进行排序，优化成功</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>Using index</li>
</ul>
<p>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p>
<ul>
<li>Using where</li>
</ul>
<p>这意味着 Mysql 服务器在存储引擎检索行后再进行过滤，一般出现 “Using where” 会受益于不同的索引</p>
<ul>
<li>Using temporary</li>
</ul>
<p>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 临时表可能是内存临时表或者文件临时表。效率低，要避免这种问题的出现。</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><p>Innodb 存储引擎设计了一个<strong>缓冲池（*Buffer Pool*）</strong>，来提高数据库的读写性能。</p>
<p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p>
<p>Innodb 通过三种链表来管理缓页：</p>
<ul>
<li>Free List （空闲页链表），管理空闲页；</li>
<li>Flush List （脏页链表），管理脏页；</li>
<li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</li>
</ul>
<p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p>
<ul>
<li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li>
<li>当<strong>「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」</strong>时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li>
</ul>
<p>可以通过调整 <code>innodb_old_blocks_pct</code> 参数，设置 young 区域和 old 区域比例。</p>
<p>在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p><img src="/../../pic/mybatis-y-arch-4.png" alt="img"></p>
<h2 id="mybatis-的执行流程"><a href="#mybatis-的执行流程" class="headerlink" title="mybatis 的执行流程"></a>mybatis 的执行流程</h2><p><img src="/../../pic/fb8f06d7d8c544c8a9bf1885c44bf3be.png" alt="在这里插入图片描述"></p>
<ol>
<li>首先读取配置文件，然后加载映射文件，由SqlSessionFactory工厂对象去创建核心对象SqlSession，SqlSession对象会通过Executor执行器对象执行sql。</li>
<li>然后Executor执行器对象会调用StatementHandler对象去真正的访问数据库执行sql语句。在执行sql语句前MapperStatement会先对映射信息进行封装，存储要映射的SQL语句的id、参数等信息</li>
<li>然后调用ParameterHandler去设置编译参数【#{}，${}】</li>
<li>然后TypeHandler进行数据库类型和JavaBean类型映射处理。</li>
<li>然后调用JBDC原生API进行处理，获取执行结果，这个执行结果交给ResultSetHandler 来进行结果集封装，然后将结果返回给StatementHandler。</li>
</ol>
</body></html></div><div class="article-licensing box"><div class="licensing-title"><p>MySQL基础原理</p><p><a href="https://jerryzhu1229.github.io/2024/03/12/数据库/MySQL基础原理/">https://jerryzhu1229.github.io/2024/03/12/数据库/MySQL基础原理/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jerry Z</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-09-17</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a><a class="link-muted mr-2" rel="tag" href="/tags/mysql/">mysql</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AE%9E%E8%B7%B5/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">MySQL实践</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/03/12/java/JVM/"><span class="level-item">JVM</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基础"><span class="level-left"><span class="level-item">1</span><span class="level-item">基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#SQL-和-NOSQL-区别"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">SQL 和 NOSQL 区别</span></span></a></li><li><a class="level is-mobile" href="#三大范式✨"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">三大范式✨</span></span></a></li><li><a class="level is-mobile" href="#MySQL如何避免重复插入数据？"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">MySQL如何避免重复插入数据？</span></span></a></li><li><a class="level is-mobile" href="#CHAR-和-VARCHAR有什么区别？"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">CHAR 和 VARCHAR有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#Text数据类型可以无限大吗？"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Text数据类型可以无限大吗？</span></span></a></li><li><a class="level is-mobile" href="#说一下外键约束"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">说一下外键约束</span></span></a></li><li><a class="level is-mobile" href="#多表查询（各种join连接详解）"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">多表查询（各种join连接详解）</span></span></a></li><li><a class="level is-mobile" href="#MySQL的关键字in和exist"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">MySQL的关键字in和exist</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#IN"><span class="level-left"><span class="level-item">1.8.1</span><span class="level-item">IN</span></span></a></li><li><a class="level is-mobile" href="#EXISTS"><span class="level-left"><span class="level-item">1.8.2</span><span class="level-item">EXISTS</span></span></a></li></ul></li><li><a class="level is-mobile" href="#SQL查询语句的执行顺序是怎么样的？"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">SQL查询语句的执行顺序是怎么样的？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#存储引擎"><span class="level-left"><span class="level-item">2</span><span class="level-item">存储引擎</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#执行一条-SQL-查询语句，期间发生了什么-✨"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">执行一条 SQL 查询语句，期间发生了什么?✨</span></span></a></li><li><a class="level is-mobile" href="#MySQL-一行记录是怎么存储的？"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">MySQL 一行记录是怎么存储的？</span></span></a></li><li><a class="level is-mobile" href="#MySql-数据的存储结构✨"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">MySql 数据的存储结构✨</span></span></a></li><li><a class="level is-mobile" href="#MyISAM-和-InnoDB-✨"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">MyISAM 和 InnoDB ✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MyISAM-和-InnoDB有什么区别？"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">MyISAM 和 InnoDB有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#innoDB-比-MyISAM-好在哪？为什么是默认引擎"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">innoDB 比 MyISAM 好在哪？为什么是默认引擎</span></span></a></li><li><a class="level is-mobile" href="#各自适合什么场景"><span class="level-left"><span class="level-item">2.4.3</span><span class="level-item">各自适合什么场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#InnoDB的底层结构"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">InnoDB的底层结构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#索引"><span class="level-left"><span class="level-item">3</span><span class="level-item">索引</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#索引的分类是什么？"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">索引的分类是什么？</span></span></a></li><li><a class="level is-mobile" href="#聚簇索引与二级索引的区别✨"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">聚簇索引与二级索引的区别✨</span></span></a></li><li><a class="level is-mobile" href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？✨"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#B-Tree-vs-B-Tree"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">B+Tree vs B Tree</span></span></a></li><li><a class="level is-mobile" href="#B-Tree-vs-二叉树"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">B+Tree vs 二叉树</span></span></a></li><li><a class="level is-mobile" href="#B-Tree-vs-Hash"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">B+Tree vs Hash</span></span></a></li></ul></li><li><a class="level is-mobile" href="#B-树叶子节点数据如何存储，以及如何查找某一条数据✨"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">B+树叶子节点数据如何存储，以及如何查找某一条数据✨</span></span></a></li><li><a class="level is-mobile" href="#联合索引范围查询"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">联合索引范围查询</span></span></a></li><li><a class="level is-mobile" href="#索引下推"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">索引下推</span></span></a></li><li><a class="level is-mobile" href="#什么时候创建索引？✨"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">什么时候创建索引？✨</span></span></a></li><li><a class="level is-mobile" href="#有什么优化索引的方法？✨"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">有什么优化索引的方法？✨</span></span></a></li><li><a class="level is-mobile" href="#优化案例"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">优化案例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#SELECT-FROM-t-order-ORDER-BY-text-LIMIT-1000000-10"><span class="level-left"><span class="level-item">3.9.1</span><span class="level-item">SELECT * FROM t_order ORDER BY text LIMIT 1000000, 10</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MySQL-使用-like-“-x“，索引一定会失效吗？"><span class="level-left"><span class="level-item">3.10</span><span class="level-item">MySQL 使用 like “%x“，索引一定会失效吗？</span></span></a></li><li><a class="level is-mobile" href="#count-和-count-1-有什么区别？哪个性能最好？"><span class="level-left"><span class="level-item">3.11</span><span class="level-item">count(*) 和 count(1) 有什么区别？哪个性能最好？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#事务"><span class="level-left"><span class="level-item">4</span><span class="level-item">事务</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#事务有哪些特性？"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">事务有哪些特性？</span></span></a></li><li><a class="level is-mobile" href="#InnoDB-引擎通过什么技术来保证事务的这四个特性的呢？"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</span></span></a></li><li><a class="level is-mobile" href="#并行事务会引发什么问题？✨"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">并行事务会引发什么问题？✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#脏读"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">脏读</span></span></a></li><li><a class="level is-mobile" href="#不可重复读"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">不可重复读</span></span></a></li><li><a class="level is-mobile" href="#幻读"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">幻读</span></span></a></li></ul></li><li><a class="level is-mobile" href="#事务的隔离级别有哪些？各自的应用场景✨"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">事务的隔离级别有哪些？各自的应用场景✨</span></span></a></li><li><a class="level is-mobile" href="#Read-View"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">Read View</span></span></a></li><li><a class="level is-mobile" href="#MVCC✨"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">MVCC✨</span></span></a></li><li><a class="level is-mobile" href="#MySQL-可重复读隔离级别，完全解决幻读了吗？✨"><span class="level-left"><span class="level-item">4.7</span><span class="level-item">MySQL 可重复读隔离级别，完全解决幻读了吗？✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#场景一"><span class="level-left"><span class="level-item">4.7.1</span><span class="level-item">场景一</span></span></a></li><li><a class="level is-mobile" href="#场景二"><span class="level-left"><span class="level-item">4.7.2</span><span class="level-item">场景二</span></span></a></li><li><a class="level is-mobile" href="#如何解决幻读的场景"><span class="level-left"><span class="level-item">4.7.3</span><span class="level-item">如何解决幻读的场景</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#锁"><span class="level-left"><span class="level-item">5</span><span class="level-item">锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#mysql有哪些锁？"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">mysql有哪些锁？</span></span></a></li><li><a class="level is-mobile" href="#表锁和行锁的作用"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">表锁和行锁的作用</span></span></a></li><li><a class="level is-mobile" href="#全局锁"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">全局锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#全局锁应用场景"><span class="level-left"><span class="level-item">5.3.1</span><span class="level-item">全局锁应用场景</span></span></a></li><li><a class="level is-mobile" href="#加全局锁的缺点"><span class="level-left"><span class="level-item">5.3.2</span><span class="level-item">加全局锁的缺点</span></span></a></li><li><a class="level is-mobile" href="#既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？"><span class="level-left"><span class="level-item">5.3.3</span><span class="level-item">既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#表级锁"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">表级锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#表锁"><span class="level-left"><span class="level-item">5.4.1</span><span class="level-item">表锁</span></span></a></li><li><a class="level is-mobile" href="#元数据锁（MDL）"><span class="level-left"><span class="level-item">5.4.2</span><span class="level-item">元数据锁（MDL）</span></span></a></li><li><a class="level is-mobile" href="#意向锁"><span class="level-left"><span class="level-item">5.4.3</span><span class="level-item">意向锁</span></span></a></li><li><a class="level is-mobile" href="#AUTO-INC-锁"><span class="level-left"><span class="level-item">5.4.4</span><span class="level-item">AUTO-INC 锁</span></span></a></li></ul></li><li><a class="level is-mobile" href="#行级锁✨"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">行级锁✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Record-Lock-记录锁"><span class="level-left"><span class="level-item">5.5.1</span><span class="level-item">Record Lock-记录锁</span></span></a></li><li><a class="level is-mobile" href="#Gap-Lock-间隙锁"><span class="level-left"><span class="level-item">5.5.2</span><span class="level-item">Gap Lock-间隙锁</span></span></a></li><li><a class="level is-mobile" href="#Next-Key-Lock-临键锁"><span class="level-left"><span class="level-item">5.5.3</span><span class="level-item">Next-Key Lock-临键锁</span></span></a></li></ul></li><li><a class="level is-mobile" href="#什么-SQL-语句会加行级锁？"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">什么 SQL 语句会加行级锁？</span></span></a></li><li><a class="level is-mobile" href="#MySQL-行级锁的加锁规则"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">MySQL 行级锁的加锁规则</span></span></a></li><li><a class="level is-mobile" href="#update-没加索引会锁全表？"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">update 没加索引会锁全表？</span></span></a></li><li><a class="level is-mobile" href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><span class="level-left"><span class="level-item">5.9</span><span class="level-item">MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</span></span></a></li><li><a class="level is-mobile" href="#MySQL-死锁了，怎么办？"><span class="level-left"><span class="level-item">5.10</span><span class="level-item">MySQL 死锁了，怎么办？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#情况一"><span class="level-left"><span class="level-item">5.10.1</span><span class="level-item">情况一</span></span></a></li><li><a class="level is-mobile" href="#情况二"><span class="level-left"><span class="level-item">5.10.2</span><span class="level-item">情况二</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MySQL的update阻塞问题"><span class="level-left"><span class="level-item">5.11</span><span class="level-item">MySQL的update阻塞问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？"><span class="level-left"><span class="level-item">5.11.1</span><span class="level-item">MySQL两个线程的update语句同时处理一条数据，会不会有阻塞？</span></span></a></li><li><a class="level is-mobile" href="#两条update语句处理一张表的不同的主键范围的记录，一个15，会不会遇到阻塞？底层是为什么的？"><span class="level-left"><span class="level-item">5.11.2</span><span class="level-item">两条update语句处理一张表的不同的主键范围的记录，一个&lt;10，一个&gt;15，会不会遇到阻塞？底层是为什么的？</span></span></a></li><li><a class="level is-mobile" href="#如果2个范围不是主键或索引？还会阻塞吗？"><span class="level-left"><span class="level-item">5.11.3</span><span class="level-item">如果2个范围不是主键或索引？还会阻塞吗？</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#日志"><span class="level-left"><span class="level-item">6</span><span class="level-item">日志</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#undo-log✨"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">undo log✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#具体实现"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">具体实现</span></span></a></li><li><a class="level is-mobile" href="#两大作用"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">两大作用</span></span></a></li><li><a class="level is-mobile" href="#刷盘策略"><span class="level-left"><span class="level-item">6.1.3</span><span class="level-item">刷盘策略</span></span></a></li></ul></li><li><a class="level is-mobile" href="#为什么需要-Buffer-Pool？"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">为什么需要 Buffer Pool？</span></span></a></li><li><a class="level is-mobile" href="#redo-log✨"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">redo log✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#有了undolog为啥还需要redolog？"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">有了undolog为啥还需要redolog？</span></span></a></li><li><a class="level is-mobile" href="#什么是-redo-log？"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">什么是 redo log？</span></span></a></li><li><a class="level is-mobile" href="#被修改-Undo-页面，需要记录对应-redo-log-吗？"><span class="level-left"><span class="level-item">6.3.3</span><span class="level-item">被修改 Undo 页面，需要记录对应 redo log 吗？</span></span></a></li><li><a class="level is-mobile" href="#redo-log-和-undo-log-区别在哪？✨"><span class="level-left"><span class="level-item">6.3.4</span><span class="level-item">redo log 和 undo log 区别在哪？✨</span></span></a></li><li><a class="level is-mobile" href="#redo-log-要写到磁盘，数据也要写磁盘，为什么要多此一举？"><span class="level-left"><span class="level-item">6.3.5</span><span class="level-item">redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？</span></span></a></li><li><a class="level is-mobile" href="#redo-log怎么保证持久性？✨"><span class="level-left"><span class="level-item">6.3.6</span><span class="level-item">redo log怎么保证持久性？✨</span></span></a></li><li><a class="level is-mobile" href="#产生的-redo-log-是直接写入磁盘的吗？"><span class="level-left"><span class="level-item">6.3.7</span><span class="level-item">产生的 redo log 是直接写入磁盘的吗？</span></span></a></li><li><a class="level is-mobile" href="#redo-log-什么时候刷盘？✨"><span class="level-left"><span class="level-item">6.3.8</span><span class="level-item">redo log 什么时候刷盘？✨</span></span></a></li><li><a class="level is-mobile" href="#redo-log-文件写满了怎么办？"><span class="level-left"><span class="level-item">6.3.9</span><span class="level-item">redo log 文件写满了怎么办？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#binlog"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">binlog</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么需要-binlog-？"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">为什么需要 binlog ？</span></span></a></li><li><a class="level is-mobile" href="#能不能只用binlog不用redo-log？"><span class="level-left"><span class="level-item">6.4.2</span><span class="level-item">能不能只用binlog不用redo log？</span></span></a></li><li><a class="level is-mobile" href="#redo-log-和-binlog-有什么区别？"><span class="level-left"><span class="level-item">6.4.3</span><span class="level-item">redo log 和 binlog 有什么区别？</span></span></a></li><li><a class="level is-mobile" href="#如果不小心整个数据库的数据被删除了，能使用-redo-log-文件恢复数据吗？"><span class="level-left"><span class="level-item">6.4.4</span><span class="level-item">如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？</span></span></a></li><li><a class="level is-mobile" href="#主从复制是怎么实现？✨"><span class="level-left"><span class="level-item">6.4.5</span><span class="level-item">主从复制是怎么实现？✨</span></span></a></li><li><a class="level is-mobile" href="#binlog-什么时候刷盘？"><span class="level-left"><span class="level-item">6.4.6</span><span class="level-item">binlog 什么时候刷盘？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#为什么需要两阶段提交？✨"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">为什么需要两阶段提交？✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#两阶段提交的过程是怎样的？"><span class="level-left"><span class="level-item">6.5.1</span><span class="level-item">两阶段提交的过程是怎样的？</span></span></a></li><li><a class="level is-mobile" href="#异常重启会出现什么现象？"><span class="level-left"><span class="level-item">6.5.2</span><span class="level-item">异常重启会出现什么现象？</span></span></a></li><li><a class="level is-mobile" href="#两阶段提交有什么问题？"><span class="level-left"><span class="level-item">6.5.3</span><span class="level-item">两阶段提交有什么问题？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MySQL日志"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">MySQL日志</span></span></a></li></ul></li><li><a class="level is-mobile" href="#性能调优"><span class="level-left"><span class="level-item">7</span><span class="level-item">性能调优</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。✨"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">慢查询的原因。怎么定位慢查询，怎么优化慢查询，思路是什么。✨</span></span></a></li><li><a class="level is-mobile" href="#使用-explain-优化你的-mysql-性能✨"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">使用 explain 优化你的 mysql 性能✨</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Explain-特点"><span class="level-left"><span class="level-item">7.2.1</span><span class="level-item">Explain 特点</span></span></a></li><li><a class="level is-mobile" href="#Explain-中的列"><span class="level-left"><span class="level-item">7.2.2</span><span class="level-item">Explain 中的列</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#内存"><span class="level-left"><span class="level-item">8</span><span class="level-item">内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Buffer-Pool"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">Buffer Pool</span></span></a></li></ul></li><li><a class="level is-mobile" href="#MyBatis"><span class="level-left"><span class="level-item">9</span><span class="level-item">MyBatis</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#mybatis-的执行流程"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">mybatis 的执行流程</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/cs/"><span class="level-start"><span class="level-item">cs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">前端技术</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BF%90%E7%BB%B4/"><span class="level-start"><span class="level-item">运维</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a><p class="is-size-7"><span>&copy; 2024 Jerry Z</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>