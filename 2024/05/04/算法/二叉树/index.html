<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>二叉树 - hao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="hao"><meta name="msapplication-TileImage" content="/img/2751710164138_.pic.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="hao"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="hao"><meta property="og:url" content="https://jerryzhu1229.github.io/2024/05/04/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="og:site_name" content="hao"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/05EE17BA6FA1FB90EDDEF5A26D0FEEF4.gif"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/23368751A430C010C582743B0E2F9414.gif"><meta property="og:image" content="https://jerryzhu1229.github.io/pic/07986E476EB2CECD3C5F81D0BCADBE12.gif"><meta property="article:published_time" content="2024-05-04T06:31:43.000Z"><meta property="article:modified_time" content="2024-08-17T03:29:44.350Z"><meta property="article:author" content="Jerry Z"><meta property="article:tag" content="算法"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://jerryzhu1229.github.io/pic/05EE17BA6FA1FB90EDDEF5A26D0FEEF4.gif"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jerryzhu1229.github.io/2024/05/04/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"},"headline":"二叉树","image":["https://jerryzhu1229.github.io/pic/05EE17BA6FA1FB90EDDEF5A26D0FEEF4.gif","https://jerryzhu1229.github.io/pic/23368751A430C010C582743B0E2F9414.gif","https://jerryzhu1229.github.io/pic/07986E476EB2CECD3C5F81D0BCADBE12.gif"],"datePublished":"2024-05-04T06:31:43.000Z","dateModified":"2024-08-17T03:29:44.350Z","author":{"@type":"Person","name":"Jerry Z"},"publisher":{"@type":"Organization","name":"hao","logo":{"@type":"ImageObject","url":"https://jerryzhu1229.github.io/img/2751710164138_.pic.jpg"}},"description":""}</script><link rel="canonical" href="https://jerryzhu1229.github.io/2024/05/04/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"><link rel="icon" href="/img/2751710164138_.pic.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/cs">计算机基础</a><a class="navbar-item" href="/categories/java">后端开发</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/jerryzhu1229"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-05-04T06:31:43.000Z" title="2024/5/4 14:31:43">2024-05-04</time>发表</span><span class="level-item"><time dateTime="2024-08-17T03:29:44.350Z" title="2024/8/17 11:29:44">2024-08-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><span class="level-item">23 分钟读完 (大约3502个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">二叉树</h1><div class="content"><html><head></head><body><h1 id="二叉树解题的思维模式"><a href="#二叉树解题的思维模式" class="headerlink" title="二叉树解题的思维模式"></a>二叉树解题的思维模式</h1><p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>
<p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>
<p>无论使用哪种思维模式，你都需要思考：</p>
<p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做</strong>？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p>
<h1 id="116-填充节点的右侧指针"><a href="#116-填充节点的右侧指针" class="headerlink" title="116.填充节点的右侧指针"></a>116.填充节点的右侧指针</h1><p><strong>传统的 <code>traverse</code> 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「空隙」</strong>。</p>
<p>所以我们可以在二叉树的基础上进行抽象，你把图中的每一个方框看做一个节点：</p>
<p><strong>这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点</strong>。</p>
<h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><p>方法 1：递归</p>
<p>方法 2：栈</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>[] ans;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] preorderTraversal (TreeNode root) {</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{};</span><br><span class="line">        }</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>){</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>){</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); ++i){</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h2><p><strong>具体做法：</strong></p>
<ul>
<li>step 1：开辟一个辅助栈，用于记录要访问的子节点，开辟一个前序指针pre。</li>
<li>step 2：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。</li>
<li>step 3：弹出一个栈元素，看成该子树的根，判断这个根的右边有没有节点或是有没有被访问过，如果没有右节点或是被访问过了，可以访问这个根，并将前序节点标记为这个根。</li>
<li>step 4：如果没有被访问，那这个根必须入栈，进入右子树继续访问，只有右子树结束了回到这里才能继续访问根。</li>
</ul>
<p><strong>图示：</strong></p>
<p><img src="/../../pic/05EE17BA6FA1FB90EDDEF5A26D0FEEF4.gif" alt="alt"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] postorderTraversal (TreeNode root) {</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{};</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty()){</span><br><span class="line">            <span class="comment">//每次先找到最左边的节点</span></span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>){</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="comment">//如果当前节点的右孩子不空且没有访问</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span> &amp;&amp; node.right != pre){</span><br><span class="line">              <span class="comment">//保存根节点</span></span><br><span class="line">                stack.push(node);</span><br><span class="line">                root = node.right;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                pre = node;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); ++i){</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><p><strong>方法：栈</strong></p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：优先判断树是否为空，空树不遍历。</li>
<li>step 2：准备辅助栈，当二叉树节点为空了且栈中没有节点了，我们就停止访问。</li>
<li>step 3：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。</li>
<li>step 4：到达最左后，可以开始访问，如果它还有右节点，则将右边也加入栈中，之后右子树的访问也是优先到最左。</li>
</ul>
<p><strong>图示：</strong></p>
<p><img src="/../../pic/23368751A430C010C582743B0E2F9414.gif" alt="alt"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] inorderTraversal (TreeNode root) {</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]{};</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty()){</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">null</span>){</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>){</span><br><span class="line">                root = node.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); ++i){</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p>分解子问题</p>
<p>可以用 map 来存中序遍历值的对应下标</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;Integer, Integer&gt; val2idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.length; ++i){</span><br><span class="line">            val2idx.put(inorder[i],i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length-<span class="number">1</span>); <span class="comment">//左闭右闭</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preh, <span class="type">int</span> pret, <span class="type">int</span>[]inorder, <span class="type">int</span> inorh, <span class="type">int</span> inort)</span>{</span><br><span class="line">        <span class="keyword">if</span>(preh&gt;pret) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//左闭右闭</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preh]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> val2idx.get(preorder[preh]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> idx-inorh;</span><br><span class="line">        node.left = build(preorder, preh+<span class="number">1</span>, size+preh, inorder, inorh, idx-<span class="number">1</span>);</span><br><span class="line">        node.right = build(preorder, preh+<span class="number">1</span>+size, pret, inorder, idx+<span class="number">1</span>, inort);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106 从中序与后序遍历序列构造二叉树"></a>106 从中序与后序遍历序列构造二叉树</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;Integer, Integer&gt; val2idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;inorder.length; ++i){</span><br><span class="line">            val2idx.put(inorder[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length-<span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> h1, <span class="type">int</span> t1, <span class="type">int</span>[] postorder, <span class="type">int</span> h2, <span class="type">int</span> t2)</span>{</span><br><span class="line">        <span class="keyword">if</span>(h1 &gt; t1) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> postorder[t2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> val2idx.get(postorder[t2]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> idx-h1;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        node.left = build(inorder, h1, idx-<span class="number">1</span>, postorder, h2, h2+leftSize-<span class="number">1</span>);</span><br><span class="line">        node.right = build(inorder, idx+<span class="number">1</span>, t1, postorder, h2+leftSize, t2-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a>889. 根据前序和后序遍历构造二叉树</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;Integer, Integer&gt; val2idx = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;postorder.length; ++i){</span><br><span class="line">            val2idx.put(postorder[i], i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> h1, <span class="type">int</span> t1, <span class="type">int</span>[] postorder, <span class="type">int</span> h2, <span class="type">int</span> t2)</span>{</span><br><span class="line">        <span class="keyword">if</span>(h1&gt;t1) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[h1];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(h1 == t1) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val); <span class="comment">//下面要用h1+1所以避免越界这里要先判断是不是子树只有一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftVal</span> <span class="operator">=</span> preorder[h1+<span class="number">1</span>]; <span class="comment">//造成答案不唯一 可能是左子树也可能是右子树  例如123  321</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> val2idx.get(leftVal);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> idx-h2;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        node.left = build(preorder, h1+<span class="number">1</span>, h1+<span class="number">1</span>+leftSize, postorder, h2, h2+leftSize);</span><br><span class="line">        node.right = build(preorder, h1+<span class="number">1</span>+leftSize+<span class="number">1</span>, t1, postorder, h2+leftSize+<span class="number">1</span>, t2-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a>652. 寻找重复的子树</h2><blockquote>
<p>前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。</p>
<p><strong>那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了</strong>。</p>
</blockquote>
<p>思路：就是将子树序列化成唯一的表示</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        </span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">    String <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">" "</span>; <span class="comment">// 节点空 则用“ ”表示</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">      	<span class="comment">//序列化的形式是：root_left_right</span></span><br><span class="line">        sb.append(root.val).append(<span class="string">"_"</span>);</span><br><span class="line">        sb.append(dfs(root.left)).append(<span class="string">"_"</span>);</span><br><span class="line">        sb.append(dfs(root.right));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        map.put(s,map.getOrDefault(s, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map.get(s) == <span class="number">2</span>) list.add(root); </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="前-中-后序和二叉树的唯一性"><a href="#前-中-后序和二叉树的唯一性" class="headerlink" title="前/中/后序和二叉树的唯一性"></a>前/中/后序和二叉树的唯一性</h2><p>问题：</p>
<p>​	<strong>什么样的序列化的数据可以反序列化出唯一的一棵二叉树</strong>？</p>
<p>回答：</p>
<p>​	若包含空指针信息，前序和后序遍历能唯一确定一颗二叉树；但中序遍历不可以</p>
<p>愿意：</p>
<p>​	前序、后序遍历可以确定根节点位置；中序遍历根节点位置无法确定 </p>
<p><strong>总结</strong>：</p>
<ol>
<li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，那么你无法还原出唯一的一棵二叉树。</p>
</li>
<li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你会给出<strong>两种</strong>遍历顺序，分两种情况：</p>
<ol>
<li>如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。</li>
<li>如果你给出前序和后序，那么你无法还原出唯一的一棵二叉树。</li>
</ol>
</li>
<li><p>如果你的序列化结果中<strong>包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，也要分两种情况：</p>
<ol>
<li>如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。</li>
<li>如果你给出的是中序，那么你无法还原出唯一的一棵二叉树。</li>
</ol>
</li>
</ol>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><p><strong>具体做法：</strong>（不需要遍历所有 加入一个子树没有就返回另一个子树）</p>
<ul>
<li>step 1：首先判断t1与t2是否为空，若为则用另一个代替，若都为空，返回的值也是空。</li>
<li>step 2：然后依据前序遍历的特点，优先访问根节点，将两个根点的值相加创建到新树中。</li>
<li>step 3：两棵树再依次同步进入左子树和右子树。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Solution {</span><br><span class="line">    public TreeNode mergeTrees (TreeNode t1, TreeNode t2) {</span><br><span class="line">        //若只有一个节点返回另一个，两个都为null自然返回null</span><br><span class="line">        if (t1 == null) </span><br><span class="line">            return t2;</span><br><span class="line">        if (t2 == null)</span><br><span class="line">            return t1;</span><br><span class="line">        //根左右的方式递归</span><br><span class="line">        TreeNode head = new TreeNode(t1.val + t2.val);</span><br><span class="line">        head.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        head.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h2 id="判断是不是完全二叉树"><a href="#判断是不是完全二叉树" class="headerlink" title="判断是不是完全二叉树"></a>判断是不是完全二叉树</h2><p><strong>思路：</strong></p>
<p>对完全二叉树最重要的定义就是叶子节点只能出现在最下层和次下层，所以我们想到可以使用队列辅助进行层次遍历——从上到下遍历所有层，每层从左到右，只有次下层和最下层才有叶子节点，其他层出现叶子节点就意味着不是完全二叉树。</p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：先判断空树一定是完全二叉树。</li>
<li>step 2：初始化一个队列辅助层次遍历，将根节点加入。</li>
<li>step 3：逐渐从队列中弹出元素访问节点，如果遇到某个节点为空，进行标记，代表到了完全二叉树的最下层，若是后续还有访问，则说明提前出现了叶子节点，不符合完全二叉树的性质。</li>
<li>step 4：否则，继续加入左右子节点进入队列排队，等待访问。</li>
</ul>
<p><strong>图示：</strong></p>
<p><img src="/../../pic/07986E476EB2CECD3C5F81D0BCADBE12.gif" alt="alt"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span> <span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        Queue&lt;TreeNode&gt; queue  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">visitLeaf</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i){</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="literal">null</span>){</span><br><span class="line">                    visitLeaf = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(visitLeaf){</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;     </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h2><p><strong>思路：</strong></p>
<p>我们也可以利用二叉搜索树的性质：对于某一个节点若是p与q都小于等于这个这个节点值，说明p、q都在这个节点的左子树，而最近的公共祖先也一定在这个节点的左子树；若是p与q都大于等于这个节点，说明p、q都在这个节点的右子树，而最近的公共祖先也一定在这个节点的右子树。而若是对于某个节点，p与q的值一个大于等于节点值，一个小于等于节点值，说明它们分布在该节点的两边，而这个节点就是最近的公共祖先，因此从上到下的其他祖先都将这个两个节点放到同一子树，只有最近公共祖先会将它们放入不同的子树，每次进入一个子树又回到刚刚的问题，因此可以使用递归。</p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：首先检查空节点，空树没有公共祖先。</li>
<li>step 2：对于某个节点，比较与p、q的大小，若p、q在该节点两边说明这就是最近公共祖先。</li>
<li>step 3：如果p、q都在该节点的左边，则递归进入左子树。</li>
<li>step 4：如果p、q都在该节点的右边，则递归进入右子树。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; Math.min(p.val,q.val) &amp;&amp; root.val &gt; Math.max(p.val,q.val)){</span><br><span class="line">            <span class="keyword">return</span>  lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; Math.min(p.val,q.val) &amp;&amp; root.val &lt; Math.max(p.val,q.val)){</span><br><span class="line">            <span class="keyword">return</span>  lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p><strong>递归情况：</strong><br>1.当到达空节点（既叶子节点的子节点）时，直接返回空<br>2.当root等于 o1 或 o2 时，返回root<br>3.若不为1， 2中情况，说明需要继续处理：<br>对左子树进行递归，返回值记为 t1<br>对右子树进行递归，返回值记位 t2<br>t1 ，t2 存在以下几种情况：<br>①. 当t1, t2都为空时，说明root的左右子树中都不存在o1, o2， 返回空<br>②. 当t1为空且t2不为空时，说明左子树找不到 o1, o2,所以返回 t2<br>③. 当t2为空且t1不为空时，说明右子树找不到 o1, o2,所以返回 t1<br>④. 当t1, t2都不为空时,说明o1, o2分别位于root的左右子树中，既root为答案，返回root</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 遍历到空结点</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root; <span class="comment">// 找到结点p 或者 q</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root; <span class="comment">// 找到最深公共结点</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span>) <span class="keyword">return</span> left;   <span class="comment">// 将找到的结点信息传导到上一层</span></span><br><span class="line">        <span class="keyword">if</span>(right != <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h1 id="二叉搜索树-BSF"><a href="#二叉搜索树-BSF" class="headerlink" title="二叉搜索树 BSF"></a>二叉搜索树 BSF</h1><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h2><h3 id="解法-1："><a href="#解法-1：" class="headerlink" title="解法 1："></a>解法 1：</h3><p>在中序遍历的时候判断是不是遍历的值是不是递增</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 判断中序为升序 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        f &amp;= isValidBST(root.left); </span><br><span class="line">        <span class="keyword">if</span>(min &lt; root.val) min = root.val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        f &amp;= isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="解法-2："><a href="#解法-2：" class="headerlink" title="解法 2："></a>解法 2：</h3><p>遍历的时候控制范围</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">// 控制 node.val 值的范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, Integer min, Integer max)</span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(min!=<span class="literal">null</span> &amp;&amp; min &gt;= root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(max!=<span class="literal">null</span> &amp;&amp; max &lt;= root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, min, root.val) &amp;&amp; dfs(root.right, root.val, max);  </span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val == root.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>若是在一颗普通的二叉树中寻找</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val == root.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> searchBST(root.left, val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> searchBST(root.right, val);</span><br><span class="line">        <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right; </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><p>上一个问题，我们总结了 BST 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。<strong>一旦涉及「改」，就类似二叉树的构造问题，函数要返回 <code>TreeNode</code> 类型，并且要对递归调用的返回值进行接收</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val){</span><br><span class="line">            root.right =insertIntoBST(root.right, val); </span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val){</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a>450. 删除二叉搜索树中的节点</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key){</span><br><span class="line">            <span class="comment">//找到了 有三种情况</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//左节点空</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>){</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//右节点空</span></span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="literal">null</span>){</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//左右节点都不空</span></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>){</span><br><span class="line">                <span class="comment">//找左子树的最大值</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span>(l.right != <span class="literal">null</span>){</span><br><span class="line">                    l = l.right;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 删除左子树最大的节点</span></span><br><span class="line">                root.left = deleteNode(root.left, l.val);</span><br><span class="line">                <span class="comment">// 用左子树最大的节点替换 root 节点</span></span><br><span class="line">                l.left = root.left;</span><br><span class="line">                l.right = root.right;</span><br><span class="line">                root = l;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key){</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key){</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="96-不同的搜索树"><a href="#96-不同的搜索树" class="headerlink" title="96. 不同的搜索树"></a>96. 不同的搜索树</h2><ul>
<li>标签：动态规划</li>
<li>假设 <code>n</code> 个节点存在二叉排序树的个数是 <code>G (n)</code>，令 <code>f(i)</code> 为以 <code>i</code> 为根的二叉搜索树的个数，则</li>
</ul>
<p>$$<br>G(n)=f(1)+f(2)+f(3)+f(4)+…+f(n)<br>$$</p>
<ul>
<li>当 <code>i</code> 为根节点时，其左子树节点个数为 <code>i-1</code> 个，右子树节点为 <code>n-i</code>，则</li>
</ul>
<p>$$<br>f(i)=G(i−1)∗G(n−i)<br>$$</p>
<ul>
<li>综合两个公式可以得到 <a href="https://leetcode.cn/link/?target=https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0">卡特兰数</a> 公式</li>
</ul>
<p>$$<br>G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+…+G(n−1)∗G(0)<br>$$</p>
<p>那么就是要用两层 for 循环：</p>
<ol>
<li>外层 <code>i</code> 循环 2～n</li>
<li>内层 <code>j</code> 循环 0～i-1</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=i-<span class="number">1</span>; ++j){</span><br><span class="line">                dp[i] += dp[j] * dp[i-<span class="number">1</span>-j]; </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="96-不同的搜索树II"><a href="#96-不同的搜索树II" class="headerlink" title="96. 不同的搜索树II"></a>96. 不同的搜索树II</h2><p>首先要想到这是问题分解。</p>
<p>遍历应该是后序，因为要用到子节点返回的子树来新建父亲节点</p>
<p>不同的是每一层递归都需要一个局部的 list 来存当前根节点</p>
<p>递归结束的条件是[start,end]为空，那么就给 list 加入 null，以便回溯的时候根节点可以用到无子树的情况，若不加 null 那么就会一直进入不了内层的两个循环体</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    List&lt;TreeNode&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">1</span>, n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    List&lt;TreeNode&gt; <span class="title function_">build</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>{</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end){</span><br><span class="line">            list.add(<span class="literal">null</span>);<span class="comment">//关键 相当于[start, end]没有要新建的点</span></span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        } </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start; i&lt;=end; ++i){</span><br><span class="line">            List&lt;TreeNode&gt; leftList = build(start, i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightList = build(i+<span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftList){</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right : rightList){</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    list.add(node);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





</body></html></div><div class="article-licensing box"><div class="licensing-title"><p>二叉树</p><p><a href="https://jerryzhu1229.github.io/2024/05/04/算法/二叉树/">https://jerryzhu1229.github.io/2024/05/04/算法/二叉树/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Jerry Z</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-05-04</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-08-17</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/05/04/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">链表</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/05/04/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="level-item">动态规划</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#二叉树解题的思维模式"><span class="level-left"><span class="level-item">1</span><span class="level-item">二叉树解题的思维模式</span></span></a></li><li><a class="level is-mobile" href="#116-填充节点的右侧指针"><span class="level-left"><span class="level-item">2</span><span class="level-item">116.填充节点的右侧指针</span></span></a></li><li><a class="level is-mobile" href="#遍历"><span class="level-left"><span class="level-item">3</span><span class="level-item">遍历</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#144-二叉树的前序遍历"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">144. 二叉树的前序遍历</span></span></a></li><li><a class="level is-mobile" href="#145-二叉树的后序遍历"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">145. 二叉树的后序遍历</span></span></a></li><li><a class="level is-mobile" href="#94-二叉树的中序遍历"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">94. 二叉树的中序遍历</span></span></a></li><li><a class="level is-mobile" href="#105-从前序与中序遍历序列构造二叉树"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">105. 从前序与中序遍历序列构造二叉树</span></span></a></li><li><a class="level is-mobile" href="#106-从中序与后序遍历序列构造二叉树"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">106 从中序与后序遍历序列构造二叉树</span></span></a></li><li><a class="level is-mobile" href="#889-根据前序和后序遍历构造二叉树"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">889. 根据前序和后序遍历构造二叉树</span></span></a></li><li><a class="level is-mobile" href="#652-寻找重复的子树"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">652. 寻找重复的子树</span></span></a></li><li><a class="level is-mobile" href="#前-中-后序和二叉树的唯一性"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">前/中/后序和二叉树的唯一性</span></span></a></li><li><a class="level is-mobile" href="#617-合并二叉树"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">617. 合并二叉树</span></span></a></li><li><a class="level is-mobile" href="#判断是不是完全二叉树"><span class="level-left"><span class="level-item">3.10</span><span class="level-item">判断是不是完全二叉树</span></span></a></li><li><a class="level is-mobile" href="#235-二叉搜索树的最近公共祖先"><span class="level-left"><span class="level-item">3.11</span><span class="level-item">235. 二叉搜索树的最近公共祖先</span></span></a></li><li><a class="level is-mobile" href="#236-二叉树的最近公共祖先"><span class="level-left"><span class="level-item">3.12</span><span class="level-item">236. 二叉树的最近公共祖先</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二叉搜索树-BSF"><span class="level-left"><span class="level-item">4</span><span class="level-item">二叉搜索树 BSF</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#98-验证二叉搜索树"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">98. 验证二叉搜索树</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#解法-1："><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">解法 1：</span></span></a></li><li><a class="level is-mobile" href="#解法-2："><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">解法 2：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#700-二叉搜索树中的搜索"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">700. 二叉搜索树中的搜索</span></span></a></li><li><a class="level is-mobile" href="#701-二叉搜索树中的插入操作"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">701. 二叉搜索树中的插入操作</span></span></a></li><li><a class="level is-mobile" href="#450-删除二叉搜索树中的节点"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">450. 删除二叉搜索树中的节点</span></span></a></li><li><a class="level is-mobile" href="#96-不同的搜索树"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">96. 不同的搜索树</span></span></a></li><li><a class="level is-mobile" href="#96-不同的搜索树II"><span class="level-left"><span class="level-item">4.6</span><span class="level-item">96. 不同的搜索树II</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/cs/"><span class="level-start"><span class="level-item">cs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">中间件</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">前端技术</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%BF%90%E7%BB%B4/"><span class="level-start"><span class="level-item">运维</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/2751710164138_.pic.jpg" alt="hao" height="28"></a><p class="is-size-7"><span>&copy; 2024 Jerry Z</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>