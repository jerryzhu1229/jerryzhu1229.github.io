{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/project/2024/03/11/hello-world/"},{"title":"计算机网络","text":"","link":"/project/2024/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"面经","text":"java 基础常见面试题基础概念JVM vs JDK vs JREJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。 JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。 JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。 什么是字节码?采用字节码的好处是什么?在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。 Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。 为什么说 Java 语言“编译与解释并存”？编译型语言：执行效率高、开发效率低 解释型语言：开发效率高、执行效率低 Java语言需要经过编译(源码经过 javac 编译变成字节码)、解释（字节码经过 解释器和 JIT(即时编译器)变成机器码） AOT 有什么优点？为什么不全部使用 AOT 呢？AOT(ahead of time Compilation)。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译） 优点：启动速度、内存占用、打包体积。 缺点：极限处理能力不如 JIT AOT 不能使用反射、动态代理、动态加载，常用框架和库（spring，CGLIB）都需要这些特性质。 基本数据类型基本类型和包装类型的区别？ 基本类型 vs 包装类型 用途： 基本类型：定义常量和局部变量 包装类型：方法参数、对象属性 包装类型可用于泛型，而基本类型不可以。 存储方式： 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中（类的实例），被static 修饰的存放在 Java 虚拟机的堆中（Class对象）。 包装类型属于对象类型，几乎所有对象实例都存在于堆中。 占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。 默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。 比较方式：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。 为什么说是几乎所有对象实例都存在于堆中呢？这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存不充部分 基本数据类型是否都存放在栈中？基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中(是否被 static 修饰都是在堆中) 包装类型的缓存机制了解么？作用：提升性能 Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。 Character 缓存源码: 1234567891011121314public static Character valueOf(char c) { if (c &lt;= 127) { // must cache return CharacterCache.cache[(int)c]; } return new Character(c);}private static class CharacterCache { private CharacterCache(){} static final Character cache[] = new Character[127 + 1]; static { for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); }} 如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。 两种浮点数类型的包装类 Float,Double 并没有实现缓存机制。 自动装箱与拆箱了解吗？原理是什么？什么是自动拆装箱？ 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。 因此， Integer i = 10 等价于 Integer i = Integer.valueOf(10) int n = i 等价于 int n = i.intValue(); 注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。（常量、局部变量用基本数据类型） 为什么浮点数运算的时候会有精度丢失的风险？与计算机保存浮点数机制有关。表示一个数字时，宽度有限，无线循环的小数存储在计算机时只能被截断，所以导致精度丢失。 浮点型从二进制的视角是怎么存储的？符号位+指数位+尾号位 这32个二进制位的内存编号从高到低 (从31到0), 共包含如下几个部分: sign: 符号位, 即图中蓝色的方块 biased exponent: 偏移后的指数位（偏移量 127 保证指数非负数）, 即图中绿色的方块 fraction: 尾数位, 即图中红色的方块 （IEEE 754）小数位如何计算出来的？如果我们现在想用浮点数表示 0.2，它的结果会是多少呢？ 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。 1234560.2 * 2 = 0.4 -&gt; 00.4 * 2 = 0.8 -&gt; 00.8 * 2 = 1.6 -&gt; 10.6 * 2 = 1.2 -&gt; 10.2 * 2 = 0.4 -&gt; 0（发生循环）... 所以 0.2(D) = 0.00110…(B)。 如何解决浮点数运算的精度丢失问题？BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。 超过 long 整型的数据应该如何表示？基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。 在 Java 中，64 位 long 整型是最大的整数类型。 123long l = Long.MAX_VALUE;System.out.println(l + 1); // -9223372036854775808System.out.println(l + 1 == Long.MIN_VALUE); // true BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。 相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。 变量成员变量与局部变量的区别？ 语法形式：成员变量属于类，局部变量属于代码块、方法定义变量和方法的参数；成员变量可以被访问控制修饰符以及static 修饰、局部变量不可以。 存储方式：成员变量存在于堆内存，局部变量则存在于栈内存。 生存时间：从变量在内存中的生存时间上看，成员变量——对象同步，而局部变量——方法同步。 默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 为什么成员变量有默认值？ 不考虑变量类型。若没有默认值，变量存储的是内存地址对应的任意随机值，即遗留值，可以会出现意外或信息泄露问题 对于编译器 javac 来说，局部变量没赋值很好判断，可以直接报错。而成员变量可能是运行时赋值，无法判断，误报“没默认值”影响用户体验，所以采用自动赋默认值 静态变量有什么作用？所有类的实例共用一份静态变量，节省内存 （若被 private 修饰就不能用类名.变量名访问） 通常情况下，静态变量会被 final 关键字修饰成为常量。 字符型常量和字符串常量的区别?形式 : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。 含义 : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。 占内存大小：字符常量只占 2 个字节; 字符串常量占若干个字节。 ⚠️ 注意 char 在 Java 中占两个字节。 方法静态方法为什么不能调用非静态成员?在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。 静态方法和实例方法有何不同？ 调用方式： ​ 在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式，而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象 。 ​ 为了避免混淆建议静态方法使用前一种 访问类成员是否存在限制： ​ 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。 重载和重写有什么区别？重载 发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 重写 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类（更精细），访问修饰符范围大于等于父类。 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。 构造方法无法被重写 总结 综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。 方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》，issue#892open in new window ）： “两同”即方法名相同、形参列表相同； “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。 ⭐️ 关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。 面相对象基础面向对象和面向过程的区别两者的主要区别在于解决问题的方式不同： 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。 另外，面向对象开发的程序一般更易维护、易复用、易扩展。 对象的相等和引用相等的区别 对象的相等一般比较的是内存中存放的内容是否相等。 引用相等一般比较的是他们指向的内存地址是否相等。 如果一个类没有声明构造方法，该程序能正确执行吗?构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。 如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。 我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。 构造方法有哪些特点？是否可被 override?构造方法特点如下： 名字与类名相同。 没有返回值，但不能用 void 声明构造函数。 生成类的对象时自动执行，无需调用。 构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 面向对象三大特征封装 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。 继承 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。 关于继承如下 3 点请记住： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 多态 多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。 多态的特点: 对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 *接口和抽象类有什么共同点和区别？共同点： 都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。 区别： 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。 一个类只能继承一个类，但是可以实现多个接口。 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？关于深拷贝和浅拷贝区别，我这里先给结论： 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。 深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。 ObjectObject 类的常见方法有哪些？1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */public final native Class&lt;?&gt; getClass()/** * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。 */public native int hashCode()/** * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。 */public boolean equals(Object obj)/** * native 方法，用于创建并返回当前对象的一份拷贝。 */protected native Object clone() throws CloneNotSupportedException/** * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。 */public String toString()/** * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。 */public final native void notify()/** * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 */public final native void notifyAll()/** * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。 */public final native void wait(long timeout) throws InterruptedException/** * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。 */public final void wait(long timeout, int nanos) throws InterruptedException/** * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 */public final void wait() throws InterruptedException/** * 实例被垃圾回收器回收的时候触发的操作 */protected void finalize() throws Throwable { } == 和 equals() 的区别== 对于基本类型和引用类型的作用效果是不同的： 对于基本数据类型来说，== 比较的是值。 对于引用数据类型来说，== 比较的是对象的内存地址。 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。 equals() 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。 Object 类 equals() 方法： 123public boolean equals(Object obj) { return (this == obj);} equals() 方法存在两种使用情况： 类没有重写 equals()方法：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。 类重写了 equals()方法：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。 hashCode() 有什么用？hashCode() 的作用是获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是：Object 的 hashCode() 方法是本地方法，也就是用 C 语言或 C++ 实现的。 ⚠️ 注意：该方法在 Oracle OpenJDK8 中默认是 “使用线程局部状态来实现 Marsaglia’s xor-shift 随机数生成”, 并不是 “地址” 或者 “地址转换而来”, 不同 JDK/VM 可能不同在 Oracle OpenJDK8 中有六种生成方式 (其中第五种是返回地址), 通过添加 VM 参数: -XX:hashCode=4 启用第五种。 为什么要有 hashCode？在 HashMap 和 HashSet 中都需要用到 hashCode，以 HashSet 为例： ​ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 其实， hashCode() 和 equals()都是用于比较两个对象是否相等。 那为什么 JDK 还要同时提供这两个方法呢？ 这是因为在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高 那为什么不只提供 hashCode() 方法呢？ 这是因为两个对象的hashCode 值相等并不代表两个对象就相等。 那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？ 因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 hashCode )。 总结下来就是： 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。 如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。 为什么重写 equals() 时必须重写 hashCode() 方法？因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。 思考：重写 equals() 时没有重写 hashCode() 方法的话，使用 HashMap 可能会出现什么问题。 两个相同的对象加到 HashMap 中，对应的 hashCode 不同，但是 HashMap 是先判断 hashCode 是否相同来判断是否有重复 key，最终会导致 HashMap 存在两个相同的对象同时作为 Key，这与 HashMap 的 key 不可以重复相悖。 总结： equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 两个对象有相同的 hashCode 值，他们也不一定是相等的（哈希碰撞）。 概念对象 Object：表示的是某一类事物的抽象的名词和概念，是对一类事物的抽象表示 类 Class：对象在计算机中的表示，如定义一个“人”的类 实例 Instance：根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 Oop：ordinary object point 对象的创建过程 申请空间，给成员变量赋默认值 调用 init 构造函数，给成员变量赋值 建立引用和对象的连接 单例模式饿汉式12345678910/** * 饿汉式单例模式 */public class singletonPattern01 { private static final singletonPattern01 SINGLE = new singletonPattern01(); private singletonPattern01(){}; public static singletonPattern01 getSingle(){ return SINGLE; }} 优点：这种写法比较简单，就是在类加载的时候就完成实例化。避免了线程同步问题。 缺点：在类加载的时候就完成实例化，没有达到Lazy Loading的效果。如果从未使用过这个实例，则会造成内存的浪费。 懒汉式起到了Lazy Loading的效果，但是只能在单线程下使用。 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式。 结论：在实际开发中，不要使用这种方式. 1234567891011121314 * 懒汉式单例模式 */public class singletonPattern02 { private static singletonPattern02 SINGLE; private singletonPattern02(){ }; public static singletonPattern02 getInstance(){ if(SINGLE == null){ SINGLE = new singletonPattern02(); } return SINGLE; }} 双重检查锁（DCL double check lock）双重检查概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。 这样，实例化代码只会执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步. 线程安全；延迟加载；效率较高 结论：在实际开发中，推荐使用这种单例设计模式 12345678910111213141516171819202122public class singletonPattern02 { private static volatile singletonPattern02 SINGLE; private singletonPattern02(){ }; public static singletonPattern02 getInstance(){ if(SINGLE == null){ synchronized (singletonPattern02.class){ if (SINGLE == null){ try{ Thread.sleep(1L); }catch (InterruptedException e) { e.printStackTrace(); } SINGLE = new singletonPattern02(); } } } return SINGLE; }} DCL要不要加 volatile 要。 假如 new singletonPattern02()时候发生指令重排序，先建立了连接，那么 SINGLE！=null ，多线程时候另一个线程就会直接 返回半初始化的对象。 所以说，这段代码要不要加volatile？必须加！加了volatile的这块内存，对于它的读写访问不可以重排序！ https://blog.csdn.net/zhaoyajie1011/article/details/106812327 静态内部类形式这种方式采用了类加载的机制来保证初始化实例时只有一个线程。 静态内部类方式在Singleton类被加载时并不会立即实例化，而是在需要实例化时，调用getSingleTon方法，才会加载Inner类，从而完成Singleton的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高 结论：推荐使用. 1234567891011public class singletonPattern03 { private singletonPattern03(){}; private static class singletonHolder{ private static singletonPattern03 SINGLE = new singletonPattern03(); } public static singletonPattern03 getInstance(){ return singletonHolder.SINGLE; }} java中的引用类型的对象存放在哪里根据上下文来确定。 123456789void func(){ Object obj = new Object();//这个obj在函数的栈里。}class Test{ private Object obj = new Object();//这个obj随对应的Test对象分配在堆里} 对于方法中的局部变量的引用时存放在java运行时数据区的栈中 对于实例变量则是存放在java运行时数据区的堆中。 Class 实例究竟在 method area 还是在 heaphotspot使用了 OOP-KLASS 模型来表示 java 对象 main方法中：Object o = new Object(); jvm在加载class时，创建instanceKlass，表示其元数据，包括常量池、字段、方法等，存放在方法区；instanceKlass是jvm中的数据结构；（vm加载的字节码，也就是.class文件，被加载到方法区里面，叫Klass，是一个C++对象，含有类的信息、虚方法表等。） 在new一个对象时，jvm创建instanceOopDesc，来表示这个对象，存放在堆区，其引用，存放在栈区；它用来表示对象的实例信息，看起来像个指针实际上是藏在指针里的对象；instanceOopDesc对应java中的对象实例； HotSpot并不把instanceKlass暴露给Java，而会另外创建对应的instanceOopDesc来表示java.lang.Class对象，并将后者称为前者的“Java镜像”，klass持有指向oop引用(_java_mirror便是该instanceKlass对Class对象的引用)； 要注意，new操作返回的instanceOopDesc类型指针指向instanceKlass，而instanceKlass指向了对应的类型的Class实例的instanceOopDesc；有点绕，简单说，就是Person实例——&gt;Person的instanceKlass——&gt;Person的Class。 对象在内存中的存储布局instanceOopDesc，只包含数据信息，它包含三部分： Mark Word，主要存储对象运行时记录信息，如hashcode, GC分代年龄，锁状态标志，线程ID，时间戳等; （64 位 os 就是 64 位即 8 字节） 元数据指针，即指向方法区的instanceKlass实例（压缩钱 8 字节，压缩后 4 字节） 实例数据; （成员变量） 另外，如果是数组对象，还多了一个数组长度 对象如何定位直接使用直接指针访问，Java堆中对象的内存布局就必须考虑如何防止访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。 间接（句柄访问）使用句柄访问，Java堆中将可能会划分出一块内存用来作为句柄池，reference中寸的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。 两种访问方式的优势句柄访问： 最大的好处是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。指针访问：最大的好处时速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。 对象怎么分配 判断分配到栈上。 逃逸分析。没有发生逃逸的对象优先尝试在栈上分配 是否大。 jvm 调优 TLAB。线程本地分配缓存 多线程时，给各线程分配特定的空间 为什么 hotspot 不实用 c++对象来代表 java 对象c++对象有虚函数表，java 对象的虚函数表在 Class 对象中 StringString、StringBuffer、StringBuilder 的区别？可变性 String 是不可变的（后面会详细分析原因）。 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer String 为什么是不可变的?被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，final 关键字修饰的数组保存字符串并不是 String不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。 String 真正不可变有下面几点原因： 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 不可变的好处 这个最简单地原因，就是为了安全。 再看下面这个HashSet用StringBuilder做元素的场景，问题就更严重了，而且更隐蔽。 123456789101112131415class Test{ public static void main(String[] args){ HashSet&lt;StringBuilder&gt; hs=new HashSet&lt;StringBuilder&gt;(); StringBuilder sb1=new StringBuilder(\"aaa\"); StringBuilder sb2=new StringBuilder(\"aaabbb\"); hs.add(sb1); hs.add(sb2); //这时候HashSet里是{\"aaa\",\"aaabbb\"} StringBuilder sb3=sb1; sb3.append(\"bbb\"); //这时候HashSet里是{\"aaabbb\",\"aaabbb\"} System.out.println(hs); }}//Output://[aaabbb, aaabbb] StringBuilder型变量sb1和sb2分别指向了堆内的字面量“aaa”和”aaabbb”。把他们都插入一个HashSet。到这一步没问题。但如果后面我把变量sb3也指向sb1的地址，再改变sb3的值，因为StringBuilder没有不可变性的保护，sb3直接在原先”aaa”的地址上改。导致sb1的值也变了。这时候，HashSet上就出现了两个相等的键值”aaabbb”。破坏了HashSet键值的唯一性。所以千万不要用可变类型做HashMap和HashSet键值。 字符串拼接用“+” 还是 StringBuilder?Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。 字符串对象通过“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。 不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。 不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 makeConcatWithConstants() 来实现，而不是大量的 StringBuilder 了。 String s1 = new String(“abc”);这句话创建了几个字符串对象？会创建 1 或 2 个字符串对象。 1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。 示例代码（JDK 1.8）： 1String s1 = new String(\"abc\"); 对应的字节码： ldc 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。 2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。 示例代码（JDK 1.8）： 1234// 字符串常量池中已存在字符串对象“abc”的引用String s1 = \"abc\";// 下面这段代码只会在堆中创建 1 个字符串对象“abc”String s2 = new String(\"abc\"); 对应的字节码： 这里就不对上面的字节码进行详细注释了，7 这个位置的 ldc 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 ldc 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 ldc 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。 *String#intern 方法有什么作用?String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况： 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。 应用场景使用方法 1234567public class Person{String name; public void setName(String paramString) { String str = paramString.intern(); }} 这里是一个能展现出inern()实际作用的场景,首先假设我从数据库里读了一个人的信息出来,然后把这个人的名字赋值给这个Person对象.那么,从数据库读数据,毫无疑问得创建一个字符串对象出来,假定读了10个人的数据,其中三个都叫小明,那么在不使用intern()的情况下,对字符串对象的引用情况如图所示 在使用intern的情况下,对字符串对象的引用情况如图所示 很显然,剩下的那两个小明字符串对象,就都可以回收了,大大节省空间. String 类型的变量和常量做“+”运算时发生了什么？ 先来看字符串不加 final 关键字拼接的情况（JDK1.8）： 12345678String str1 = \"str\";String str2 = \"ing\";String str3 = \"str\" + \"ing\";String str4 = str1 + str2;String str5 = \"string\";System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false 在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。 常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。 对于 String str3 = \"str\" + \"ing\"; 编译器会给你优化成 String str3 = \"string\"; 。 并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以： 基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。 final 修饰的基本数据类型和字符串变量 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ） 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。 对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。 我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。 不过，字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。 示例代码： 123456final String str1 = \"str\";final String str2 = \"ing\";// 下面两个表达式其实是等价的String c = \"str\" + \"ing\";// 常量池中的对象String d = str1 + str2; // 常量池中的对象System.out.println(c == d);// true 被 final 关键字修饰之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。 如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。 示例代码（str2 在运行时才能确定其值）： 12345678final String str1 = \"str\";final String str2 = getStr();String c = \"str\" + \"ing\";// 常量池中的对象String d = str1 + str2; // 在堆上创建的新的对象System.out.println(c == d);// falsepublic static String getStr() { return \"ing\";} 异常Exception 和 Error 有什么区别？在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类: Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。 Error：Error 属于程序无法处理的错误 ，我们不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止 Checked Exception 和 Unchecked Exception 有什么区别？Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws关键字处理的话，就没办法通过编译。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException…。 Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。 RuntimeException 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）： NullPointerException(空指针错误) IllegalArgumentException(参数错误比如方法入参类型错误) NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类） ArrayIndexOutOfBoundsException（数组越界错误） ClassCastException（类型转换错误） ArithmeticException（算术错误） SecurityException （安全错误比如权限不够） UnsupportedOperationException(不支持的操作错误比如重复创建同一用户) Throwable 类常用方法有哪些？ String getMessage(): 返回异常发生时的简要描述 String toString(): 返回异常发生时的详细信息 String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同 void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息 try-catch-finally 如何使用？ try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch块：用于处理 try 捕获到的异常。 finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。 注意：不要在 finally 语句块中使用 return! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。 123456789101112131415public static void main(String[] args) { System.out.println(f(2));}public static int f(int value) { try { return value * value; } finally { if (value == 2) { return 0; } }}输出0 finally 中的代码一定会执行吗？不一定的！在某些情况下，finally 中的代码不会被执行。 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。 程序所在的线程死亡。 关闭 CPU。 如何使用 try-with-resources 代替try-catch-finally？适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象 关闭资源和 finally 块的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行 Java 中类似于InputStream、OutputStream、Scanner、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下： 1234567891011121314//读取文本文件的内容Scanner scanner = null;try { scanner = new Scanner(new File(\"D://read.txt\")); while (scanner.hasNext()) { System.out.println(scanner.nextLine()); }} catch (FileNotFoundException e) { e.printStackTrace();} finally { if (scanner != null) { scanner.close(); }} 使用 Java 7 之后的 try-with-resources 语句改造上面的代码: 1234567try (Scanner scanner = new Scanner(new File(\"test.txt\"))) { while (scanner.hasNext()) { System.out.println(scanner.nextLine()); }} catch (FileNotFoundException fnfe) { fnfe.printStackTrace();}a 当然多个资源需要关闭的时候，使用 try-with-resources 实现起来也非常简单，如果你还是用try-catch-finally可能会带来很多问题。 通过使用分号分隔，可以在try-with-resources块中声明多个资源。 12345678910try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(\"test.txt\"))); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(\"out.txt\")))) { int b; while ((b = bin.read()) != -1) { bout.write(b); }}catch (IOException e) { e.printStackTrace();} 异常使用有哪些需要注意的地方？ 不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。 抛出的异常信息一定要有意义。 建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。 使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。 …… 泛型什么是泛型？泛型：是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，而这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口。注意:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 有什么作用？ 避免了类型强转的麻烦。 它提供了编译期的类型安全，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。 泛型的使用方式有哪几种？ 泛型类： 泛型类型用于类的定义中，被称为泛型类。最典型的就是各种集合框架容器类，如：List、Set、Map。 123456789101112131415161718192021222324泛型类的定义格式：修饰符 class 类名&lt;代表泛型的变量&gt; { }怕你不清楚怎么使用，这里我还是做了一个简单的泛型类：/** * @param &lt;T&gt; 这里解释下&lt;T&gt;中的T: * 此处的T可以随便写为任意标识，常见的有T、E等形式的参数表示泛型 * 泛型在定义的时候不具体，使用的时候才变得具体。 * 在使用的时候确定泛型的具体数据类型。即在创建对象的时候确定泛型。 */public class Generic&lt;T&gt;{ private T key; public Generic(T key) { this.key = key; } public T getKey(){ return key; }}泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。即：在创建对象的时候确定泛型。 泛型接口： 12345定义格式修饰符 interface接口名&lt;代表泛型的变量&gt; { }public interface Generator&lt;T&gt; { public T method();} 实现泛型接口，不指定类型： 123456class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;{ @Override public T method() { return null; }} 实现泛型接口，指定类型： 123456class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;{ @Override public String method() { return \"hello\"; }} 泛型方法： 123456789101112131415161718192021222324定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){ }例如：/** * * @param t 传入泛型的参数 * @param &lt;T&gt; 泛型的类型 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型。 */ public &lt;T&gt; T genercMethod(T t){ System.out.println(t.getClass()); System.out.println(t); return t;}fanxing fanxing = new fanxing();String string = fanxing.genercMethod(\"string\");Integer integer = fanxing.genercMethod(123); 泛型通配符 当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 12345678static void tongpeifu(List&lt;?&gt; list){ //只能用 Object 修饰，所以也只能用 Object 自带的方法 Object o = list.get(0);}public static void main(String[] args) { tongpeifu(Arrays.asList(\"1111\"));} 通配符基本使用 泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。 此时只能接受数据,不能往该集合中存储数据。 12345678// ？代表可以接收任意类型// 泛型不存在继承、多态关系,泛型左右两边要一样。jdk1.7后右边的泛型可以省略//ArrayList&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的//泛型通配符?:左边写&lt;?&gt; 右边的泛型可以是任意类型ArrayList&lt;?&gt; list = new ArrayList&lt;String&gt;();//编译错误 不可以存储数据list.add(\"1111\"); 泛型通配符?主要应用在参数传递方面 12345678public static void main(String[] args) { ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); test(list1); ArrayList&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); test(list2);}public static void test(ArrayList&lt;?&gt; coll){} 通配符高级使用 之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 123456789101112131415161718192021public static void main(String[] args) { Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement1(list1); getElement1(list2);//报错 getElement1(list3); getElement1(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); }// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll){}// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll){} 反射何为反射反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。 通过反射你可以获取任意一个类的所有属性和方法，并调用这些方法和属性。 反射的应用场景了解么？Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。 像 Java 中的一大利器 注解 的实现也用到了反射。基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。 反射机制的优缺点优点：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利 缺点：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点（编译器无法优化，无法使用 JIT），不过，对于框架来说实际是影响不大的。 反射原理​ 要想通过反射获取一个类的信息，首先要获取该类对应的Class类实例（Class 对象），Class类的实例代表了正在运行中的Java应用的类和接口。Class类没有公共的构造方法，Class类对象是在二进制字节流（一般是.class文件，也可通过网络或zip包等路径获取）被JVM加载时，通过调用类加载器的defineClass()方法来构建的。（译自Class类的JDK源码） ​ JVM在加载阶段要完成的3件事情中正好有Class对象的生成： 通过一个类的全限定名来获取定义此类的二进制字节流（.class字节码文件）。 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构（hotspot vm 中即InstanceKlass，即元数据）。 在内存（堆）中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 获取 Class 对象的四种方式12345678910111213//1. 知道具体类的情况下可以使用：Class alunbarClass = TargetObject.class;//2. 通过 Class.forName()传入类的全路径获取：Class alunbarClass1 = Class.forName(\"cn.javaguide.TargetObject\");//3. 通过对象实例instance.getClass()获取：TargetObject o = new TargetObject();Class alunbarClass2 = o.getClass();//4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取:ClassLoader.getSystemClassLoader().loadClass(\"cn.javaguide.TargetObject\");//通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行 反射的一些基本操作 创建一个我们要使用反射操作的类 TargetObject。 123456789101112131415public class TargetObject { private String value; public TargetObject() { value = \"JavaGuide\"; } public void publicMethod(String s) { System.out.println(\"I love \" + s); } private void privateMethod() { System.out.println(\"value is \" + value); }} 使用反射操作这个类的方法以及参数 1234567891011121314151617181920212223242526272829import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class test_targetObject { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { Class&lt;?&gt; targetObject = Class.forName(\"TargetObject\"); Object o = targetObject.newInstance(); for (Method declaredMethod : targetObject.getDeclaredMethods()) { System.out.println(declaredMethod); } Method publicMethod = targetObject.getDeclaredMethod(\"publicMethod\", String.class); publicMethod.invoke(o, \"fml\"); Field value = targetObject.getDeclaredField(\"value\"); //为了调用private方法我们取消安全检查 value.setAccessible(true); value.set(o, \"fmlzuibang\"); /** * 调用 private 方法 */ Method privateMethod = targetObject.getDeclaredMethod(\"privateMethod\"); privateMethod.setAccessible(true); privateMethod.invoke(o); }} 注解何谓注解Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。 注解本质是一个继承了Annotation 的特殊接口： 123456789@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {}public interface Override extends Annotation{} JDK 提供了很多内置的注解（比如 @Override、@Deprecated），同时，我们还可以自定义注解。 注解的解析方法有哪几种？注解只有被解析之后才会生效，常见的解析方法有两种： 编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。 运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。 SPI何谓 SPI?SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”。一种服务发现机制，允许在运行时动态地加载实现特定接口的类，而不需要在代码中显式地指定该类，从而实现解耦和灵活性。 SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。 SPI 和 API 有什么区别？说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下： 一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。 当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。 Java SPI 的优缺点？优点： 松耦合度：在运行时动态加载实现类，而无需在编译时将实现类硬编码到代码中 扩展性：可以为同一个接口定义多个实现类。这使得应用程序更容易扩展和适应变化。 缺点： 安全性不足：SPI提供者必须将其实现类名称写入到配置文件中，因此如果未正确配置，则可能存在安全风险。 性能损失：每次查找服务提供者都需要重新读取配置文件，这可能会增加启动时间和内存开销。 上面对Java SPI的缺点说了一下，我们来说一下：Spring的SPI机制相对于Java原生的SPI机制进行了改造和扩展，主要体现在以下几个方面： 支持多个实现类：Spring的SPI机制允许为同一个接口定义多个实现类，而Java原生的SPI机制只支持单个实现类。这使得在应用程序中使用Spring的SPI机制更加灵活和可扩展。 支持自动装配：Spring的SPI机制支持自动装配，可以通过将实现类标记为Spring组件（例如@Component），从而实现自动装配和依赖注入。这在一定程度上简化了应用程序中服务提供者的配置和管理。 支持动态替换：Spring的SPI机制支持动态替换服务提供者，可以通过修改配置文件或者其他方式来切换服务提供者。而Java原生的SPI机制只能在启动时加载一次服务提供者，并且无法在运行时动态替换。 提供了更多扩展点：Spring的SPI机制提供了很多扩展点，例如BeanPostProcessor、BeanFactoryPostProcessor等，可以在服务提供者初始化和创建过程中进行自定义操作。 应用场景Java SPI机制是一种服务提供者发现的机制，适用于需要在多个实现中选择一个进行使用的场景。 常见的应用场景包括： 应用名称 具体应用场景 数据库驱动程序加载 JDBC为了实现可插拔的数据库驱动，在Java.sql.Driver接口中定义了一组标准的API规范，而具体的数据库厂商则需要实现这个接口，以提供自己的数据库驱动程序。在Java中，JDBC驱动程序的加载就是通过SPI机制实现的。 日志框架的实现 流行的开源日志框架，如Log4j、SLF4J和Logback等，都采用了SPI机制。用户可以根据自己的需求选择合适的日志实现，而不需要修改代码。 Spring框架 Spring框架中的Bean加载机制就使用了SPI思想，通过读取classpath下的META-INF/spring.factories文件来加载各种自定义的Bean。 Dubbo框架 Dubbo框架也使用了SPI思想，通过接口注解@SPI声明扩展点接口，并在classpath下的META-INF/dubbo目录中提供实现类的配置文件，来实现扩展点的动态加载。 参考：https://blog.csdn.net/qq_52423918/article/details/130968307 序列化和反序列化什么是序列化?什么是反序列化? 序列化：将数据结构或对象转换成二进制字节流的过程 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过 序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。 序列化协议对应于 TCP/IP 4 层模型的哪一层？ 应用层（表示层） 如果有些字段不想进行序列化怎么办？使用 transient 关键字修饰 关于 transient 还有几点注意： transient 只能修饰变量，不能修饰类和方法。 transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。 static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。 JDK 自带的序列化方式JDK 自带的序列化，只需实现 java.io.Serializable接口即可。 serialVersionUID 有什么作用？序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？static 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。但是，serialVersionUID 的序列化做了特殊处理，在序列化时，会将 serialVersionUID 序列化到二进制字节流中；在反序列化时，也会解析它并做一致性判断。 为什么不推荐使用 JDK 自带的序列化？ 性能差 存在安全问题 不支持跨语言调用 I/OJava IO 流了解吗？IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。 Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 I/O 流为什么要分为字节流和字符流呢?问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？ 字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时（字节流优势）； 如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题（字符流优势）。 代理模式一种设计模式：使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，扩展目标对象的功能。（比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。） 静态代理 实现和应用角度： ​ 对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类） JVM 层面： ​ 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 静态代理实现步骤: 定义一个接口及其实现类； 创建一个代理类同样实现这个接口 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。 动态代理JDK 动态代理机制在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。 使用步骤： 定义一个接口及其实现类； 定义一个实现 InvocationHandler 并重写invoke方法的类，在 invoke 方法中会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 12345678public interface InvocationHandler { /** * 当你使用代理对象调用方法的时候实际会调用到这个方法 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;} 通过 Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法创建代理对象； 12345678910/**loader :类加载器，用于加载代理对象。* interfaces : 被代理类实现的一些接口；* h : 实现了 InvocationHandler 接口的对象；**/public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException{ ......} CGLIB 动态代理机制在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer类是核心。 使用步骤 定义一个类； 自定义 MethodInterceptor 并重写 intercept 方法，intercept用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似； 123456789101112131415161718192021222324import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * 自定义MethodInterceptor */public class DebugMethodInterceptor implements MethodInterceptor { /** * @param o 被代理的对象（需要增强的对象） * @param method 被拦截的方法（需要增强的方法） * @param args 方法入参 * @param methodProxy 用于调用原始方法 */ @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { //调用方法之前，我们可以添加自己的操作 System.out.println(\"before method \" + method.getName()); Object object = methodProxy.invokeSuper(o, args); //调用方法之后，我们同样可以添加自己的操作 System.out.println(\"after method \" + method.getName()); return object; }} 通过 Enhancer 类的 create()创建代理类； 1234567891011121314151617import net.sf.cglib.proxy.Enhancer;public class CglibProxyFactory { public static Object getProxy(Class&lt;?&gt; clazz) { // 创建动态代理增强类 Enhancer enhancer = new Enhancer(); // 设置类加载器 enhancer.setClassLoader(clazz.getClassLoader()); // 设置被代理类 enhancer.setSuperclass(clazz); // 设置方法拦截器 enhancer.setCallback(new DebugMethodInterceptor()); // 创建代理类 return enhancer.create(); }} JDK 动态代理和 CGLIB 动态代理对比 JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀 静态代理和动态代理的对比 灵活性：动态代理更加灵活，不需要必须实现接口（静态代理、jdk 动态代理），可以直接代理实现类(CGLIB)，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！ JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。 集合 集合框架底层数据结构总结List ArrayList：Object[] 数组。详细可以查看：ArrayList 源码分析。 Vector：Object[] 数组。 LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：LinkedList 源码分析。 Set HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素。 LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。 TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)。 Queue PriorityQueue: Object[] 数组来实现小顶堆。详细可以查看：PriorityQueue 源码分析。 DelayQueue:PriorityQueue。详细可以查看：DelayQueue 源码分析。 ArrayDeque: 可扩容动态双向数组。 再来看看 Map 接口下面的集合。 Map HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。详细可以查看：HashMap 源码分析。 LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：LinkedHashMap 源码分析 Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。 TreeMap：红黑树（自平衡的排序二叉树）。 ListArrayList 和 Array（数组）的区别？ArrayList 内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活： 动态地扩容或缩容 使用泛型来确保类型安全 只能存储对象（Array 都可以） 不需要指定大小 ArrayList 插入和删除元素的时间复杂度？尾部插入：当 ArrayList 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。 LinkedList 插入和删除元素的时间复杂度？ 指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。 LinkedList 为什么不能实现 RandomAccess 接口？RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！是为了能够更好地判断集合是否ArrayList或者LinkedList，从而能够更好选择更优的遍历方式，提高性能！（Collections类中的binarySearch（）） ArrayList 与 LinkedList 区别?底层数据结构 插入和删除是否受元素位置的影响 是否支持快速随机访问 内存空间占用 **ArrayList 的扩容机制 先从 ArrayList 的构造函数说起 有三种构造方法 1234567891011121314/** * 带初始容量参数的构造函数。（用户自己指定容量） */public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) {//初始容量大于0 //创建initialCapacity（10）大小的数组 this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) {//初始容量等于0 //创建空数组 this.elementData = EMPTY_ELEMENTDATA; } else {//初始容量小于0，抛出异常 throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity); }} 以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。 add 方法 这里以无参构造函数创建的 ArrayList 为例分析，即一开始为空的数组。 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为 10。此时，minCapacity - elementData.length &gt; 0成立，所以会进入 grow(minCapacity) 方法。 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity)方法。 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。 直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。 grow 方法 1private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数. 需要保证newCapacity&gt;=minCapacity 假如newCapacity &gt; MAX_ARRAY_SIZE需要进一步进入hugeCapacity() 方法判断minCapacity &gt; MAX_ARRAY_SIZE 无序性和不可重复性的含义是什么 无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。 不可重复性是指添加的元素按照 equals() 判断时 ，返回 false，需要同时重写 equals() 方法和 hashCode() 方法。 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同同： HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。 异： HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。 底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。 QueueQueue 与 Deque 的区别Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。 Deque 是双端队列，在队列的两端均可以插入或删除元素。 Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。 1Deque&lt;Integer&gt; a = new LinkedList&lt;&gt;(); ArrayDeque 与 LinkedList 的区别ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？ ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。 ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。 ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。 从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。 说一说 PriorityQueue PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据 PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。 PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。 PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。 PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。 Map（重要）HashMap 和 Hashtable 的区别 线程是否安全 效率 对 Null key 和 Null value 的支持 初始容量大小和每次扩充容量大小的不同: ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小 底层数据结构:JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间 HashMap 和 HashSet 区别如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。 HashMap 和 TreeMap 区别相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。 HashSet 如何检查重复?当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。 HashMap 的底层实现JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashcode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法影响性能 换句话说使用扰动函数之后可以减少碰撞。 JDK 1.8 HashMap 的 hash 方法源码: JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。 1234567 static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。 HashMap 的长度为什么是 2 的幂次方Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。散列值是不能直接拿来用的。 用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n 代表数组长度）。一开始想到的是 % 取余 但是效率比 按位与 低。这也就解释了 HashMap 的长度为什么是 2 的幂次方。 解释：（只有 n 为 2 的幂次方，n-1 用二进制表示时低位才可能都是 1，与 hash 做按位&amp; 才能得到全部低位数据） HashMap 多线程操作导致死循环问题JDK1.7 及之前版本的 HashMap 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。 为了解决这个问题，JDK1.8 版本的 HashMap 采用了尾插法而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在数据覆盖的问题。并发环境下，推荐使用 ConcurrentHashMap 。 *HashMap 为什么线程不安全？JDK1.7 及之前版本，在多线程环境下，HashMap 扩容时会造成死循环和数据丢失的问题。 数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在 情况 1：哈希冲突，导致两个线程同时进行 hash 判断都可以插入，a 线程判断可以插入后挂起，b 线程执行插入，完成后另a 线程继续执行插入导致数据被覆盖 情况 2：两个线程同时 put 操作导致 size 的值只增加了 1，实际上只有一个元素被添加到了 HashMap 中，进而导致数据覆盖的问题 ConcurrentHashMap 和 Hashtable 的区别底层数据结构 JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。 Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的； 实现线程安全的方式（重要） 在 JDK1.7 的时候，ConcurrentHashMap 对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图） 到了 JDK1.8 的时候，ConcurrentHashMap 已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并使用 synchronized 、CAS 、node来保证并发安全。 （未发生 hash 冲突时，采用 CAS加入新 node 到数组中；若发生 hash冲突时，采用 synchronized 来添加该节点到链表 or 红黑树） Hashtable(同一把锁) :使用 synchronized 来保证线程安全，锁住整个数组，效率底下。 Hashtable : JDK1.7 的 ConcurrentHashMap： Segment 数组中的每个元素包含一个 HashEntry 数组，每个 HashEntry 数组属于链表结构。 JDK1.8 的 ConcurrentHashMap： JDK1.8 的 ConcurrentHashMap 不再是 Segment 数组 + HashEntry 数组 + 链表，而是 Node 数组 + 链表 / 红黑树。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **TreeNode**。当冲突链表达到一定长度时，链表会转换成红黑树。 CAS&amp;synchronizedCAS：在判断数组中当前位置为null的时候，使用CAS来把这个新的Node写入数组中对应的位置 synchronized ：当数组中的指定位置不为空时，通过加锁来添加这个节点进入数组(链表&lt;8)或者是红黑树（链表&gt;=8） 所以这部分是进行了cas： else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin } ConcurrentHashMap 为什么 key 和 value 不能为 null？避免二义性： 值没有在集合中 ； 值本身就是 null。 单线程下可以容忍歧义，而多线程下无法容忍 并发Java 线程和操作系统的线程有啥区别？一句话概括 Java 线程和操作系统线程的关系：现在的 Java 线程的本质其实就是操作系统的线程。 线程持有读锁还能获取写锁吗？【1】在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。【2】在线程持有写锁的情况下，该线程可以继续获取读锁(获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败)。 原因：当线程获取读锁的时候，可能有其他线程也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让他获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。 线程池处理任务的流程了解吗？ JVM垃圾回收JVM是如何判断一个对象是可回收的？引用计数法 难解决对象之间循环引用 可达性分析算法 基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。 讲一下JVM调优过程？https://zhuanlan.zhihu.com/p/488615913 分析和定位当前系统的瓶颈 1）CPU指标 123456// 显示系统各个进程的资源使用情况top// 查看某个进程中的线程占用情况top -Hp pid// 查看当前 Java 进程的线程堆栈信息jstack pid 2）JVM 内存指标 123456// 查看 Java 进程的配置信息，包括系统属性和JVM命令行标志jinfo pid// 输出 Java 进程当前的 gc 情况jstat -gc pid// 输出 Java 堆详细信息jmap -heap pid 制订优化方案 代码bug：升级修复bug。典型的有：死循环、使用无界队列。 不合理的JVM参数配置：优化 JVM 参数配置。典型的有：年轻代内存配置过小、堆内存配置过小、元空间配置过小。 对比优化前后的指标，统计优化效果 GC日志查看可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。 123456-XX:+PrintGC 输出GC日志-XX:+PrintGCDetails 输出GC的详细日志-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息-Xloggc:../logs/gc.log 日志文件的输出路径 MySQL执行一条 SQL 查询语句，期间发生了什么？ 连接器：建立连接、管理链接、校验个人身份 查询缓存：key-value形式——查询语句是否命中 解析器：词法解析、语法解析，建立语法树 执行 SQL： 预处理阶段：判断是否存在表面、字段名；将*替换成全部列 优化阶段：基于查询成本，选择最佳的执行计划 执行阶段：根据执行计划执行 SQL查询语句，从存储引擎读取记录，返回给客户端 MySQL 一行记录是怎么存储的？ MySQL 的 NULL 值是怎么存放的？ MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。 NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。 MySQL 怎么知道 varchar(n) 实际占用数据的大小？ MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。 varchar(n) 中 n 最大取值为多少？ 一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。 如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。 计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。 如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= 65535。 行溢出后，MySQL 是怎么处理的？ 如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。 Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。 Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？1、B+Tree vs B Tree B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。 B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。 B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化； 2、B+Tree vs 二叉树 对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。 在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 34 层左右，也就是说一次数据查询操作只需要做 34 次的磁盘 I/O 操作就能查询到目标数据。 而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。 3、B+Tree vs Hash Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。 但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。 联合索引范围查询联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配 索引下推 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 什么时候需要 / 不需要创建索引？需要： 字段唯一；经常用于where查询的字段；经常用于 groupby和 orderby 的字段 不需要：区分度小的；数据少的；经常更新的 有什么优化索引的方法？ 前缀索引优化； 提高索引的查询速度；减小索引项的大小 覆盖索引优化； 不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。 主键索引最好是自增的； 避免页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。 防止索引失效； 使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式 在查询条件中对索引列做了计算、函数、类型转换操作 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列 可能会出现其他的索引失效场景，这时我们就需要查看执行计划，通过执行计划显示的数据判断查询语句是否使用了索引。 聚簇索引&amp;二级索引如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。 在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。 MySQL 使用 like “%x“，索引一定会失效吗？从这个思考题我们知道了，使用左模糊匹配（like “%xx”）并不一定会走全表扫描，关键还是看数据表中的字段。 如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。 count(*) 和 count(1) 有什么区别？哪个性能最好？count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。 所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。 再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。 事务有哪些特性？原子性（Atomicity） 一个事务中的所有操作，要么全部完成，要么全部不完成 一致性（Consistency） 数据满足完整性约束，数据库保持一致性状态 隔离性（Isolation） 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 持久性（Durability） 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？原子性是通过 undo log（回滚日志）; 一致性则是通过持久性+原子性+隔离性来保证； 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的； 持久性是通过 redo log （重做日志）来保证的； 并行事务会引发什么问题？脏读如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。 不可重复读在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。 幻读在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。 事务的隔离级别有哪些？ Read View Read View 中四个字段作用； 聚簇索引记录中两个跟事务有关的隐藏列； trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里； roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。 MVCC通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对,来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同： 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View 「可重复读」隔离级别是启动事务时生成一个 Read View 对于幻读现象，不建议将隔离级别升级为串行化。MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读 MySQL 可重复读隔离级别，完全解决幻读了吗？场景一： 对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。 场景二： T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。 T2 时刻：事务 B 往插入一个 id= 200 的记录并提交； T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。 总结： 所以，MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。 要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。 MySQL 行级锁的加锁规则唯一索引等值查询： 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。 当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」。 非唯一索引等值查询： 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。 当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。 非唯一索引和主键索引的范围查询的加锁规则不同之处在于： 唯一索引在满足一些条件的时候，索引的 next-key lock 退化为间隙锁或者记录锁。 非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。 其实理解 MySQL 为什么要这样加锁，主要要以避免幻读角度去分析，这样就很容易理解这些加锁的规则了。 还有一件很重要的事情，在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。 MySQL日志具体更新一条记录 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 的流程如下: 执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录： 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新； 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。 执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样： 如果一样的话就不进行后续更新流程； 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作； 开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。 InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。 至此，一条记录更新完了。 在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。 事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）： prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘； commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）； 至此，一条更新语句执行完成。 Buffer PoolInnodb 存储引擎设计了一个缓冲池（*Buffer Pool*），来提高数据库的读写性能。 Buffer Pool 以页为单位缓冲数据，可以通过 innodb_buffer_pool_size 参数调整缓冲池的大小，默认是 128 M。 Innodb 通过三种链表来管理缓页： Free List （空闲页链表），管理空闲页； Flush List （脏页链表），管理脏页； LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。； InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化： 将 LRU 链表 分为young 和 old 两个区域，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。 当「页被访问」且「 old 区域停留时间超过 innodb_old_blocks_time 阈值（默认为1秒）」时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。 可以通过调整 innodb_old_blocks_pct 参数，设置 young 区域和 old 区域比例。 在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。 Linux查看内存 12free -hcat /proc/meminfo 查看 cpu 信息 12lscpucat /proc/cpuinfo linux查看tcp的状态命令： netstat -nat 查看TCP各个状态的数量 lsof -i:port 可以检测到打开套接字的状况 sar -n SOCK 查看tcp创建的连接数 tcpdump -iany tcp port 9000 对tcp端口为9000的进行抓包 计算机网络TCP为什么需要 TCP 协议？ TCP 工作在哪一层？网络层不可靠，如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。 为什么要三次握手？不是两次或者四次SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应 三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 不使用「两次握手」和「四次握手」的原因： 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号； 「四次握手」：三次握手就已经理论建立可靠连接，所以不需要使用更多的通信次数。 为什么挥手需要四次？再来回顾下四次挥手双方发 FIN 包的过程，就能理解为什么需要四次了。 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。 从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，因此是需要四次挥手。 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命） 确保服务端收到客户端的 ack 确保上一次的 tcp 报文信息不会影响下一次的 tcp 连接 TCP 如何保证传输的可靠性？ 基于数据块传输 对失序数据包重排以及去重 校验和 重传机制 流量控制 拥塞控制 TCP 如何实现流量控制？TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。 TCP 发送窗口可以划分成四个部分： 已经发送并且确认的 TCP 段（已经发送并确认）； 已经发送但是没有确认的 TCP 段（已经发送未确认）； 未发送但是接收方准备接收的 TCP 段（可以发送）； 未发送并且接收方也并未准备接受的 TCP 段（不可发送） TCP 接收窗口可以划分成三个部分： 已经接收并且已经确认的 TCP 段（已经接收并确认）； 等待接收且允许发送方发送 TCP 段（可以接收未确认）； 不可接收且不允许发送方发送 TCP 段（不可接收）。 TCP 的拥塞控制是怎么实现的？拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。 为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。 拥塞控制主要是四个算法: 慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。指数性的增长 拥塞避免：每当收到一个 ACK 时，cwnd 增加 1/cwnd。线性增长 快速重传：ssthresh设为cwnd/2，cwnd 重置为ssthresh，进入快速恢复算法。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。 快速恢复：将 cwnd 变为 ssthresh，开始拥塞避免 HTTPHTTP vs HTTPS（应用层）HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息。 HTTP 协议优点：扩展性强、速度快、跨平台支持性好。 HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443. HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特 HTTPS协议优点：保密性好、信任度高。 HTTP 和 RPC 有什么区别 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。 HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。 操作系统虚拟内存操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。 分段问题： 外部内存碎片 内存交换的效率低（段太大，导致内存交换代价高） 分页：分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小 页表：虚拟地址与物理地址之间通过页表来映射 多级页表 页表一定要覆盖全部虚拟地址空间 如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表 大小页面的优缺点 页面小可以减少内部碎片的浪费，但页表项相对较多；页面大可以减少页表项，增加TLB命中率，但是内部碎片浪费较严重。具体系统选择应该根据业务需求来决定。 Kafka为什么 redis Pub/Sub 比 kafka 更快一些？二者如何选取Redis是一个内存数据库，其Pub/Sub功能将消息保存在内存中。由于内存访问速度通常远快于磁盘访问速度，因此Redis在处理实时性较高的消息推送时具有优势；Redis的Pub/Sub模型相对简单，使得它在处理发布和订阅操作时的开销较小。 Kafka是一个完整的系统，提供了高吞吐量、分布式的提交日志。它旨在处理大规模数据流，具有强大的持久化能力和容错性。Kafka的分布式架构和分区机制使得它能够在多个消费者之间实现负载均衡，从而提高整体处理能力。 Redis PUB/SUB使用场景： 消息持久性需求不高 吞吐量要求不高 可以忍受数据丢失 数据量不大 Kafka使用场景：(上面以外的其他场景) 高可靠性 高吞吐量 持久性高 多样化的消费处理模型","link":"/project/2024/03/11/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"面经","slug":"面经","link":"/project/tags/%E9%9D%A2%E7%BB%8F/"}],"categories":[],"pages":[]}